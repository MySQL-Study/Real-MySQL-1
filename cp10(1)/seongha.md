## 9.3.2 조인 최적화 알고리즘

조인 쿼리의 실행 계획 최적화를 위한 알고리즘이 2개 있다. 
- Exhaustive 검색 알고리즘
- Greedy 검색 알고리즘

### 9.3.2.1 Exhaustive 검색 알고리즘 (완전 탐색)
5.0과 이전 버전에서 사용되던 조인 최적화 기법이다. 
FROM절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다. 
![](https://velog.velcdn.com/images/pi1199/post/f6ea2aa0-fc72-4625-8709-68dde8840a5e/image.png)

위의 그림은 t1~t4 테이블을 조인할 때 모든 경우의 수를 찾는 것을 보여준다.
`n!`개의 경우의 수를 찾기에 테이블이 추가될수록 탐색 시간이 오래 걸린다. 

### 9.3.2.2 Greedy 알고리즘
위의 완전탐색 방법의 시간 문제를 해결하기 위해 등장했다. 
각 단계에서 최적이라고 판단되는 테이블을 하나씩 추가하면서 실행 계획을 완성하는 방식이다.
![](https://velog.velcdn.com/images/pi1199/post/df04fec9-b06a-4a47-af65-e72821f2b082/image.png)

1. 전체 N개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
2. 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
3. 선정된 실행 계획의 첫 번째 테이블을 "부분 실행 계획"의 첫 번째 테이블로 선정
4. 전체 N-1개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
5. 생성된 조인 조합들을 하나씩 3번에서 생성된 부분 실행 계획에 대입해 실행 비용을 계산
6. 비용 계산 결과 최적의 실행 계획에서 두 번쨰 테이블을 3번에서 생성된 "부분 실행 계획"의 두 번째 테이블로 선정
7. 남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복 실행하면서 "부분 실행 계획"에 테이블의 조인 순서를 기록
8. 최종적으로 "부분 실행 계획"이 테이블의 조인 순서로 결정됨

조인 순서는 한 번에 하나씩 확정되며, 이전까지 확정된 테이블과 새로운 테이블을 조합하여 실행 비용을 비교하면서 최적의 순서를 찾는다.

`optimizer_search_depth` 의 기본값은 62이다. 62를 넘어가면 62까지는 그리디를 사용하고 나머지는 완전탐색을 이용하게 된다. 또한, 0으로 설정하면 mysql 옵티마이저가 자동으로 결정한다. 그러나 쿼리에 영향을 끼칠 수 있기에 4~5 정도가 적당하다. 
![](https://velog.velcdn.com/images/pi1199/post/787d7724-b250-4ef0-8a1f-93bd8c497db5/image.png)


# 9.4 쿼리 힌트
MySQL 서버가 개발자나 DBA보다 부족한 실행 계획을 수립할 때가 있다. 이런 경우 옵티마이저에게 어떻게 실행 계획을 수립해야하는지 알려줄 필요가 있다. 이런 목적으로 쿼리 힌트를 사용한다. 
MySQL 서버에서 사용 가능한 쿼리 힌트는 다음과 같이 2가지로 구분할 수 있다.

- 인덱스힌트
- 옵티마이저 힌트

## 9.4.1 인덱스 힌트
`STRAIGHT_JOIN`과 `USE INDEX` 등을 포함한 인덱스 힌트들은 모두 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능들이다. 
이들은 모두 SQL의 문법에 맞게 사용해야 하기 때문에 사용하게 되면 ANSI-SQL 표준 문법을 준수하지 못하게 되는 단점이 있다. 
5.6 버전부터 추가되기 시작한 옵티마이저 힌트들은 모두 MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석하기 때문에 ANSI-SQL 표준을 준수한다고는 볼 수 있다. 
그래서 가능하다면 인덱스 힌트보다는 옵티마이저 힌트를 사용할 것을 추천한다. 
또한 인덱스 힌트는 SELECT 명령과 UPDATE 명령에서만 사용할 수 있다.

### STRAIGHT_JOIN
옵티마이저 힌트인 동시에 조인 키워드이기도 하다.
SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.
다음 쿼리는 3개의 테이블을 조인하지만 어느 테이블이 드라이빙 테이블이 되고 어느 테이블이 드리븐 테이블이 될지 알 수 없다.
```SQL 
SELECT *
	FROM employees e, dept_no de, departments d
	WHERE e.emp_no=de.emp_no AND d.dept_no=de.dept_no;
```
일반적으로 조인을 하기 위한 컬럼들의 인덱스 여부로 조인의 순서가 결정되며 조인 컬럼의 인덱스에 아무런 문제가 없는 경우에는 레코드가 적은 테이블을 드라이빙으로 선택한다.

하지만, 이 쿼리의 조인 순서를 변경하려는 경우에는 STRAIGHT_JOIN 힌트를 사용할 수 있다. 
인덱스 힌트는 SELECT 키워드 뒤로 사용할 위치가 정해져 있으므로 주의하자.
```SQL
SELECT STRAIGHT_JOIN
 	   e.first_name, e.last_name, d.dept_name
       FROM employees e, dept_emp de, departments d
       WHERE e.emp_no=de.emp_no AND d.dept_no=de.dept_no;
```
STRAIGHT_JOIN 힌트는 옵티마이저가 FROM 절에 명시된 테이블의 순서대로(employees -> dept_emp -> departments) 조인을 수행하도록 유도한다.


주로 다음 기준에 맞게 조인 순서가 결정되지 않는 경우에만 STRAIGHT_JOIN 힌트로 조인 순서를 조정하는 것이 좋다.

- 임시 테이블과 일반 테이블 조인
일반적으로 임시 테이블을 드라이빙 테이블로 선택하는 것이 좋다. 
레코드 테이블의 조인 칼럼에 인덱스가 없는 경우 레코드 건수가 작은 쪽을 드라이빙 테이블로 하는게 좋다.

- 임시 테이블끼리 조인 
항상 인덱스가 없기 때문에 크기가 작은 테이블을 드라이빙 테이블로 하는게 좋다. 

- 일반 테이블끼리 조인 
두 테이블 모두 조인 칼럼에 인덱스가 있거나, 없다면 레코드가 적은 테이블을 드라이빙 테이블로 하는게 좋다.
한 쪽만 조인 칼럼에 인덱스가 있다면, 인덱스가 없는 테이블을 드라이빙테이블로 하는게 좋다. 

STRAIGHT_JOIN 힌트와 비슷한 역할을 하는 옵티마이저 힌트로는 다음이 있다.
- JOIN_FIXED_ORDER
- JOIN_ORDER
- JOIN_PREFIX
- JOIN_SUFFIX



### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX

인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다. 
3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여러 개 존재하는 경우에는 가끔 옵티마이저가 실수를 하는데 이런 경우에는 강제로 특정 인덱스를 사용하도록 힌트를 추가한다.

인덱스 힌트는 크게 다음과 같이 3종류가 있다. 
3종류의 인덱스 모두 키워드 뒤에 사용할 인덱스의 이름을 괄호로 묶어서 사용하며, 괄호 안에 아무것도 없거나 존재하지 않는 인덱스 이름을 사용할 경우에는 쿼리의 문법 오류로 처리한다.

- USE INDEX
옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트이다. 항상 그 인덱스를 사용하는 것은 아니다.
- FORCE INDEX
USE INDEX보다 옵티마이저에 미치는 영향이 강한 힌트이다. (차이가 업다고 보면되서 거의 사용하지 않는다.)
- IGNORE INDEX
특정 인덱스를 사용하지 못하게 하는 용도로 사용하는 힌트다. 
옵티마이저가 풀 테이블 스캔을 사용하도록 유도하기 위해 사용한다.


인덱스 용도를 명시할 수 있지만, 옵티마이저가 잘 선택하기에 용도까지는 고려하지 않아도 된다. 
나중에 필요하다면 p.374를 참고하자 

### 9.4.1.3 SQL_CALC_DOUND_ROWS

Limit 를 사용하는 경우 조건을 만족하는 레코드가 많더라도 Limit 개수만큼 찾았다면 탐색을 중단한다. 
그러나 `SQL_CALC_DOUND_ROWS` 힌트가 사용된 쿼리는 Limit 개수만큼 찾아도 끝까지 탐색을 계속한다. 
-> 예제를 본 결과 count를 위해서 사용한다면 오히려 성능저하가 발생하니 그냥 count쿼리와 조회쿼리 2가지를 사용하자

## 9.4.2 옵티마이저 힌트 


### 9.4.2.1 옵티마이저 힌트 종류 

옵티마이저 힌트는 영향 범위에 따라 다음 4개 그룹으로 나뉜다.

- 인덱스 : 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- 테이블 : 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- 쿼리 블록 : 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트로서 특정 쿼리 블록의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
- 글로벌(쿼리 전체) : 전체 쿼리에 대해서 영향을 미치는 힌트


### 9.4.2.2 MAX_EXECUTION_TIME

옵티마이저 힌트 중에서 유일하게 쿼리의 실행 계획에 영향을 미치지 않으며, 단순히 쿼리의 최대 실행 시간을 설정하는 힌트다. 여기에 지정한 시간을 초과하면 쿼리는 실패한다.

### 9.4.2.3SET_VAR
SET_VAR는 실행 계획을 바꾸는 용도뿐 아니라 조인 버퍼나 정렬용 버퍼(소트 버퍼)의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도로 사용할 수 있다.

### 9.4.2.4 SEMIJOIN & NO_SEMIJOIN
SEMIJOIN 힌트는 어떤 세부 전략을 사용할지 제어하는 데 사용할 수 있다.
최적화 전략들은 상황에 따라 다른 최적화 전략으로 우회하는 것이 더 나은 성능을 낼 수도 있기 때문에 NO_SEMIJOIN 힌트도 제공된다.

### 9.4.2.5 SUBQUERY
서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법이다.

### 9.4.2.6 BNL & NO_BNL & HASHJOIN & NO_HASHJOIN

8.0.20 버전부터는 해시 조인이 블록 네스티드 루프 조인까지 대체했다. 
그래서 8.0.20 버전 이후에는 해시 조인을 유도하거나 해시조인을 사용하지 않게 하고자 할 때 이런 힌트들을 사용한다.


### 9.4.2.7 JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
조인의 순서를 결정하기 위해 전통적으로 사용했던 STRAIGHT_JOIN 힌트의 단점을 보완한 힌트들이다.

- `JOIN_FIXED_ORDER` : STRAIGHT_JOIN과 동일하게 FROM 절의 테이블 순서대로 조인을 실행하는 힌트
- `JOIN_ORDER` : FROM 절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
- `JOIN_PREFIX` : 조인에서 드라이빙 테이블만 강제하는 힌트
- `JOIN_SUFFIX` : 조인에서 드리븐 테이블만 강제하는 힌트

### 9.4.2.8 MERGE & NO_MERGE

예전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리를 항상 내부 임시 테이블(파생 테이블)로 생성했다. 이는 불필요한 자원 소모를 유발한다. 
그래서 5.7, 8.0 버전에서는 가능하면 임시 테이블을 사용하지 않게 FROM 절의 서브쿼리를 외부 쿼리와 병합하는 최적화를 도입했다.
병합 여부에 대해 옵티마이저가 최적의 방법을 선택하지 못할 때, MERGE, NO_MERGE 힌트를 사용한다.

### 9.4.2.9 INDEX_MERGE & NO_INDEX_MERGE
MySQL는 가능하다면 테이블당 하나의 인덱스만을 이용해 쿼리를 처리하려 한다. 하지만 하나만으로 부족하다면 여러 인덱스를 동시에 사용한다. 이를 인덱스 머지라고 한다.
인덱스 머지 실행 계획의 사용 여부를 결정할 때, 이 힌트들을 사용한다.

### 9.4.2.10 NO_ICP
인덱스 컨디션 푸시다운 최적화는 사용 가능하다면 항상 성능 향상에 도움이 되므로 기본적으로 항상 사용하는 방향으로 실행 계획을 수립한다.
하지만, 비용이 잘못 계산된다면 잘못된 계획을 수립할 수 있는데, 이때 인덱스 컨디션 푸시다운 최적화만 비활성화하는 힌트이다.

### 9.4.2.11 SKIP_SCAN & NO_SKIP_SCAN
인덱스 스킵 스캔은 인덱스의 선행 칼럼에 대한 조건 없이도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 최적화 기능이다. 하지만 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아지면 성능은 오히려 떨어진다.
인덱스 스킵 스캔의 사용 여부를 결정할 때, 이 힌트들을 사용한다.


### 9.4.2.12 INDEX & NO_INDEX
이 힌트들은 예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공된다.
인덱스 힌트는 특정 테이블 뒤에 사용했기 때문에 별도로 힌트 내에 테이블명 없이 인덱스 이름만 나열했다. 하지만 옵티마이저 힌트에는 테이블명과 인덱스 이름을 함께 명시해야 한다.


# 10 실행 계획
이 장에서는 실행 계획에 영향을 미치는 통계정보에 대해 살펴보고, 실행계획을 읽는 순서, 실행 계획에 출력되는 키워드, 그리고 알고리즘에 대해 살펴보겠다.

# 10.1 통계 정보 
5.7까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립해서 정확도가 떨어졌다.
8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.

## 10.1.1 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보이다.
통계정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다. 

### 10.1.1.1 MySQL 서버의 통계 정보
5.6 버전부터는 각 테이블의 통계 정보를 영구적으로 관리할 수 있게 개선되었다. (서버가 재시작 되어도 유지)
STATS_PERSISTENT 옵션으로 영구적으로 저장할지 말지를 결정할 수 있다. (기본값은 1(on))
STATS_AUTO_RECALC 옵션으로 통계 정보를 자동으로 수집할지 여부를 결정할 수 있다.

자동으로 통계정보가 갱신되는 이벤트들이 있는데 이로 인해 쿼리 실행 방법이 변경되는 경우가 있다. 
예를 들어 테이블이 새로 오픈되는 경우, 레코드가 대량으로 변경되는 경우 등등 여러 경우가 있다. 
이를 막기 위해서 `innodb_status_auto_recalc` 시스템 설정 변수를 off로 만들어 통계정보가 자동으로 갱신되지 않게 할 수 있다. 
그리고 db사용이 적은 시간대를 이용하여 통계정보를 갱신하도록 할 수 있다. 


## 10.1.2 히스토그램
8.0부터는 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

### 10.1.2.1 히스토그램 정보 수집 및 삭제

히스토그램 정보는 칼럼단위로 관리되고, `ANALYZE TABLE … UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다. 
수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드한다. 그래서 실제 히스토그램 정보를 조회하려면 column_statistics 테이블을 SELECT해서 참조할 수 있다.


8.0버전 에서는 2가지 히스토그램 타입이 지원된다.
- `Singleton` (싱글톤 히스토그램) :
칼럼값 개별로 레코드 건수를 관리하는 히스토그램, value-Based 히스토그램 또는 도수분포라고 불림 
- `Equi-Height` (높이 균형 히스토그램) : 
칼럼값 범위를 균등한 개수로 구분해서 관리하는 히스토그램, Height-Balanced 히스토그램이라고 불린다. 


히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값 범위가 관리된다. 
싱글톤은 칼럼 값(value) 별로 버킷이 할당되고, 높이 균형에서는 칼럼값의 범위별로 하나의 버킷이 할당된다. 
싱글톤은 각 버킷이 칼럼 값, 발생 빈도 비율 값을 가진다.(2개) 높이 균형은 각 버킷이 범위 시작값, 마지막값, 발생 빈도 비율, 각 버킷에 포함된 유니크 값 개수 값을 가진다.(4개)

예시에서는 싱글톤은 enum을 사용하는 성별에 사용되었고, 높이균형은 datetime을 사용하는 고용날짜에 사용되었다. 

히스토그램을 삭제할수도 사용하지 않도록 할 수도 있다. 다만, 쿼리가 달라질 수 있으니 주의하자.

### 10.1.2.2 히스토그램의 용도

히스토그램이 도입되기 이전에도 테이블과 인덱스에 대한 통계정보는 존재했다. 하지만, 테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크 값의 개수 정도였다. 

하지만, 실제 응용프로그램의 데이터는 균등하지 않은데 기존 통계정보는 이런 부분은 고려하지 못했다. 이런 단점을 보완하기 위해 히스토그램이 도입되었다.
히스토그램은 각 범위(버킷)별 레코드 건수와 유니크한 값 개수 정보를 가지기 때문에 훨씬 더 정확한 예측을 할 수 있다. 

히스토그램 정보가 없으면 옵티마이저는 데이터가 균등 분포라고 예측하지만, 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.
각 칼럼에 대해 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.

### 10.1.2.3 히스토그램과 인덱스 

실행 계획을 수립할 때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다. 이를 인덱스 다이브라고 표현한다. 
인덱스된 칼럼을 검색 조건으로 사용하는 경우, 인덱스 다이브가 항상 더 정확하기 때문에, 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

## 10.1.3 코스트 모델
전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델이라고 한다. 

코스트 모델은 mysql DB에 있는 2개 테이블에 저장돼 있는 설정값을 사용한다.
- `server_cost` : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- `engine_cost` : 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리\

`row_evaluate_cost` 스토리지 엔진이 반환한 레코드가 쿼리 조건에 일치하는지를 평가하는 단위.
작업 값이 증가할수록 풀 테이블 스캔과 같이 많은 레코드를 처리하는 쿼리의 비용이 높아지고, 반대로 레인지 스캔과 같이 적은 수의 레코드를 처리하는 쿼리의 비용이 낮아진다.
`key_compare_cost` 키 값의 비교 작업에 필요한 비용.
값이 증가할수록 레코드 정렬과 같이 키 값 비교 처리가 많은 경우 쿼리 비용이 높아진다.

코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것이다. 

자세한 내용은 p.411을 참고 

# 10.2 실행 계획 확인 
DESC 또는 EXPLAIN 명령으로 확인할 수 있다. 

## 10.2.1 실행 계획 출력 포멧 
FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON, TREE, 단순 테이블 형태로 선택할 수 있다.
```SQL
EXPLAIN FORMAT=TREE SELECT * FROM employees … ;
```


## 10.2.2 쿼리의 실행 시간 확인
EXPLAIN ANALYZE를 쓰면 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있다. 
이 명령은 항상 결과를 TREE 포맷으로 보여준다.

TREE 포맷 실행 계획에서 들여쓰기는 호출 순서를 의미하며, 다음 기준으로 읽으면 된다.
- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행


실행 계획에 나열된 필드들의 의미
- actual time 숫자 값이 2개 표시되는데, 첫 번째 숫자 값은 첫 번째 레코드를 가져오는 데 걸린 평균 시간이고, 두 번째 숫자 값은 마지막 레코드를 가져오는 데 걸린 평균 시간이다.
- rows 해당 테이블에서 읽은 조건에 일치하는 평균 레코드 건수를 의미한다.
- loops 해당 테이블에서 읽은 정보를 이용해 해당 레코드를 찾는 작업이 반복된 횟수를 의미한다.


# 10.3 실행 계획 분석

실행 계획이 어떤 접근방법을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱스를 사용하는지 등을 이해하는게 중요하다. 
실행 계획에서 위쪽에 출력된 결과일수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당한다.

## 10.3.1 id 칼럼

id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. 
하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여된다.
id 칼럼이 테이블 접근 순서를 의미하지는 않는다. 테이블 포맷으로 보면 접근 순서가 혼란스러울 수 있다. FORMAT=TREE로 보면 순서를 더 정확히 알 수 있다.

## 10.3.2 select_type 칼럼
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. 표시될 수 있는 값은 다음과 같다.


### 10.3.2.1 SIMPLE

UNION이나 서브쿼리를 사용하지 않은 단순한 SELECT 쿼리
아무리 복잡한 쿼리라도 SIMPLE인 단위 쿼리는 하나만 존재한다. 일반적으로 제일 바깥 SELECT 쿼리가 SIMPLE이다.

### 10.3.2.2 PRIMARY
UNION이나 서브쿼리를 가지는 SELECT 쿼리의 가장 바깥쪽에 있는 단위 쿼리
쿼리에서 PRIMARY인 단위 쿼리는 하나만 존재한다. 제일 바깥 SELECT 쿼리가 PRIMARY이다.

### 10.3.2.3 UNION

UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리들이다.
UNION의 첫 번째 단위 SELECT는 select_type이 DERIVED(union 결과를 모아서 저장하는 임시테이블을 뜻함)이다.

### 10.3.2.4 DEPENDENT UNION
UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다.
DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.


### 10.3.2.5 UNION RESULT
UNION (또는 UNION DISTINCT) 결과를 담아두는 테이블을 의미한다. 
UNION (또는 UNION DISTINCT)은 임시 테이블에 결과를 버퍼링한다.
UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id값은 부여되지 않는다.

UNION ALL은 임시 테이블을 생성하지 않는다. 

### 10.3.2.6 SUBQUERY

FROM절에 사용된 서브쿼리는 DERIVED로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY로 표시된다.

### 10.3.2.7 DEPENDENT SUBQUERY

서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우
외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브쿼리보다 느리다.


### 10.3.2.8 DERIVED
FROM절에 사용된 서브쿼리를 의미한다. 
8.0 버전부터는 최적화가 많이 개선되어 불필요한 서브쿼리는 조인으로 재작성된다.

### 10.3.2.9 DEPENDENT DERIVED
래터럴 조인이 사용된경우 DEPENDENT DERIVED가 표시된다.
래터럴 조인이 추가되면서 from 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 되었다. 

### 10.3.2.10 UNCACHEABLE SUBQUERY


서브쿼리의 결과는 내부 캐시 공간에 담겨서 재사용할 수 있다.
서브쿼리에 아래와 같은 요소들이 포함되면 캐시 자체가 불가능하며, 이때 UNCACHEABLE SUBQUERY로 표시된다.
- 사용자 변수
- NOT-DETERMINISTIC 속성의 스토어드 루틴
- 결괏값이 호출할 때마다 달라지는 함수


### 10.3.2.11 UNCACHEABLE UNION

캐시가 불가능한 UNION이다. 
위에서 두가지를 설명했는데 이를 조합한 것이다. 

### 10.3.2.12 MATERIALIZED
MATERIALIZED은 구체화 라는 의미이다. 
주로 FROM절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
임시 테이블로 구체화하여 조인하는 형태로 최적화 되어 사용된다. 


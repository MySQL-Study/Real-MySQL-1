# Chapter.9 옵티마이저와 힌트
### 9.3.2 조인 최적화 알고리즘
- 조인 쿼리의 실행 계획 최적화 위한 알고리즘
  - 2가지가 있음.
  - 중요성이 매우 큼.

#### 9.3.2.1 Exhaustive 검색 알고리즘
- MySQL 5.0과 그 이전 버전에서 사용되던 조인 최적화 기법
- FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법
- 이전 버전에서 Exhaustive 검색 알고리즘 : 실행 계획 수립 매우 오래 걸림.

#### 9.3.2.2 Greedy 알고리즘
- Exhaustive 검색 알고리즘의 시간 소모적인 문제점 해결하기 위해 MySQL 5.0부터 도입된 조인 최적화 기법<br>
    -> 조금 더 복잡한 형태로 최적의 조인 순서 결정
- `optimizer_search_depth` 시스템 변수에 설정된 값에 따라 조인 최적화의 비용 상당히 줄어들 수 있음.
- 시스템 변수 : `optimizer_search_depth`, `optimizer_prune_level`
<br>
  (다시 정리 필요)

## 9.4 쿼리 힌트
- MySQL 서버에서 사용 가능한 쿼리 힌트
  - 인덱스 힌트
    : 예전부터 사용되어 오던 힌트
  - 옵티마이저 힌트
    : MySQL 5.6버전부터 새롭게 추가되기 시작한 힌트

### 9.4.1 인덱스 힌트
- `STRAIGHT_JOIN`, `USE INDEX`: 옵티마이저 힌트 도입 전 사용되던 기능
  - SQL 문법에 맞게 사용해야 하기 때문에 사용하게되면 ANSI-SQL 표준 문법 준수 못하게 됨.
  - `SELECT` 명령과 `UPDATE` 명령에서만 사용할 수 있음.
- 옵티마이저 힌트
  - MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석하기 때문에 ANSI-SQL 표준을 준수함.

#### 9.4.1.1 STRAIGHT_JOIN
- 옵티마이저 힌트인 동시에 조인 키워드이기도 함.
- SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 함.
- 인댁스 힌트는 사용해야 하는 위치가 이미 결정됐으므로 그 이외의 다른 위치에서는 사용하지 않도록 주의 필요
- 주로 다음 기준에 맞게 조인 순서가 결정되지 않는 경우에만 사용하는 것이 좋음.
  - 임시 테이블과 일반 테이블의 조인
    : 임시테이블을 드라이빙 테이블로 선정하는 것이 좋음
  - 임시 테이블끼리의 조인
    : 크기가 작은 테이블을 드라이빙으로 선택
  - 일반 테이블끼리 조인
    : 모두 조인 칼럼에 인덱스가 있거나 모두 없는 경우에는 레코드 건 수가 적은 테이블을 드라이빙으로, 
      그 이외의 경우에는 조인 칼럼에 인덱스가 없는 테이블을 드라이빙으로
- 유사한 역할을 하는 옵티마이저 힌트
  - `JOIN_FIXED_ORDER` : STRAIGHT JOIN과 동일한 효과, 나머지 3개는 일부 테이블의 조인 순서에 대해서만 제안하는 힌트
  - `JOIN_ORDER`
  - `JOIN_PREFIX`
  - `JOIN_SUFFIX`
  
#### 9.4.1.2 USE INDEX/ FORCE INDEX / IGNORE INDEX
- 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 함.
  - 키워드 뒤에 사용할 인덱스의 이름을 괄호로 묶어서 사용
  - 괄호 안에 아무것도 없거나 존재하지 않는 인덱스 이름을 사용할 경우에는 쿼리의 문법 오류로 처리됨.
  - 별도로 사용자가 부여한 이름이 없는 프라이머리 키는 "PRIMARY"라고 명시

- `USE INDEX`
  - 가장 자주 사용되는 인덱스 힌트
  - MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트 (항상 채택하는 것은 아님)

- `FORCE INDEX`
  - `USE_INDEX`보다 옵티마이저에게 미치는 영향이 더 강한 힌트
  - 거의 사용할 필요 없음.
  
- `IGNORE INDEX`
  - 특정 인덱스를 사용하지 못하게 하는 용도
  - 옵티마이저가 풀 테이블 스캔 사용하도록 유도하기 위해 사용할 수도 있음.

- 3 종류 모두 용도를 명시해줄 수 있음. 용도는 선택 사항, Default는 다음과 같음.
  - `USE INDEX FOR JOIN`
      - 여기서 JOIN은 테이블간의 조인 뿐 아니라 레코드 검색하기 위한 용어까지 포함.
  - `USE INDEX FOR ORDER BY`
  - `USE INDEX FOR GROUP BY`

- 인덱스 사용법이나 좋은 실행 계획이 어떤 것인지 판단하기 힘든 상황이라면 
  힌트 사용해 강제로 옵티마이저의 실행 계획에 영향을 미치는 것을 피하는 것이 좋음.
- 그때 그때 옵티마이저가 당시 통계 정보를 가지고 선택하게 하는 것이 가장 좋음.

#### 9.4.1.3 SQL_CALC_FOUND_ROWS
- MYSQL의 LIMIT : 조건을 만족하는 레코드가 LIMIT에 명시된 수보다 더 많더라고 하더라도, 
    명시된 수만큼 만족하는 레코드 찾으면 즉시 검색 작업 멈춤
- `SQL_CALC_FOUND_ROWS` : 끝까지 검색을 수행, FOUND_ROWS()라는 함수를 이용해 LIMIT을 제외한 조건을 만족하는 전체 레코드 수 알려줌.
- 이 힌트를 사용하면 안되는 경우
  - 속도가 느린 문제
  - FOUND_ROWS() 함수로 정확한 레코드 건수 가져올 수 없는 문제
  - 사용하지 않는 것을 추천

### 9.4.2 옵티마이저 힌트
#### 9.4.2.1 옵티마이저 힌트 종류
- `인덱스` : 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- `테이블` : 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- `쿼리 블록` : 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트, 
  특정 쿼리 블록의 이름의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
- `글로벌(쿼리 전체)` : 전체 쿼리에 대해서 영향을 미치는 힌트

<br>

- 위 구분으로 힌트의 사용 위치가 달라지는 것은 아님.

#### 9.4.2.2 MAX_EXECUTION_TIME
- 옵티마이저 힌트 중에서 유일하게 쿼리의 실행 계획에 영향을 미치지 않는 힌트
- 단순히 쿼리의 최대 실행 시간을 설정하는 힌트
- 밀리초 단위 시간 설정 -> 지정 시간 초과하면 쿼리 실패

#### 9.4.2.3 SET_VAR
- MySQL 서버의 시스템 변수들 또한 쿼리의 실행 계획에 상당한 영향을 미침
- 실행 계획을 바꾸는 용도 뿐 아니라 조인 버퍼나 정렬용 버퍼 크기를 일시적 증가시켜 대요양 처리 쿼리의 성능 향상하는 용도로도 사용 가능
- 다양한 시스템 변수 조정을 사용할 수 있음.
- 모든 시스템 변수를 조정할 수는 없음.

#### 9.4.2.4 SEMIJOIN & NO_SEMIJOIN
- (최적화 전략, 힌트)
  - `Duplicate Weed-out` :  SEMIJOIN(DUPSWEEDOUT)
  - `First Match`:  SEMIJOIN(FIRSTMATCH)
  - `Loose Scan`:  SEMIJOIN(LOOSESCAN)
  - `Materialization`:  SEMIJOIN(MATERIALIZATION)
  - `Table Pull-out`:  없음
- `Table Pull-out`은 사용할 수 있다면, 항상 더 나은 성능 보장 -> 별도의 힌트 사용 불가
- 다른 최적화 전략들은 상황에 따라 다른 최적화 전략으로 우회하는 것이 더 나은 성능을 낼 수도 있기 때문에 세미 조인 힌트로 제공됨.

#### 9.4.2.5 SUBQUERY
- 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법
- 서브 쿼리의 2가지 형태의 최적화 방법
  - `IN-to-EXISTS` : SUBQUERY(UNTOEXISTS)
  - `Materialization` : SUBQUERY(MATERIALIZATION)

- 세미 조인 최적화는 주로 IN(subquery) 형태의 쿼리에 사용될 수 있지만, 안티 세미 조인의 최적화에 사용될 수 없음.
- 주로 안티 세미 조인 최적화에는 위 2가지 최적화가 사용됨.
- 서브 쿼리 최적화는 그다지 사용할 기회 많지 않음.

#### 9.4.2.6 BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
- MySQL 8.0.19 버전까지는 블록 네스티드 루프 (Block Nested Loop) 조인 알고리즘 사용
- MyySQL 8.0.18 버전부터는 도입된 해시 조인 알고리즘이 MySQL 8.0.20 버전 부터는 블록 네스티드 루프 조인까지 대체하도록 개선됨.
  - BNL 힌트와 NO_BNL 힌트는 그 이후의 버전에서도 여전히 사용 가능
  - 그러나, 해시 조인을 사용하도록 유도하는 힌트로 용도 변경됨.

#### 9.4.2.7 JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX &JOIN_SUFFIX
- `STRAIGHT_JOIN 힌트` : FROM 절에 사용된 테이블의 순서를 조인 순서에 맞게 변경해야 하는 번거로움 & 일부는 조인 순서를 강제하고, 옵티마이저에 맞기는 것 불가
- 이 단점 보완하기 위해 옵티마이전에는 4개의 힌트 제공
  - `JOIN_FIXED_ORDER` : STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인을 실행하게 하는 힌트
  - `JOIN_ORDER_FROM` : FROM 절에 사용된 테이블의 순서가 아니라 힌트에 명시된 순서대로 조인을 실행하는 힌트
  - `JOIN_PREFIX` : 조인에서 드라이빙 테이블만 강제하는 힌트
  - `JOIN_SUFFIX` : 조인에서 드리븐 테이블(가장 마지막에 조인돼야 할 테이블들)만 강제하는 힌트

#### 9.4.2.8 MERGE & NO_MERGE
- MySQL 5.7 버전과 8.0 버전에서는 가능하면 임시 테이블을 사용하지 않게 FROM 절의 서브 쿼리를 외부 쿼리와 병합하는 최적화 도입
  - 때로는 MySQL 옵티마이저가 내부 쿼리를 외부 쿼리와 병합하는 것이 나을 수도, 때로는 내부 임시 테이블 생성이 나을 수도 <br>
  -> MySQL 옵티마이저가 최적의 방법을 선택하지 못할 수도 있는데, 이때는 다음과 같이 MERGE 또는 NO_MERGE 옵티마이저 힌트를 사용하면 됨.

#### 9.4.2.9 INDEX_MERGE & NO_INDEX_MERGE
- 인덱스 머지(INDEX_MERGE)
  - 하나의 테이블에 대해 여러 개의 인덱스를 동시에 사용하는 것
  - 인덱스 머지 실행 계획은 성능 향상에 도움이 되지만, 항상 그렇지는 않음.

#### 9.4.2.10 NO_ICP
- 인덱스 컨디션 푸시다운(ICP, Index Condition Pushdown) 최적화는 사용 가능하다면 항상 성능 향상에 도움됨.
- MySQL 옵티마이저에서 ICP 힌트를 제공되지 않음 <br>
-> 인덱스 컨디션 푸시다운으로 인해 여러 실행 계획의 비용이 잘못 계산되면, 결과적으로 잘못된 실행 계획 수립하게 될 수도 있음.

#### 9.4.2.11 SKIP_SCAN & NO_SKIP_SCAN
- 인덱스 스킵 스캔은 인덱스의 선행 칼럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 매우 훌륭한 최적화 기능
- 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면, 인덱스 스킵 스캔의 성능은 오히려 떨어짐.
- `NO_SKIP_SCAN 옵티마이저 힌트`를 통해서 인덱스 스킵 스캔 사용하지 않을 수도 있음.

#### 9.4.2.12 INDEX & NO_INDEX
- (인덱스 힌트, 옵티마이저 힌트)
  - `USE INDEX` : INDEX
  - `USE INDEX FOR GROUP BY` : GROUP_INDEX
  - `USE INDEX FOR ORDER BY` : ORDER_INDEX
  - `IGNORE INDEX` : NO_INDEX
  - `IGNORE INDEX FOR GROUP BY` : NO_GROUP_INDEX
  - `IGNORE INDEX FOR ORDER BY` : NO_ORDER_INDEX
  
- INDEX 와 NO_INDEX 옵티마이저 힌트는 예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공됨.
- 옵티마이저 힌트는 테이블명과 인덱스 이름을 함께 명시해야 함.

# Chapter.10 실행 계획
## 10.1 통계 정보
- MySQL 8.0 버전부터는 인덱스되지 않는 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됨.
- 히스토그램이 도입됐다고 해서 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아님.

### 10.1.1 테이블 및 인덱스 통계 정보
- 비용 기반 최적화에서 가장 중요한 것은 통계 정보

#### 10.1.1.1 MySQL 서버의 통계 정보
- MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됨.
- MySQL 5.5 버전 이전 
  - 각 테이블의 통계 정보가 메모리에만 관리됨, SHOW INDEX 명령으로만 테이블의 인덱스 칼럼의 분포도 볼 수 있었음.
  <br> -> MySQL 서버가 재시작되면 지금까지 수집된 통계 정보 모두 사라짐.
  - 테이블 통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 옵션으로 `innodb_stats_sample_pages` 시스템 변수 제공

- MySQL 5.6 버전 이후 
  - 각 테이블의 통계 정보를 `innodb_index_stats`테이블과 `innodb_table_stats` 테이블로 관리
    <br> -> MySQL 서버가 재시작되도 기존의 통계 정보 유지할 수 있게 됨.
  - `STATUS_PERSISTENT` : 테이블 단위로 영구적인 통계 정보 저장할지 결정
    - MySQL 5.5이전에는 사용자나 관리자가 알지 못하는 순간에 이벤트가 발생하면, 자동으로 통계 정보가 갱신됨 <br>
    -> 영구적인 통계 정보 도입하면서 의도하지 않은 통계 정보 변경 막을 수 있게 됨.
  - `innodb_stats_sample_pages`옵션이 사라지고 `innodb_stats_transient_sample_pages``innodb_stats_persistent_sample_pages`로 분리됨.

### 10.1.2 히스토그램
- MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값 개수 정도만 가지고 있었음.
- 옵티마이저가 최적의 실행 계획 수립하기에는 많이 부족
- 부족함을 메우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식 사용
- 8.0 버전으로 업그레이드되면서 MySQL 서버도 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램(Histogram) 정보를 활용할 수 있게 됨.

#### 10.1.2.1 히스토그램 정보 수집 및 삭제
- MySQL 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리됨.
- 자동으로 수집되지 않고, 수동으로 수집 및 관리됨.
- 수집된 히스토그램 정보는 시스템 딕셔너리에 저장됨 
- MySQL 서버가 시작될 때 딕셔너리의 히스토그램을 `information_schema`, `column_statistics` 테이블로 로드함.
<br>
- MySQL 8.0 버전에서 지원되는 히스토그램 타입
  - `Singleton(싱글톤 히스토그램)` : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램
  - `Equi-Height(높이 균형 히스토그램)` : 칼럼 값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램
- 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리됨.
  - 싱글톤 히스토그램은 칼럼이 가지는 값별로 버킷이 할당됨.
    - 각 버킷이 칼럼의 값, 발생 빈도의 비율 -> 2개의 값 가짐.
  - 높이 균형 히스토그램은 개수가 균둥한 칼럼값의 범위별로 하나의 버킷이 할당됨.
    - 각 버킷이 범위 시작 값과 마지막 값, 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 -> 4개 가짐.

- 생성된 히스토그램 삭제
  - 테이블 데이터를 참조하는 것이 아니라 딕셔내리 내용만 삭제
  - 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료됨.
  - 히스토그램이 사라지면, 쿼리의 실행 계획이 달라질 수 있음.
  ```
    mysql> ANALYZE TABLE employees.employees
            DROP HISTOHRAM ON gender, hire_date;
    ```
- 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 `optimizer_switch` 시스템 변수 값 변경
  - 모든 쿼리가 히스토그램 사용하지 않음.
  - condition_fanout_filter 옵션에 의해 영향 받는 다른 최적화 기능들이 사용되지 않을 수도 있음.
  - 특정 커넥션 또는 특정 쿼리에서만 히스토그램 사용하지 않도록 설정도 가능

#### 10.1.2.2 히스토그램의 용도
- 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않음.
- 하지만, 각 범위(버킷) 별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 더 정확한 예측 가능

#### 10.1.2.3 히스토그램과 인덱스
- 히스토그램과 인덱스는 완전히 다른 객체이지만 MySQL 서버에서 인덱스는 부족한 통계 정보 수집하기 위해 사용되어 어느 정도 공통점
- `인덱스 다이브(Index Dive)` : 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저가 실제 인덱스의 B-Tree를 샘플링해서 살펴봄.
  - 실제 검색 조건의 대상 값에 대한 샘플링을 실행하므로 항상 히스토그램보다 정확한 결과를 기대할 수 있음.
  - MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용됨.
  - 비용이 높아지기도 함.

### 10.1.3 코스트 모델(Cost Model)
- 전체 쿼리의 비용을 게산하는 데 필요한 작업 단위들의 비용
- MySQL 5.7 이전 버전 : MySQL 서버 코드에 상수화 해서 사용
  - 하드웨어에 따라 달라지므로, 최적의 실행 계획 수립에 방해 요소
  - MySQL 5.7버전 부터는 MySQL 서버의 소스코드에 상수화돼 있던 각 단위 작업 비용을 DBMS 관리자가 조정할 수 있게 개선됨.
  - 그럼에도 인덱스되지 않은 칼럼의 데이터 분포나 메모리에 상주 중인 페이지 비율 등 비용 계산과 연관된 부분 정보 부족한 상태
  - MySQL 8.0 버전으로 업그레이드되면서 칼럼의 데이터 분포를 위한 히스토그램과 메모리에 적재된 페이지 비율이 관리되고, 옵티마이저 실행 계획 수립에 사용되게 됨.

  <br>
  
- MySQL 8.0 서버의 코스트 모델은 다음 2개 테이블에 저장돼 있는 설정 값 사용
  - `server_cost` : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
  - `engine_cost` : 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
  
    <br>
(추후 정리 필요)

## 10.2 실행 계획 확인
- MySQL 서버의 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인 가능
- MySQL 8.0버전부터는 EXPLAIN 명령에 사용할 수 있는 새로운 옵션 추가됨.

### 10.2.1 실행 계획 출력 포맷
- 이전 버전
  - EXPLAIN EXTENDED와 EXPLAIN PARTITIONS 명령이 구분돼 있었음
- MySQL 8.0
  - 모든 내용이 통합되어 보이도록 개선됨
  - FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택 가능해짐.

### 10.2.2 쿼리의 실행 시간 확인
- MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됨.
- `SHOW PROFILE` 명령으로 어떤 부분에서 시간이 많이 소요되는지 확인 가능하지만, 실행 계획 단계별로 소요된 시간 정보 보여주지는 않음.
- `EXPLAIN ANALYZE` 명령은 항상 결과를 TREE 포맷으로 보여줌 -> FORMAT 옵션 사용 불가
- `EXPLAIN ANALYZE` 명령은 `EXPLAIN` 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여줌.
  - 실행 계획이 아주 나쁜 경우는 `EXPLAIN` 명령으로 실행 계획만 확인 후, 어느 정도 튜닝 후`EXPLAIN ANALYZE` 명령 실행하는 것이 좋음.

## 10.3 실행 계획 분석
- MySQL 8.0 버전부터는 `EXPLAIN` 명령 결과로 출력되는 실행 계획의 포맷을 기존 테이블 포맷, JSON, TREE 중 선택 가능

### 10.3.1 id 칼럼
- 실행 계획에서 가장 왼쪽에 표시되는 id 칼럼 : 단위 SELECT 쿼리별로 부여되는 식별자 값
- 하나의 SELECT 문장 안에서 여러 개의 테이블 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만, 같은 id 값이 부여됨.

### 10.3.2 select_type 칼럼
- 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼

#### 10.3.2.1 SIMPLE
- UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리의 select_type

#### 10.3.2.2 PRIMARY
- UNION이나 서브 쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리의 select_type

#### 10.3.2.3 UNION
- UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type

#### 10.3.2.4 DEPENDENT UNION
- DEPENDENT UNION 또한 UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에 표시

#### 1O.3.2.5 UNION RESULT
- UNION 결과를 담아두는 테이블을 의미
- MySQL 8.0 이전 버전에서는 UNION ALL이나 UNION 쿼리는 모두 UNION의 결과를 임시 테이블로 생성했음.
- MySQL 8.0 부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능 개선
  - UNION은 여전히 임시 테이블에 결과를 버퍼링

#### 10.3.2.6 SUBQUERY
- select_type의 SUBQUERY는 FROM 절 이외에서 사용되는 서브쿼리만을 의미함.
- MySQL 서버의 실행 계획에서 FROM 절에 사용된 서브 쿼리는 select_type이 DERIVED로 표시되고, 그 밖의 위치에서 사용된 서브 쿼리는 전부 SUBQUERY로 표시됨.

#### 10.3.2.7 DEPENDENT SUBQUERY
- 서부 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우 select_type이 DEPENDENT SUBQUERY
- 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브 쿼리보다는 처리 속도가 느릴 때가 많음.

#### 10.3.2.8 DERIVED
- MySQL 5.5 버전까지는 서브 쿼리가 FROM 절에 사용된 경우는 항상 select_type이 DERIVED 였음.
- MySQL 5.6 버전부터는 옵티마이션 옵션에 따라 FROM 절의 서브 쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 함.
- DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미함.
- DERIVED인 경우에는 생성되는 임시 테이블을 파생 테이블이라고도 함.
- MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스 추가해서 만들 수 있게 최적화 됨.

#### 10.3.2.9 DEPENDENT DERIVED
- MySQL 8.0 이전 버전에서는 FROM 절의 서브 쿼리는 외부 칼럼을 사용할 수 없었음.
- MySQL 8.0 버전부터는 래터럴 조인(LATERAL JOIN) 기능이 추가되면서 FROM 절의 서브 쿼리에서도 외부 칼럼을 참조할 수 있게 됨.

#### 10.3.2.10 UNCATCHEABLE SUBQUERY
- 서브 쿼리 결과가 캐시는 되지만, 딱 한 번만 캐시되는 것이 아니라 외부 쿼리의 값 단위로 캐시가 만들어지는 방식으로 처리됨.

#### 10.3.2.11 UNCATCHEABLE UNION

#### 10.3.2.12 MATERIALIZED
- MySQL 5.6 버전부터 도입된 select_type으로, 주로 FROM 절이나 IN 형태의 쿼리에 사용된 서브 쿼리의 최적화를 위해 사용됨.
- MySQL 5.6 버전까지는 테이블을 읽어서 레코드마다 서브쿼리가 실행되는 형태
- MySQL 5.7 버전부터는 서브 쿼리의 내용을 임시 테이블로 구체화(MATERIALIZED)한 후, 임시 테이블과 테이블을 조인하는 형태로 최적화
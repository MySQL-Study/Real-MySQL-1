## 조인 최적화 알고리즘

MySQL에는 조인 쿼리의 실행 계획 최적화를 위한 2가지 알고리즘이 있었습니다. 테이블의 개수가 많아지면 최적화된 실행 계획을 찾기 어려워졌고, 계획 수립에만 몇 분이 걸릴 수도 있었습니다.

### **Exhaustive 검색 알고리즘**

Exhaustive 검색 알고리즘은 FROM 절에 명시된 모든 테이블 조합에 대해 실행 계획의 비용을 계산해 최적의 조합 1개를 찾는 방법이었습니다. 테이블이 20개라면 가능한 조인 조합은 20!이 되어 매우 많은 계산이 필요했습니다.

### **Greedy 검색 알고리즘**

Greedy 검색 알고리즘은 말 그대로 그때그때 최적의 조인 순서를 하나씩 찾아가는 방법이었습니다. 4개의 테이블이 처리될 경우 최적의 조인 순서를 단계적으로 검색하며, 가능한 조합 중에서 최적의 경로를 선택해 나갔습니다.

## **9.4 쿼리 힌트**

개발자가 직접 MySQL에 필요한 실행 계획을 수립할 수 있게 해주는 기능이었습니다.

### **인덱스 힌트**

옵티마이저 힌트들은 모두 MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석되기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있었습니다. 그래서 가능하다면 인덱스 힌트보다는 옵티마이저 힌트를 사용할 것을 추천했습니다. 또한 인덱스 힌트는 SELECT 명령과 UPDATE 명령에서만 사용할 수 있었습니다.

### **STRAIGHT_JOIN**

STRAIGHT_JOIN은 테이블 조인 시 순서를 고정하는 역할을 했습니다. 이를 통해 옵티마이저가 결정한 조인 순서가 아닌 개발자가 지정한 순서대로 테이블을 조인할 수 있었습니다.

### **USE INDEX / FORCE INDEX / IGNORE INDEX**

인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시했습니다. 대체로 옵티마이저는 인덱스 선택을 무난하게 수행했지만, 3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여럿 있다면 가끔 실수를 했습니다.

이러한 문제를 해결하기 위해 특정 테이블의 인덱스를 사용하도록 권장하거나 강제 혹은 사용하지 못하게 제한하는 힌트들이 제공되었습니다.

### **SQL_CALC_FOUND_ROWS**

LIMIT을 사용하는 경우 해당 수만큼 레코드를 찾으면 즉시 검색을 멈추었습니다. 하지만 SQL_CALC_FOUND_ROWS 힌트가 있으면 끝까지 검색을 수행했습니다. 이를 통해 LIMIT을 제외한 조건에 만족하는 레코드가 전체 몇 건인지 알아낼 수 있었습니다.

### **옵티마이저 힌트**

옵티마이저 힌트는 영향 범위에 따라 다음 4개 그룹으로 나뉘었습니다:

- 인덱스: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- 테이블: 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- 쿼리 블록: 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트로서, 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 힌트
- 글로벌(쿼리 전체): 전체 쿼리에 대해서 영향을 미치는 힌트

이러한 구분으로 인해 힌트의 사용 위치가 달라지는 것은 아니었습니다. 그리고 힌트에 인덱스 이름이 명시될 수 있는 경우를 인덱스 수준의 힌트로 구분하고, 테이블 이름까지만 명시될 수 있는 경우를 테이블 수준의 힌트로 구분했습니다. 또한 특정 힌트는 테이블과 인덱스의 이름을 모두 명시할 수도 있었지만, 인덱스의 이름을 명시하지 않고 테이블 이름만 명시할 수도 있었는데, 이런 경우는 인덱스 테이블 수준의 힌트가 되었습니다.

# **10장 실행 계획**

MySQL 서버에서 보여주는 실행 계획을 읽고 이해하려면 서버가 데이터를 처리하는 로직을 이해해야 합니다.

## **10.1 통계 정보**

실행 계획을 수립할 때는 테이블과 인덱스, 데이터 분포도를 수집해서 저장하는 히스토그램 정보를 활용합니다.

### **테이블 및 인덱스 통계 정보**

비용 기반 최적화에서 가장 중요한 것이 통계 정보입니다. InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 되었습니다. 이전에는 메모리에서만 관리되어 서버가 재시작되면 모든 수집 정보가 사라졌지만, 이제는 통계 정보를 테이블로 관리할 수 있게 되었습니다.

### **히스토그램**

이전에는 통계 정보가 단순히 인덱스된 칼럼의 유니크한 값 개수 정도만 가지고 있었습니다. 그래서 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했었습니다. 이제는 업그레이드되어 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있습니다.

히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리됩니다. 히스토그램이 없으면 옵티마이저는 데이터가 균등하다고 예측하지만, 히스토그램을 통해 실제 특정 범위의 데이터가 많고 적음을 식별할 수 있습니다. 이를 통해 조인 순서를 바꾸는 등으로 쿼리 성능에 상당한 영향을 미칠 수 있습니다.

히스토그램과 인덱스는 완전히 다른 객체이지만 통계 정보 수집에서 어느 정도 공통점을 가집니다. 인덱스를 통한 레코드 건수 예측을 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해 살펴보며 이를 인덱스 다이브라고 표현합니다.

### **코스트 모델**

쿼리를 처리할 때 다음과 같은 다양한 작업이 필요합니다:

- 디스크로부터 데이터 페이지 읽기
- 메모리로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

MySQL 서버는 쿼리에 대해 다양한 작업이 얼마나 필요한지 예측하고 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾습니다. 이렇게 전체 쿼리 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델이라고 합니다.

## **10.2 실행 계획 확인**

실행 계획은 DESC 혹은 EXPLAIN 명령으로 확인할 수 있습니다. 쿼리의 실행 시간 정보를 확인할 수 있는 EXPLAIN ANALYZE 기능도 추가되었습니다.

## **10.3 실행 계획 분석**

실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요합니다.

### **id 칼럼**

하나의 SELECT 문장은 다시 1개 이상의 하위 SELECT 문장을 포함할 수 있습니다. 실행 계획에서 가장 왼쪽에 표시되는 id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값입니다.

하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여됩니다. 반대로 쿼리 문장이 여러 개의 단위 SELECT 쿼리로 구성된 경우, 실행 계획의 각 레코드는 각기 다른 id 값을 가지게 됩니다.

주의할 점은 id 컬럼이 테이블의 접근 순서를 의미하지는 않는다는 것입니다. 접근 순서는 EXPLAIN FORMAT=TREE 명령으로 확인할 수 있습니다.

### **select_type 칼럼**

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼입니다. select_type 컬럼에 표시될 수 있는 값은 다음과 같습니다:

- SIMPLE: UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리
- PRIMARY: UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
- UNION: UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리
- DEPENDENT UNION: UNION이나 UNION ALL로 결합된 쿼리가 외부 쿼리에 의해 영향을 받는 쿼리
- UNION RESULT: UNION 결과를 담아두는 테이블
- SUBQUERY: FROM 절 이외에서 사용되는 서브쿼리
- DEPENDENT SUBQUERY: 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우
- DERIVED: 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것
- DEPENDENT DERIVED: 서브 쿼리 중 외부에 영향을 받는 첫 번째 쿼리
- UNCACHEABLE SUBQUERY: 결과를 캐시할 수 없는 서브쿼리
- UNCACHEABLE UNION: UNCACHEABLE과 UNION이 혼합된 select_type
- MATERIALIZED: 실체화된 서브쿼리

MySQL 8.0 이전 버전에서는 UNION ALL이나 UNION 쿼리는 모두 임시 테이블을 생성했는데, MySQL 8.0 버전부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선되었습니다.
# CHAPTER 6. 데이터 압축
- 디스크에 저장된 데이터 파일의 크기는 일반적으로 쿼리의 처리 성능과도 직결되지만 백업 및 복구 시간과도 밀접하게 연결됨
- 따라서 많은 DBMS는 데이터 압축 기능 제공

## 페이지 압축
- MySQL 서버가 디스크에 저장하는 시점에 데이터 페이지가 압축되어 저장
- MySQL 서버가 디스크에서 데이터 페이지를 읽어올 때 압축 해제
- 하나의 테이블은 동일한 크기의 페이지(블록)로 통일돼야 함
- 16KB 페이지를 압축하여 7KB가 되면 나머지 9KB를 펀치 홀을 생성하여 운영체제에 반납
- 테이블 생성 또는 변경 시 `COMPRESSION="ZLIB"` 옵션 설정으로 사용 가능
- 문제점
  - 펀치 홀 기능은 운영체제뿐만 아니라 하드웨어 자체에서도 해당 기능을 지원해야 사용 가능
  - 파일 시스템 관련 명령어(유틸리티)가 펀치 홀 지원 불가 예) cp

## 테이블 압축
- 페이지 압축과 달리 운영체제나 하드웨어 대한 제약 없이 사용 가능
- 문제점
  - 버퍼 풀 공간 활용률 낮음
  - 쿼리 처리 성능 낮음
  - 빈번한 데이터 변경 시 압축률 떨어짐
 
#### 압축 테이블 생성
- 테이블 압축을 사용하기 위해서는 테이블이 별도의 테이블 스페이스를 사용해야 함
  - `innodb_file_per_table` ON으로 설정된 상태에서 `ROW_FORMAT=COMPRESSED` 또는 `KEY_BLOCK_SIZE=2n(n 값은 2 이상)` 옵션 설정으로 테이블 생성
  - InnoDB 스토리지 엔진의 페이지 크기는 4KB, 8KB, 16KB, 32KB, 64KB를 지원하지만 32KB 또는 64KB인 경우 테이블 압축 적용 불가
  - `KEY_BLOCK_SIZE`의 경우 압축된 페이지가 저장될 페이지의 크기로 페이지 크기보다 작은 값만 가능 -> 4KB, 8KB만 가능
- 데이터 페이지를 압축 -> 목표 크기 이하라면 디스크에 저장 초과하면 원본 페이지를 2개로 스플릿한 후 반복

#### KEY_BLOCK_SIZE 결정
- 테이블 압축에서 가장 중요한 부분은 압축된 결과가 어느 정도가 될지를 예측해서 KEY_BLOCK_SIZE를 결정하는 것
- 일반적으로 압축 실패율은 3~5% 미만으로 유지할 수 있게 KEY_BLOCK_SIZE를 선택하는 것이 좋음
- INSERT만 되는 로그 테이블의 경우는 압축 실패율이 높더라도 데이터 파일의 크기가 큰 폭으로 줄어든다면 큰 손해는 아님
- 압축 실패율이 높지 않더라도 데이터가 매우 빈번하게 조회되고 변경된다면 압축은 고려하지 않는 것이 좋음
- 예상외로 압축 알고리즘은 많은 CPU 자원 소모

#### 압축된 페이지의 버퍼 풀 적재 및 사용
- InnoDB 스토리지 엔진은 디스크에서 읽은 상태 그대로의 데이터 페이지 목록을 관리하는 *LRU 리스트*와 압축된 페이지들의 압축 해제 버전인 *Unzip_LRU 리스트*를 별도로 관리
- Unzip_LRU 리스트는 압축이 적용되지 않은 테이블의 데이터 페이지는 가지지 않음
- 압축된 테이블에 대해서는 버퍼 풀의 공간을 이중으로 사용 -> 메모리 낭비
  - InnoDB 버퍼 풀 공간이 필요한 경우 Unzip_LRU 리스트 제거
  - 압축된 데이터 페이지가 많이 사용된다면 Unzip_LRU 리스트에 계속 유지
  - 압축된 데이터 페이지가 사용되지 않는다면 LRU 리스트와 Unzip_LRU 리스트 모두에서 제거
- 압축 해제된 데이터 페이지를 적절한 수준으로 유지하기 위해 어댑티브 알고리즘 사용
  - CPU 사용량이 높은 서버에서는 압축과 압축 해제를 피하기 위해 Unzip_LRU의 비율을 높여서 유지
  - Disk IO 사용량이 높은 서버에서는 Unzip_LRU 리스트의 비율을 낮춰서 InnoDB 버퍼 풀 공간 확보

#### 테이블 압축 관련 설정
- `innodb_cmp_per_index_enabled`: 테이블 압축이 사용된 테이블의 모든 인덱스별로 압축 성공 및 압축 실행 횟수 수집
- `innodb_compression_level`: 0~9까지의 압축률 설정, 값이 커질수록 속도는 느려지지만(CPU 자원을 많이 사용) 압축률은 높아짐, 기본값은 6
- `innodb_compression_failure_threshold_pct`, `innodb_compression_pad_pct_max`: 테이블 단위로 압축 실패율이 innodb_compression_failure_threshold_pct 값보다 커지면 압축 전 원본 데이터 페이지의 끝에 의도적으로 innodb_compression_pad_pct_max % 값 이하의 빈 공간 추가 -> 추가된 빈 공간은 압축률을 높여서 압축 결과가 KEY_BLOCK_SIZE보다 작아지게 만듦
- `innodb_log_compressed_pages`: 서버가 비정상적으로 종료 후 다시 시작되는 경우 압축 알고리즘의 버전 차이가 있더라도 복구 과정이 실패되지 않도록 암축된 페이지를 통째로 리두 로그에 기록
<details>
<summary>빈 공간을 추가했을 때 압축 결과가 더 작아지는 이유(feat.GPT)</summary>
  
- 압축 알고리즘의 특성: 대부분의 압축 알고리즘은 데이터의 중복성을 잘 압축합니다. 하지만 데이터가 너무 빽빽하게 차 있는 경우, 압축 알고리즘이 중복 데이터를 찾고 압축하는 데 한계가 있을 수 있습니다. 이때, 여유 공간을 추가하면 데이터가 조금 더 "흩어지게" 되어, 압축 과정에서 더 많은 중복 데이터가 발견되거나 압축이 잘 이루어질 수 있습니다.

- 빈 공간을 통한 압축 효율성 증가: 압축이 잘되지 않는 데이터가 있을 때, 빈 공간을 추가하는 것이 오히려 데이터의 분포를 변화시켜 압축 알고리즘이 더 효과적으로 데이터를 압축하도록 유도할 수 있습니다. 예를 들어, 압축된 데이터는 연속적인 블록으로 저장되기보다는 불연속적인 구조로 배치될 수 있습니다. 이때 여유 공간이 데이터의 정렬 및 배치 방식을 유리하게 만들어, 압축 결과가 더 작은 크기로 나오게 되는 것입니다.

- 페이지 크기와 압축률: 데이터가 압축되기 전에 빈 공간을 추가함으로써 최종적으로 생성된 페이지 크기가 목표 크기 (KEY_BLOCK_SIZE) 이하로 유지되게 됩니다. 빈 공간을 추가하면 압축된 데이터가 원하는 크기 이하로 압축되도록 유도할 수 있기 때문에, 압축률을 높일 수 있는 효과가 생깁니다.
</details>

# CHAPTER 7. 데이터 암호화
- MySQL 5.7 버전부터 지원 시작, 데이터 파일(테이블 스페이스)에 대해서만 암호화 기능 제공
- 8.0 버전부터 리두 로그, 언두 로그 등 모두 암호화 기능 지원

## MySQL 서버의 데이터 암호화
- 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰기 지점에서 암호화 또는 복호화를 수행 -> InnoDB 스토리지 엔진의 I/O 레이어에서만 데이터 암호화 과정 실행
- TDE(Transparent Data Encryption)

#### 2단계 키 관리
- 암호화 키는 키링 플러그인에 의해 관리
- 데이터 암호화는 마스터 키와 테이블스페이스 키라는 두 가지 종류의 키 가짐
- 서버는 외부 키 관리 솔루션 또는 디스크의 파일에서 마스터 키를 가져오고 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키 발급
- 마스터 키를 이용해 테이블스페이스키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장
- 테이블스페이스 키는 서버 외부로 노출되지 않아서 주기적으로 변경하지 않아도 보안상 취약점 아님
- 마스터 키는 외부의 파일을 이용하기 때문에 노출 위험이 있어 주기적으로 변경해야 함 -> `ALTER INSTANCE ROTATE INNODB MASTER KEY;`
- TDE에서 지원되는 암호화 알고리즘은 AES 256 비트

#### 암호화와 성능
- 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재
- 버퍼 풀에 존재하지 않는 데이터 페이지를 읽을 경우 복호화 시간 동안 쿼리 처리 지연
- 데이터 페이지 암호화 저장은 MySQL 서버의 백그라운드 스레드가 수행하기 떄문에 사용자의 쿼리가 지연되지는 않음
- TDE를 적용해도 데이터 파일의 크기는 암호화되지 읺은 테이블과 동일한 크기를 가짐 -> 버퍼 풀 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상 발생 X
- 같은 테이블에 암호화와 압축이 동시에 적용되면 압축 먼저 실행 후 암호화 적용
  - 암호화된 결과물은 랜덤한 바이트의 배열을 가져 압축률이 낮음
  - 암호화 후 압축된다면 버퍼 풀에 존재하는 데이터 페이지에 대해서 매번 암복호화 작업 수행해야 함

#### 암호화와 복제
- MySQL 서버에서 기본적으로 모든 노드는 각자의 마스터 키를 할당해야 함 -> 소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 키를 관리
- 소스 서버와 레플리카 서버에서 암호화된 데이터가 저장된 데이터 파일의 내용은 완전히 다름

## keyring_file 플러그인 설치
- 유일하게 MySQL 커뮤니티 에디션에서 사용 가능한 플러그인
- 테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크 파일로 관리
- 이 때 마스터 키는 평문으로 디스크에 저장 -> 보안에 취약
  - 키링 파일을 로컬 디스크에 저장 후 서버 시작 후 삭제하는 방법 고려 (캐시되기 때문에 서버가 재시작되지 않는 한 서버 작동에 문제 없음)
  - Percona Server의 keyring_vault 오픈 소스 플러그인 검토도 권장
```
# my.cnf
early-plugin-load = keyring_file.so # keyring_file 플러그인을 위한 라이브러리
keyring_file_data = /very/secure/directory/tde_master.key # 마스터 키를 저장할 키링 파일의 경로
```
- 데이터 암호화 기능을 사용하는 테이블을 생성하거나 마스터 로테이션을 실행하면 키링 파일의 마스터 키가 초기화됨

## 테이블 암호화
- 어떤 키링 플러그인을 사용하든 관계없이 암호화된 테이블을 생성하고 활용하는 방법은 모두 동일

#### 테이블 생성
- 테이블 생성 시 `ENCRYPTION='Y'` 옵션을 추가
- `default_table_encryption`을 ON으로 설정하면 모두 암호화된 테이블로 생성

#### 응용 프로그램 암호화와의 비교
- 응용 프로그램에서 암호화된 칼럼은 인덱스를 생성하더라도 인덱스의 기능을 100% 활용 불가
- 응용 프로그램에서의 암호화와 MySQL 서버의 암호화 기능 중 선택해야 하는 상황이라면 MySQL 서버의 암호화 기능을 선택할 것을 권장
- 그러나 MySQL 서버의 TDE 기능으로 암호화한다면 서버에 로그인만 할 수 있다면 모든 데이터를 평문으로 확인 가능
- 응용 프로그램에서의 암호화 기능은 서비스의 요건과 성능을 고려해서 선택해야 하고 MySQL 서버의 암호화 기능과 혼합해서 사용한다면 더 안전한 서비스 구축 가능

#### 테이블스페이스 이동
- 테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면 테이블스페이스 이동 기능이 레코드를 덤프했다가 복구하는 방식보다 훨씬 효율적이고 빠름
- `FLUSH TABLES source_table FOR EXPORT;` 실행 -> source_table의 저장되지 않은 변경 사항을 모두 디스크로 기록 및 테이블 잠금 -> 동시에 source_table의 구조를 source_table.cfg 파일로 기록 -> souce_table.ibd 파일과 souce_table.cfg 파일을 목적지 서버로 복사 -> UNLOCK TABLES
- 암호화된 테이블의 경우임시 마스터 키를 source_table.cfp라는 파일로 기록 및 테이블스페이스 키를 다시 암호화해서 데이터 파일의 헤더 부분에 저장
- *.cfp 파일이 없다면 복구 불가능

## 언두 로그 및 리두 로그 암호화
- MySQL 8.0.16 버전부터는 innodb_undo_log_encrypt와 innodb_redo_log_encrypt 변수를 이용해 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장 가능
- MySQL 서버는 리두 로그나 언두 로그를 평문으로 저장하다가 암호화가 활성화되면 그때부터 생성되는 리두 로그나 언두 로그만 암호화해서 저장
- 언두나 리두 로그의 경우 현재 암호화가 비활성화되어도 활성화되었을 때의 로그는 암호화되어있기 때문에 암호화키가 필요

## 바이너리 로그 암호화
- 데이터베이스의 변경된 내용을 기록하는 로그 파일로, 주로 복제와 데이터 복구를 위해 사용
- 의도적으로 상당히 긴 시간 동안 보관하는 서비스도 있고 떄로는 증분 백업을 위해 보관하기도 함
- 바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고 MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터를 암호화하지 않음

#### 바이너리 로그 암호화 키 관리
- 2단계 암호화 키 관리 방식 사용
- 바이너리 로그와 릴레이 로그 파일의 데이터는 파일 키로 암호화해서 디스크로 저장하고 파일 키는 `바이너리 로그 암호화 키`로 암호화해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장됨

#### 바이너리 로그 암호화 키 변경
- `ALTER INSTANCE ROTATE BINLOG MASTER KEY;`

#### mysqlbinlog 도구 활용
- 바이너리 로그 암호화 키는 그 바이너리 로그나 릴레이 로그 파일을 생성한 MySQL 서버만 가지고 있기 때문에 MySQL 서버와 관계없이 mysqlbinlog 도구만으로는 복호화할 방법 없음
- `mysqlbinlog --read-from-remote-server -u root -p -vvv mysql-bin.000011`
- MySQL 서버에게 요청하기 위해 `--read-from-remote-server` 파라미터와 서버 접속 정보 입력

## 9.1 개요

### 9.1.1 쿼리 실행 절차
- MySQL 서버에서 쿼리가 실행되는 과정
    - 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)
        - `SQL 파싱(Parsing)`이라고 함.
        - MySQL 서버의 `SQL 파서`로 무듈로 처리함.
        - SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러짐.
        - `SQL 파스 트리`가 만들어짐.
        - MySQL 서버는 SQL 문장 자체가 아니라 SQL 파스 트리를 이용해서 쿼리를 실행함.
    - SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
        - 불필요한 조건 제거 및 복잡한 연산의 단순화
        - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
        - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
        - 가져온 레코드들을 임시 테이블로 넣고 다시 한번 가공해야 하는지 결정
    - 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터 가져옴.

### 9.1.2 옵티마이저의 종류
- 옵티마이저의 분류
    - 현재 대부분의 DBMS : 비용 기반 최적화(Cost-based optimizer, CBO) 방법
    - 예전 초기 버전의 오라클 DBMS : 규칙 기반 최적화(Rule-based optimizer, RBO)방법

- 규칙 기반 최적화
    - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선 순위에 따라 실행 계획을 수립하는 방식
    - 통계 정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어냄.
    - 사용자의 데이터는 분포도가 매우 다양하기 때문에 규칙 기반 최적화는 오래전부터 사용되지 않음.

- 비용 기반 최적화
    - 쿼리를 처리하기 위한 여러 가지 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
    - 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행

## 9.2 기본 데이터 처리
### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- `풀 테이블 스캔`
  : 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
  - 풀 테이블 스캔 하는 조건
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
  - MySQL에는 풀 테이블 스캔을 할 때 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수가 없음.
  -> 하지만, InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작됨.
  <br>

- `리드 어헤드` : 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
    - 풀 테이블 스캔이 진행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드(Foreground thread, 클라이언트 스레드)가 페이지 읽기를 실행하지만, 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김.
    - 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킴. 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠.
    - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하면 되어 쿼리가 상당히 빨리 처리됨.
    - MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수를 이용해 InnoDb 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값 정할 수 있음.
    - 포그라운드 스레드에 의해 `innodb_read_ahead_threshold` 시스템 변수가 읽히면 InnoDB 스토리지 엔진은 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재
    - 일반적으로는 디폴트로 사용하면 충분, 데이터 웨어하우스용으로 MySQL을 사용한다면 더 낮은 값으로 설정해서 빨리 리드 어헤드가 실행되게 해도 좋음.
      <br>

- 리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용됨.
    - 인덱스를 처음부터 끝까지 스캔하는 것을 의미
    - 풀 테이블 스캔보다 용량이 작은 인덱스를 선태갛는 것이 디스크 읽기 횟수를 줄일 수 있기 때문에 가능하다면 인덱스 스캔을 사용
    - 레코드에만 있는 칼럼이 필요한 쿼리의 경우에는 풀 인덱스 스캔을 활용하지 못하고, 풀 테이블 스캔을 함.

### 9.2.2 병렬 처리
- 용도가 한정되어 있긴 하지만, MySQL 8.0 버전부터는 쿼리의 병렬 처리가 가능해짐.
- `innodb_parallel_read_threads` 라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있음.
- MySQL 서버에서 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없음.
- 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU 코어 개수를 넘어서는 경우에는 오히려 성능을 떨어뜨릴 수도 있음.

### 9.2.3 ORDER BY 처리(Using filesort)
- 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용됨.
- 정렬을 처리하는 방법
    - `인덱스 이용`
        - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름.
        - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림.
        - 인덱스 때문에 디스크 공간이 더 많이 필요함.
        - 인덱스 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요.
    - `filesort 이용`
        - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때 단점이 장점으로 바뀜.
        - 정렬해야 할 레코드가 많지 않으면 메모리에서 filesort 처리되므로 충분히 빠름.
        - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느림.

- 모든 정렬을 인덱스를 이용하도록 튜닝하기 불가능한 이유
    - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 이유
    - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
    - UNION 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야 하는 경우
- MySQL 서버에서 인덱스를 이용하지 않고, 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 "Using filesort" 메시지가 표시되는지 여부로 판단 가능

#### 9.2.3.1 소트 버퍼
- `소트 버퍼` : 정렬을 하기 위해 별도로 할당하는 메모리 공간
- 정렬이 필요한 경우에만 할당
- 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만, 최대 사용 가능한 소트 버퍼의 공간은 `sort_buffer_size`라는 시스템 변수로 설정 가능.
- 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납됨.
  <br>
- 정렬이 문제가 되는 이유
    - 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 큰 경우
        - MySQL을 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 때 임시 저장을 위해 디스크를 사용함.

- `멀티 머지(Multi-Merge)`
  : 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록하고, 다음 레코드를 가져와 반복적으로 디스크에 임시저장하게 되는데, 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행하는데, 이 때의 병합 작업
  - 수행된 멀티 머지 횟수는 `Sort_merge_passes`라는 상태 변수에 누적해서 집계됨.

- 위 작업들이 모두 디스크 쓰기와 읽기를 유발하고, 레코드 건수가 많을수록, 반복 작업의 횟수가 늘어나게 됨.
- `sort_buffer_size` 시스템 변수 설정 값이 크면 메모리에서 모두 처리되니 빨라질 것으로 예상하지만, 실제로는 큰 차이 없음.
    - 리눅스 계열의 운영체제에서는 너무 큰 sort_buffer_size를 사용하면, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있음.

    - 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니라, 커넥션이 많으면 많을수록, 정렬이 많으면 많을 수록 소트 버퍼로 소비되는 메모리 공간이 커짐.
    - 소트 버퍼를 10MB이상으로 설정하면, 운영체제가 메모리 부족 현상을 겪을 수도 있고, 더는 메모리 여유ㅠ 공간이 없으면 운영체제의 OOM-Killer가 프로세스를 강제 종료하는데, 메모리 가장 많이 사용하는 프로세스를 강제 종료하기 때문에 일반적으로 MySQL 서버가 강제 종료 1순위가 됨.

#### 9.2.3.2 정렬 알고리즘
- 정렬 모드
- `싱글 패스(Single-pass)`
- `투 패스(Two-pass)`

- 정렬 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능으로 확인 가능

- MySQL 서버의 정렬 방식
    - <sort_key, rowid>: 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬하는 방식 => `투패스`
    - <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리에 저장 => `싱글 패스`
    - <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈로 메모리에 저장=> `싱글 패스` , MySQL 5.7버전부터 도입됨.

#### 9.2.3.2.1 싱글 패스 정렬 방식
- 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼을 전부 담아서 정렬을 수행하는 정렬 방식

#### 9.2.3.2.2 투 패스 정렬 방식
- 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 방식
- 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식
- MySQL 8.0 버전에서도 여전히 특정 조건에서는 사용
  <br>
- 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 불합리
    - 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하다는 점은 있음.
- 투 패스 정렬 방식을 사용하는 경우
    - 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
    - BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

- 싱글 패스 방식은 정렬 대상 레코드 크기나 건수가 작은 성능 빠른 성능을 보이고, 튜 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우에 효율적

### 9.2.3.3 정렬 처리 방법
- 3가지 정렬 처리 방법
    - 인덱스를 사용한 정렬
    - 조인에서 드라이빙 테이블만 정렬
    - 조인에서 조인 결과를 임시 테이블로 저장 후 정렬

- 옵티마이저가 정렬 대상 레코드 최소화 하기 위한 방법
    - 조인의 드라이빙 테이블만 정렬한 다음 조인 수행
    - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행

#### 9.2.3.1 인덱스를 이용한 정렬
- 반드시 ORDER BY에 명시한 칼럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서로 생성된 인덱스가 있어야 함.
    - WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 함.
    - B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스, R-Tree 인덱스에서는 인덱스를 이용한 정렬이 불가함.
    - 여러 테이블이 조인되는 경우 네스티드 루프(Nested-loop) 방식의 조인에서만 이 방식 사용 가능

- 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬되어 있기 때문에 인덱스 순서대로 읽기만 하면 됨.
    - B-Tree 인덱스가 키 값으로 정렬되어 있기 때문에 가능함.
    - 네스티드-루프 방식으로 조인이 실행되기 때문에 조인으로 인한 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않음.
    - 조인이 사용된 계획에 조인 버퍼(Join buffer)가 사용되면 순서가 흐트러질 수 있음.

#### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
- 조인을 실행하기 전 첫 번째 테이블의 레코드를 먼저 정렬한 다음 다음 조인을 실행
    - 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY를 작성해야 함.

#### 9.2.3.3.3 임시 테이블을 이용한 정렬
- 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있음.
- 3가지 정렬 방식 중 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방식

#### 9.2.3.3.4 정렬 처리 방법의 성능 비교
**9.2.3.3.4.1 스트리밍 방식**
- 서버 쪽에서 처리할 데이터가 얼마인지 관계없이 조건에 일치하는 렠코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
    - 이 방식으로 쿼리 처리하면 클라이언트는 쿼리를 요청하고 바로 원했던 첫번째 레코드 전달 받음.
    - 가장 마지막 레코드는 언제 받을 수 알 수 없지만, 그다지 중요 X
- 스트리밍 방식으로 처리되는 쿼리는 얼마나 많은 쿼리 처리하느냐와 관계 없이 빠른 응답 시간 보장해줌.
- LIMIT처럼 결과 건수를 제한 하는 조건들은 쿼리 전체 실행 시간을 줄여줄 수 있음.

**9.2.3.3.4.2 버퍼링 방식**
- ORDER BY나 GROUP BY는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 함.
- 버퍼링 방식으로 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에 일괄에서 일괄 가공해야 하므로, 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 함.
- 건수를 제한해도 별 차이 없음.


#### 9.2.3.4 정렬 관련 상태 변수
- MySQL 서버는 처리하는 주요 작어벵 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장함.
```
mysql > FLUSH STATUS
```
- 위 명령으로 몇 건의 레코드나 정렬 처리 수행했는지, 소트 버퍼 간의 병합 작업은 몇 번 발생했는지 확인 가능

### 9.2.4 GROUP BY 처리
- ORDER BY와 함께 쿼리가 스트리밍 처리 할 수 없게 하는 처리 중 하나
- HAVING절은 GROUP BY에 대해 필터링을 실행하는데, GROUP BY에 적용된 조건은 인덱스 이용해 처리될 수 없으므로, HAVING 절을 튜닝하려고 인덱스를 생성하거나 고민할 필요 없음.

- GROUP BY에서 인덱스 사용하는 경우
    - 인덱스 스캔 (인덱스를 차례대로 읽음)
    - 루스 인덱스 스캔 (인덱스를 건너 뛰면서 읽음)

- GROUP BY에서 인덱스 사용하지 않는 경우
    - 임시 테이블 이용

#### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만을 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인넥스가 있다면, 그 인덱스를 차례대로 읽으면서 그루핑 작업 수행하고, 그 결과로 조인 처리
- GROUP BY가 인덱스를 사용해서 처리된다고 하더라도 그룹 함수(Aggregation function) 등의 그룹값 처리해야해서 임시 테이블 필요할 때도 있음.
- GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블 필요 없음.
- 쿼리 실행 계획에서 Extra 칼럼에 별도로 GROUP BY 관련 코멘트("Using index for group-by")나 임시 테이블 사용 또는 정렬 관련 코멘트("Using temporary, Using filesort"가 표시되지 않음.

#### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
-  쿼리 실행 계획에서 Extra 칼럼에 "Using index for group-by" 코멘트가 표시됨.
- 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용 가능
- 프리픽스 인덱스(Prefix index, 칼럼 앞쪽 일부만으로 생성된 인덱스)는 사용 불가
- 인덱스 유니크한 값의 수가 적을수록 성능 향상됨. (분포도가 좋지 않은 인덱스 일수록 빠른 결과)
- 별도의 임시 테이블 필요 없음.

#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY
- GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리됨.
- 쿼리 실행 계획에서 Extra 칼럼에 "Using temporary" 메시지 표시됨.
    - Using filesort가 표시되지 않는 경우
      : MySQL 8.0부터는 묵시적인 정렬이 실행되지 않음.
      - Using filesort가 표시되지 않는 경우
      : ORDER BY가 함께 사용된 경우 명시적인 정렬 작업을 수행해서 뜸.


### 9.2.5 DISTINCT 처리
- 특정 칼럼의 유니크한 값만 조회하기 위해 SELECT 쿼리에 DISTINCT 사용

#### 9.2.5.1 SELECT DISTINCT ...
- GROUP BY와 동일한 방식으로 처리됨.
- 조회하는 모든 칼럼 조합이 유니크 한 것만 가져옴.
- DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미침, SELECT하는 여러 칼럼 중에서 일부 칼럼만 유니크하게 조회하는 것이 아님!

#### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT
- 집합 함수의 인자로 전달된 칼럼 값이 유니크한 것들을 가져옴.

### 9.2.6 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때 사용
- MySQL에서 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블 크기가 커지면 디스크로 옮겨짐.(특정 예외 케이스의 경우 바로 디스크에 만들어지기도)
- 내부적인 임시 테이블은 다른 세션이나 다른 쿼리에서 볼 수 없고, 쿼리의 처리가 완료되면 자동으로 삭제됨.

#### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블
- MySQL 8.0 이전
  : 스토리지 엔진과 상관 없이 임시테이블이 메모리 사용할 때는 MEMORY 스토리지 엔진을, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 이용
  - MySQL 8.0 이후
  : 메모리는 TempTable이라는 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 InnoDB를 사용

#### 9.2.6.2 임시 테이블이 필요한 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫번째 테이블이 아닌 쿼리
- DISTINCT나 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리 (select_type이 UNION RESULT인 경우)
- 쿼리 실행 계획에서 select_type이 DERIVED인 쿼리

-> 마지막 쿼리 패턴만 유니크 인덱스가 없는 내부 임시 테이블이 생성됨.

#### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우
- UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- DISTINCT나 GROUP BY 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 temptable_max_ram 시스템 변수 값보다 큰 경우

#### 9.2.6.4 임시 테이블 관련 상태 변수
- "Using temporary"가 표시되면 임시 테이블을 사용했다는 사실 알 수 있음.
    - 임시 테이블이 메모리에서 처리됐는지, 디스크에서 처리됐는지는 알 수 없음.
    - 몇 개의 임시 테이블이 사용됐는지도 알 수 없음.
- 임시 테이블이 디스크에 생성됐는지, 메모리에 생성됐는지 확인해 보려면, MYSQL 서버의 상태 변수(SHOW SESSION STATUS LIKE 'Created_tmp%';)을 확인해 보면 됨.

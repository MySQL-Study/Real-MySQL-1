# Chapter9 - 옵티마이저와 힌트(1) (처음~9.2)

## 9.1 개요

### 9.1.1 쿼리 실행 절차

1. SQL 파싱 -> SQL 파스 트리 생성
2. SQL 파스 트리 기반으로 어떤 테이블부터 읽을지, 어떤 인덱스를 써서 읽을지 결정 -> 실행 계획 완성
3. 2단계의 결정에 따라 스토리지 엔진으로부터 데이터를 가져옴

### 9.1.2 옵티마이저의 종류

-   규칙 기반 최적화: 통계 정보(테이블 레코드 건수, 선택도 등)을 고려하지 않는 방식. 옵티마이저에 내장된 규칙에 따라 실행함. 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어 냄
-   비용 기반 최적화: 쿼리를 처리하기 위한 여러 가지 방법을 만들고, 각 실행 계획 별 비용을 산출함. 그 중 가장 최소 비용을 택해 쿼리를 실행

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

#### 다음 조건 하에서 풀 테이블 스캔 발생

1. 테이블 레코드 건 수가 너무 적어서 인덱스를 사용하는 것보다 전체를 읽어오는 게 더 빠른 경우
2. where 절이나 on 절에서 인덱스를 이용하기 어려운 경우
3. 인덱스를 사용할 순 있으나, 일치 레코드들이 많아 차라리 풀 테이블 스캔 하는 게 더 빠른 경우

#### 한꺼번에 여러 페이지 읽기

-   풀 테이블 스캔 시에 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능이 내장되어 있음
-   다만 몇 개의 페이지를 읽어올지를 사용자가 설정할 순 없음.
-   InnoDB에서는 Read ahead (어떤 영역의 데이터가 앞으로 필요해지리라 예측하고 미리 디스크에서 읽어 버퍼 풀에 올려 두는 것)가 발생함.
-   innodb_read_ahead_threshold 변수로 언제 read ahead를 시작할지 임계값을 설정할 수 있음

#### 쿼리 비교

-   `SELECT COUNT(*) FROM employees;` : 풀 인덱스 스캔 (인덱스만 봐도 개수 셀 수 있으니!)
-   `SELECT * FROM employees;`: 풀 테이블 스캔

### 9.2.2 병렬 처리

-   여러 스레드가 동시에 한 쿼리를 나누어 수행하는 기능이 8.0부터 생겼다.
-   여러 스레드가 동시에 각각의 쿼리를 수행하는 건 MySQL 서버가 처음 만들어질 때부터 가능했음. 여기선 그 이야기가 아님.
-   `innodb_parallel_read_threads`라는 시스템 변수를 이용해 몇 개의 스레드로 하나의 쿼리를 수행할지 정할 수 있음.
-   8.0 버전에서는 아무런 WHERE 조건 없이 단순히 테이블 전체 건수를 가져오는 쿼리만 병렬 처리 가능:
    ```sql
    innodb_parallel_read_threads=1;
    SELECT COUNT(*) FROM employees;
    ```
-   다만 아무리 병렬 처리용 스레드 개수를 늘려도 서버의 CPU 코어 개수를 넘어서는 경우 성능이 더 떨어질 수 있으니 주의해야함

### 9.2.3 ORDER BY 처리

정렬은 인덱스를 사용하거나 쿼리 실행 시 정렬하는 두 가지 방법이 있다.

1. 인덱스를 사용한 정렬
    - 장점: 미리 정렬되어 저장되므로 빠르다.
    - 단점: 쓸 때 정렬해서 쓰므로 느리다. 또 인덱스 만큼의 디스크 공간이 더 필요하다.
2. 쿼리 실행 시점에 정렬 (Using filesort)
    - 장점: 쓸 때 정렬할 필요 없으므로 느리지 않다. 공간도 안 필요하다.
    - 단점: 레코드가 많으면 쿼리 수행 시간이 오래 걸릴 수 있다.

모든 ORDER BY를 인덱스를 통해 지정해놓기란 어려운 일이다. 인덱스가 너무 많아질 우려도 있고, GROUP BY의 결과나 DISTINCT의 결과를 처리해야하는 경우는 인덱스를 사용하기 어렵다.

#### 소트 버퍼

-   소트 버퍼: 정렬을 위한 별도의 메모리 공간
-   정렬 문제점: 만약 정렬해야할 레코드 건수가 할당된 소트 버퍼 크기보다 크다면 MySQL은 디스크에까지 임시 저장을 한다. 이 때에 디스크 읽기/쓰기가 발생하여 느려질 우려가 있다.
-   하지만 소트 버퍼 크기를 키운다고 해서 이 문제가 해결되는 것은 아니다. 저자의 벤치마크 결과 sort_buffer_size 변수가 크다고 더 빨라지는 건 아니었다. 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있기 때문이다.
-   소트 버퍼는 여러 클라이언트가 공유할 수 없는 영역. 때문에 커넥션이 많고 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커진다. 소트 버퍼가 커지면 운영체제 메모리가 부족해질 수 있다.

#### 정렬 알고리즘

정렬 모드:

-   싱글 패스: 레코드 전체를 소트 버퍼에 담기
    -   테이블을 두 번 읽을 필요가 없음.
    -   다만 더 많은 소트 버퍼가 필요함.
    -   최신 버전에서는 주로 이 싱글 패스 방식을 이용함.
-   투 패스: 정렬의 기준이 되는 컬럼만 소트 버퍼에 담기
    -   테이블을 두 번 읽어야해서 불합리함.
    -   싱글 패스 대비 더 적은 소트 버퍼 가능.
    -   레코드 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때, BLOB이나 TEXT 타입처럼 클 우려가 있는 컬럼이 SELECT 대상에 포함될 때에는 이 투 패스 방식을 이용함.

#### 정렬 처리 방법

세 종류가 있으며, 아래로 갈수록 정렬 처리 속도가 느려진다:

1. 인덱스를 사용한 정렬
    - 인덱스 정렬의 조건:
        - ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블 (드라이빙 테이블)에 속하고,
        - ORDER BY의 순서대로 인덱스가 있어야 함
        - WHERE 절에 첫 번째로 읽는 테이블의 컬럼 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 함
        - B-Tree 계열이 아닌 해시 인덱스, 전문 검색 인덱스를 이용한 정렬은 불가능
        - 여러 테이블이 조인되는 경우 Nested-loop 방식의 조인에서만 인덱스 정렬 사용 가능
    - ORDER BY절을 넣자.
        - ORDER BY 절을 넣지 않아도 인덱스가 자동으로 정렬을 해주니 넣지 않아도 되는 것 아닌가? 그래도 넣자.
        - 어차피 넣는다고 해서 작업이 한 번 더 수행되거나 하지 않는다. 성능 문제 없다.
        - 또한 오히려 나중에 모종의 이유로 쿼리 실행계획이 변경되는 경우 순서가 흐트러질 우려가 있다. 이러한 버그를 막기 위해서라면 ORDER BY절을 꼬박꼬박 넣어주는 것을 추천한다.
2. 조인에서 드라이빙 테이블(기준 테이블)만 정렬 (Using filesort)
    - 조인을 하면 결과 레코드가 몇 배로 불어나기 때문에, 조인 전에 첫 번째로 읽히는 테이블(드라이빙 테이블) 먼저 정렬하고 가는 방법을 택함
    - 예시:
        ```sql
        SELECT * FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no AND e.emp_no BETWEEN 100002 AND 100010
        ORDER BY e.last_name;
        ```
        - 드라이빙 테이블은 employee 발탁. WHERE절로 먼저 거를 수 있기 때문 + salaries의 emp_no에 인덱스가 존재하기 때문
        - employee에서 9건의 데이터를 먼저 뽑고, e.last_name 순으로 filesort 정렬을 한 다음, salaeries와 join하여 결과 도출
3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 (Using temporary; Using filesort)
    - 2번 패턴 외에는 모두 JOIN 결과에 대한 임시 테이블이 만들어지고, 그걸 또 정렬함. 때문에 가장 느리다.
    - 예시:
        ```sql
        SELECT * FROM employees e, salaries s
        WHERE s.emp_no=e.emp_no AND e.emp_no BETWEEN 100002 AND 100010
        ORDER BY s.salary;
        ```
        - 조인 결과를 임시 테이블에 저장, 그 결과를 다시 정렬 처리함.

#### 정렬 처리 방법의 성능 비교

-   `ORDER BY`나 `GROUP BY` 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수 만큼만 가져와서는 처리할 수 없다. 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 수행한 뒤 LIMIT 처리를 할 수 있다.
-   인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동할 수밖에 없는가?
    -   스트리밍 처리
        -   전체를 주는 게 아니라, 조건에 맞는 레코드가 있을 때마다 바로바로 전송해주는 방식.
        -   쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해줌
        -   LIMIT 조건이 있으면 없을 때보다 마지막 레코드 조회까지 시간이 단축됨
        -   정렬 처리 방법 중, 인덱스를 사용한 경우엔 스트리밍으로 보낼 수 있음
    -   버퍼링 처리
        -   ORDER BY나 GROUP BY가 있는 경우 스트리밍 불가능. 모두 가져와서 정렬/그루핑 해야 하기 때문
        -   모든 걸 받아서 작업하는 동안 클라이언트는 논다. 스트리밍의 반대 '버퍼링'
        -   LIMIT 조건이 있어도 성능이 개선되지는 않음
        -   정렬 처리 방법 중, 인덱스 사용 정렬을 제외한 경우 버퍼링 처리됨
-   결론: 가능하다면 인덱스를 사용한 정렬로 유도하기, 그렇지 못하면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하기

#### 정렬 관련 상태 변수

-   `Sort_scan`: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
-   `Sort_range`: 인덱스 레인지 스캔을 통해 검색된 정렬 작업 횟수
-   `Sort_merge_passes`: 단위 정렬 작업에 대한 병합 횟수
-   `Sort_rows`: 전체 정렬된 건수

### 9.2.4 GROUP BY 처리

1. 인덱스 스캔을 이용하는 GROUP BY
    - GROUP BY 컬럼에 인덱스가 있는 경우
2. 루스 인덱스 스캔을 이용하는 GROUP BY ("Using index for group-by")
    - 인덱스 레코드를 건너뛰면서 필요한 부분만 가져오는 것
    - `(emp_no, from_date)`로 인덱스가 걸려있을 때, WHERE에 from_date만을 두고, GROUP BY에 emp_no를 두는 경우
        - 유일한 emp_no를 하나 찾고, `WHERE emp_no = 1 AND from_date = '2025-02-15'` 느낌으로 인덱스를 탄다.
3. 임시 테이블을 사용하는 GROUP BY
    - 인덱스를 전혀 사용하지 못하는 경우
    - GROUP BY 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거 및 집합 함수 연산을 수행함
    - GROUP BY만 있으면 별도의 정렬없이 그룹화만 실행됨 (8.0 이전엔 암묵적 정렬이 있긴 했다)
    - GROUP BY와 ORDER BY를 함께 실행하면 명시적으로 정렬 작업이 실행됨 ("Using temporary" & "Using filesort")

### 9.2.5 DISTINCT 처리

1. SELECT DISTINCT (집합 함수 없는 경우)
    - GROUP BY와 동일한 방식으로 처리됨
    - 다음 두 쿼리는 동일하게 수행됨:
        - `SELECT DISTINCT emp_no FROM salaries;`
        - `SELECT emp_no FROM salaries GROUP BY emp_no;`
    - SELECT DISTINCT에서 DISTINCT 뒤에 오는 모든 컬럼에 대해 UNIQUE한 값을 조회한다.
        - `SELECT DISTINCT first_name, las_name FROM employees;`
        - 이것은 (first_name, last_name) 조합 전체가 유니크한 값을 찾아오는 것임.
        - (first_name)만 유니크하고, last_name은 그냥 다 가져오는 그런 방식이 아님
2. 집합 함수와 함께 사용된 DISTINCT
    - `SELECT COUNT(DISTINCT s.salary) FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND e.emp_no BETWEEN 100001 AND 100100;`
    - 집합 함수 내에서 DISTINCT 사용!
    - 조인 후에 salary 컬럼만 저장하기 위해 임시 테이블을 만들고, 이 때 salary에 unique 인덱스를 걸어 사용함
    - `SELECT COUNT(DISTINCT s.salary), COUNT(DISTINCT e.las_name)` 이러면 임시 테이블 2개 생성
    - 인덱스된 컬럼에 DISTINCT를 처리할 때엔 인데스를 활용할 수 있음:
        - `SELECT COUNT(DISTINCT emp_no) FROM employees;`

### 9.2.6 내부 임시 테이블 활용

1. 메모리 임시 테이블과 디스크 임시 테이블

    - 메모리 임시 테이블: TempTable 스토리지 엔진 사용
        - 임시 테이블의 크기가 1GB보다 커지는 경우에는 메모리의 임시 테이블을 디스크로 기록함
        - 디스크 저장방식은 주로 MMAP 파일로 기록한다. InnoDB 테이블로 기록하는 것보다 오버헤드가 적기 때문
    - 디스크 임시 테이블: InnoDB 스토리지 엔진 사용
        - 임시 테이블이 처음부터 디스크에 생성되는 경우도 있다.
        - 기본값으로 InnoDB 테이블로 기록된다.

2. 임시 테이블이 필요한 쿼리: 실행 계획에서 "Using temporary"
    - ORDER BY와 GROUP BY에 명시된 컬럼이 다른 쿼리
    - ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
    - DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
    - UNION이나 UNION DISTINCT가 사용된 쿼리
    - 쿼리의 실행계획에서 select_type이 DERIVED인 쿼리
3. 임시 테이블이 디스크에 생성되는 경우
    - UNION이나 UNION ALL에서 SELECT 되는 컬럼 중에서 길이가 512바이트 이상인 크기의 컬럼이 있는 경우
    - GROUP BY나 DISTINCT 컬럼에서 512바이트 이상인 크기의 컬럼이 있는 경우
    - 메모리 임시 테이블의 크기가 ~~ 시스템 변수 값보다 큰 경우
4. 임시 테이블 관련 상태 변수
    - 임시 테이블이 디스크에 생성되었는지 메모리에 생성되었는지 확인하는법:
        - `SHOW SESSION STATUS LIKE 'Created_tmp%`

# 9 옵티마이저와 힌트 
옵티마이저는 최적의 쿼리 실행 계획을 수립한다. 
`Explain` 명령으로 쿼리 실행 계획을 확인할 수 있는다.
이를 이해하고 활용하기 위해서는 최적화에 대해 지식을 갖추고 있어야한다. 


## 9.1.1 쿼리 실행 절차

1. SQL문장을 MySQL이 이해할 수 있도록 분리한다. (parse tree) 
SQL파서 모듈로 처리하고 문법 검사를 진행한다. 
2. SQL의 파싱 정보를 확인하면서 어떤 테이블, 어떤 인덱스를 사용할지 선택한다.
"최적화 및 수립 단계"이며 `옵티마이저`에서 처리한다. 불필요한 조건 제거, 테이블 조인 순서 결정, 인덱스 결정 등등 많은 작업을 한다. 
3. 2에서 결정된 읽기 순서나 인덱스를 이용하여 스토리지 엔진으로부터 데이터를 가져온다. 
2의 계획대로 실행한다. 1,2 는 주로 MySQL엔진이 처리하고 3은 MySQL엔진과 스토리지 엔진이 함께처리 한다.


## 9.1.2 옵티마이저의 종류
옵티마이저는 DBMS의 두뇌이다.
- 비용 기반 최적화 (Cost Based Optimizer)
현재 대부분의 DBMS가 사용한다.
가능한 여러 방법을 만들고, 각 작업의 비용과 통계정보를 이용하여 비용을 산출한다.
이 중에서 최소 비용을 선택한다. 
    
- 규칙 기반 최적화 (Rule Based Optimizer)
비용을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다. 	




# 9.2 기본 데이터 처리


## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔 

- 풀 테이블 스캔
인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청을 처리하는 방식이다. 많은 디스크 읽기가 필요하다. 

옵티마이저는 다음과 같은 상황일 때 풀 테이블 스캔을 선택한다. 
- 레코드의 개수가 너무 작아서 인덱스보다 풀 테이블 스캔이 빠른경우
- where 절이나 On 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있지만, 조건 일치 레코드가 너무 많은 경우 

InnoDB에서는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 `리드 어헤드` 작업이 자동으로 실행된다. 
`리드 어헤드`는 데이터가 앞으로 필요해 질 것을 예측하여 미리 버퍼풀로 가져오는 기능이다. 
이를 통해 백그라운드 스레드에서는 4 -> 8 -> ...->64 까지 한번에 불러오는 페이지 수를 늘려가며 버퍼풀에 불러온다. 
이 기능은 인덱스 풀 스캔에서도 동일하게 사용된다. 



## 9.2.2 병렬 처리 

8.0부터는 용도가 한정되어 있지만 병렬처리가 가능해졌다. 
이 병렬처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것이다. 
`SET SESSION innodb_parallel_read_threads=1` 이를 이용하여 최대 몇개의 스레드를 이용할지 변경할 수 있다. 
서버의 Cpu 개수보다 많아지면 성능이 오히려 저하된다. 

## 9.2.3 ORDER BY 처리(Using filesort)

정렬은 거의 필수적으로 사용된다. 
정렬을 처리하는 방법은 인덱스를 이용하는 방법과 `filesort`라는 별도의 처리를 이용하는 방법으로 나눌 수 있다. 
인덱스를 모든 정렬 조건에 설정할 수 없으므로 "filesort" 방법이 필요하다. 
쿼리 실행 계획에서 Extra에 Using filesort 표시 여부로 확인할 수 있다.

### 9.2.3.1 소트 버퍼

MySQL은 정렬을 진행하기 위해 별도의 메모리 공간을 할당받아 사용한다. 이를 소트버퍼 라고 한다.
`sort_buffer_size`라는 시스템 변수로 설정할 수 있고, 정렬 후 메모리공간은 반납된다.

정렬할 데이터가 버퍼 크기보다 크다면 잘라서 진행한다. 이때 임시 저장할 공간으로 디스크를 사용한다. 
나누어서 정렬시킨 데이터를 다시 병합하면서 정렬하는데 이를 멀티 머지 라고 표현한다. 
이 작업은 디스크 읽기 쓰기를 유발하며 데이터가 클수록 많이 반복된다. 

그렇다면 소트 버퍼의 크기를 크게하면 무조건 빠를까? 
답은 아니다. 큰 메모리 공간을 할당하면서 성능이 훨씬 떨어질 수도 있다. 

소트 버퍼는 세션 메모리 영역에 해당한다. 여러 클라이언트가 공유해서 사용하는 것이 아니라 클라이언트마다 사용하는 공간이다. 따라서 여러 커넥션이 동시에 활용한다면 메모리 부족 현상이 발생할 수 있다. 


### 9.2.3.2 정렬 알고리즘
정렬할때 레코드 전체를 소트버퍼에 담는 방식과 정렬기준만 소트 버퍼에 담는 방식이 있다. 
이를 싱글패스와 투패스라고 부른다 (비공식 명칭)

- `<sort_key, rowid>` : 정렬 키와 레코드의 로우 아이디만 가져와 정렬 (투패스 방식)
- `<sort_key, additional_fields>` : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 고정 사이즈로 메모리 저장 
- `<sort_key, packed_additional_fields>` : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 가변 사이즈로 메모리 저장 

2,3 번 방식을 투패스 라고 부른다. 


####  9.2.3.2.1 싱글패스 정렬 방식
소트 버퍼에 칼럼을 전부 담아서 정렬을 수행하는 방식이다. 
그림처럼 정렬에 필요하지 않은 last_name까지 모두 조회하여 소트버퍼에 담고 정렬을 수행한다.
![](https://velog.velcdn.com/images/pi1199/post/dc731ba2-73de-4092-bb4e-6fa5516fed47/image.png)

####  9.2.3.2.2 투패스 정렬 방식
정렬 대상 칼럼과 프라이머리 키 값만 소트버퍼에 담아 정렬을 수행하고, 정렬된 순서대로 다시 테이블을 읽어오는 방식이다. 

![](https://velog.velcdn.com/images/pi1199/post/9bb6fdda-cbf0-436f-8991-6b4d52ef470e/image.png)

이 투패스 방식은 테이블을 2번 읽어야 하기 때문에 i/o작업이 2번 발생한다. 
따라서 새로운 방식인 싱글패스를 주로 사용한다. 물론 싱글패스는 투패스 방식에 비해 소트 버퍼의 크기를 많이 사용한다. 따라서 정렬 할 수 있는 레코드의 수가 절반밖에 안된다. 
그럼에도 불구하고 디스크 I/O를 줄이기 위해 일반적으로 싱글패스 방식을 사용한다. 

그래도 투패스 방식을 사용하는 경우가 있다. 
이는 싱글패스로 한번에 정렬을 완료할 수 없기 때문이다. 소트버퍼의 최대 크기가 정해져 있는데 그 크기를 넘으면 투패스 방식을 사용한다.
- 레코드의 크기가 `max_length_for_sort_data` 변수보다 클 때
- BLOB 이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

> 개발시 SELECT * 을 활용하는 경우가 많은데, 이는 정렬에서 투패스 방식을 이용하도록 하여 소트 버퍼를 비효율적으로 사용하게 만들 수 있다. 
SELECT 시 필요한 칼럼만 조회하라는 이유가 이것이다. 

### 9.2.3.3 정렬 처리 방법

`ORDER BY` 가 사용되면 다음 3가지 방법중 하나로 처리된다.
다음은 정렬처리 방법과 실행 계획의 Extra 칼럼의 내용이다. 아래로 갈수록 처리 속도가 느리다. 
- 인덱스를 이용한 정렬 : 별도 표기 없음
- 조인에서 드라이빙 테이블만 정렬 : "Using filesort" 로 표시
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 : "Using temporary; Using filesort"


인덱스가 있다면 이미 정렬되어 있으므로 순서대로 데이터를 읽는다.
인덱스가 없다면 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리한다(file sort) 
이때, 정렬 대상 레코드를 최소화 하기 위해 2가지 방법 중 하나를 선택한다. 
- 조인 드라이빙 테이블만 정렬하고 조인 수행
- 조인이 끝나고 일치하는 레코드를 가져온 후 정렬 수행


#### 9.2.3.3.1 인덱스를 이용한 정렬
order by에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙 테이블)에 속하고 Order by의 순서대로 정렬된 인덱스가 있어야 한다. 그리고 B-Tree 인덱스가 아닌경우는 사용할 수 없다.

인덱스에 의해 자동정렬 된다고 해도 ORDER BY 절을 없애면 안된다. 옵티마이저가 알아서 정렬을 수행하지 않기도 하고, 쿼리 실행 계획이 변경되면서 정렬을 하지 않아 버그로 이어질 가능성이 있다. 

![](https://velog.velcdn.com/images/pi1199/post/ee1de626-334d-448e-9b38-63723627829f/image.png)

#### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
조인이 진행되면 결과 레코드의 건수가 몇배가 되고, 레코드의 크기도 커진다. 
따라서 정렬을 먼저 수행한 뒤 조인하는 것이 차선책이 된다. 이 방법을 이용하려면 첫번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 order by절을 작성해야 한다. 

![](https://velog.velcdn.com/images/pi1199/post/e364326d-7866-4727-bc28-1b16a9717461/image.png)

```SQL
SELECT * FROM employees e, salaries s
WHERE s.emp_no=e.emp_no AND e.emp_no BETWEEN 100002 ABD 100010
ORDER BY e.last_name;
```
위 그림과 쿼리문의 실행 순서는 다음과 같다. 
1. 인덱스를 이용해 `e.emp_no BETWEEN 100002 AND 100010`조건 검색
2. 검색 결과를 last_name 칼럼으로 정렬 수행 (file_sort)
3. 정렬된 결과를 읽으면서 조인 수행

#### 9.2.3.3.3 임시 테이블을 이용한 정렬 
드라이빙 테이블로 정렬하지 않는다면 조인 결과를 임시 테이블에 저장하고 이를 통해 정렬을 수행해야 한다. 
위의 드라이빙 테이블 정렬에서 변경된 점은 정렬 기준뿐이다. 
`ORDER BY s.salary` 는 드라이빙 테이블에 s.salary가 없기에 조인된 데이터에서 정렬을 수행할 수 밖에 없다. 

![](https://velog.velcdn.com/images/pi1199/post/dff7b4dc-6438-4aec-8424-da711bc86a39/image.png)


```SQL
SELECT * FROM employees e, salaries s
WHERE s.emp_no=e.emp_no AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```

#### 9.2.3.3.4 정렬 처리 방법의 성능 비교
limit는 처리 결과의 일부를 가져오기에 작업량을 줄이는 역할을 한다. 
그러나 limit 를 사용하는 경우에도 order by, group by 와 같은 작업은 limit 만큼만 가져와서 처리할 수 없다. 정렬이나 그룹핑을 한 뒤 Limit을 적용해야 하기 때문이다.

인덱스를 사용하지 못하는 정렬이나 그룹핑이 왜 느리게 처리되는지 알아보자. 
쿼리가 처리되는 방법을 스트리밍 방식, 버퍼링 처리 2가지로 구분할 수 있다. 

- **9.2.3.3.4.1 스트리밍 방식 **
서버에서 처리할 데이터가 얼마인지 관계없이 레코드가 검색될 때마다 바로 클라이언트로 전송해주는 방식이다. 
필터링 없이 진행되기에 쿼리가 실행중이어도 동작한다. 따라서 Limit 처럼 결과 수를 제한하는 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있다. 

- **9.2.3.3.4.2 버퍼링 방식 **
order by 나 group by 는 쿼리 결과가 스트리밍 되는 것을 불가능하게 한다. 
정렬 작업을 하는동안 MySQL서버는 대기해야 하기에 응답 속도가 느려진다. 

쿼리 결과를 mysql 서버에서 일괄 가공(정렬, 그룹핑) 해야하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 한다. 그래서 limit이 있어도 성능에 영향이 별로 없다. 



### 9.2.3.4 정렬 관련 상태 변수

MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장하고 있다.
이를 통해 서버가 처리한 정렬 작업의 내용을 어느정도 이해할 수 있다. 

```SQL
SHOW SESSION STATUS LIKE 'Sort%';
+---------------------+---------+
| Variable name       | Value   |
+---------------------+---------+
| Sort_merge_passes   | 56      |
| Sort_range          | 0       |
| Sort_rows           | 279408  |
| Sort_scan           | 1       |
+---------------------+---------+

SELECT first_name, last_name
        FROM employees
        GROUP BY first_name, last_name;

SELECT first_name, last_name
        FROM employees
        GROUP BY first_name, last_name;

SHOW SESSION STATUS LIKE 'Sort%';
+----------------------+------------+
| Variable name        | Value      |
+----------------------+------------+
| Sort_merge_passes    | 112        |
| Sort_range           | 0          |
| Sort_rows            | 558816     |
| Sort_scan            | 2          |
+----------------------+------------+
```
- `Sort_merge_passes`: 멀티 머지 처리 횟수
- `Sort_range`: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- `Sort_scan`: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
 Sort_scan과 Sort_range는 둘 다 정렬 작업 횟수를 누적하고 있는 상태 값
- `Sort_rows`: 지금까지 정렬한 전체 레코드 건수



## 9.2.4 Group By 처리

`Group By`도 스트리밍 처리 할 수 없는 쿼리중 하나다. 
`Group By`에서 사용된 조건(having 조건)은 인덱스를 사용해서 처리할 수 없다. 따라서 튜닝하려고 인덱스를 사용할 필요가 없다.

`Group By`도 인덱스를 사용하는 경우와 그렇지 않은 경우가 있다. 
- 인덱스 스캔 (차례로 읽음)
- 루스 인덱스 스캔
- 인덱스 사용 x (임시 테이블 사용)


### 9.2.4.1 인덱스 스캔 Group by (타이트 인덱스 스캔)
조인 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 Group By칼럼으로 이미 인덱스가 있다면 인덱스를 차례로 읽으면서 그룹핑을 진행하고 그 결과로 조인을 처리한다. 


### 9.2.4.2 루스 인덱스 스캔을 이용하는 Group by 
인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미한다. 
실행 계획의 Extra 칼럼에 "Using index for group-by" 로 표시된다. 
루스 인덱스 스캔으로 처리되는 쿼리에서는 임시테이블이 필요하지 않다. 
인덱스 레인지 스캔에서는 유니크 값이 많을수록 성능이 향상되는 반면, 루스 인덱스 스캔에서는 유니크 값이 적을 수록 성능이 향상된다. 


### 9.2.4.3 임시테이블을 사용하는 Group by
인덱스를 전혀 사용할 수 없을 때 사용하는 Group by이다. 
쿼리 실행 계획의 Extra 컬럼에 "Using temporary"가 표시된다. 8.0부터는 묵시적 정렬이 실행되지 않는다


## 9.2.5 Distinct 처리
distinct 처리에 인덱스를 사용할 수 없다면 항상 임시 테이블이 필요하다.

### 9.2.5.1 Select Distinct ...
단순히 select 되는 레코드 중에서 유니크한 레코드만 가져오고자 한다면 select distinct 형태의 쿼리문을 사용한다. 
이는 Group by 와 동일한 방식으로 처리된다. 
```SQL
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_nop FROM salaries GROUP BY emp_no;
```

주의할 점은 Distinct 는 select 하는 레코드를 유니크하게 하는 것이지 특정 컬럼만 유니크하게 조회하는 것이 아니다. 
`SELECT Distinct(first_name), last_name ...;` 이렇게 사용해도 괄호를 제거하고 first_name, last_name 조합이 유니크한 것을 가져온다. 


### 9.2.5.2 집합 함수와 함께 사용된 Distinct

Min, max, count 등의 집합 함수 내부에서 distinct가 사용될 수 있는데 이는 일반 select distinct와는 다르다. 
일반 select distinct 는 9.2.5.1에서 보았듯이 모든 칼럼의 조합이 유니크한 것을 가져온다. 
반면 집합 함수에서는 집합함수의 인자로 전달된 칼럼 값이 유니크한 것들을 가져온다. 

쿼리의 실행 계획에서 Distinct 가 인덱스를 사용하지 못하면 항상 임시 테이블이 필요하다. 


## 9.2.6 내부 임시 테이블 활용

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑할 때 내부 임시 테이블을 활용한다. 
내부 임시 테이블은 처음에는 메모리에 생성되었다가 크기가 커지면 디스크로 옮겨진다. 쿼리 처리가 완료되면 자동으로 삭제된다. 


### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

8.0 부터는 TempTable 이라는 스토리지 엔진을 사용하고, 디스크 임시테이블은 InnoDB스토리지 엔진을 사용한다. 
Memory 스토리지 엔진은 VARBinary 나 varchar 같은 가변 길이 타입을 지원하지 못하고, MyIsam은 트랜잭션을 사용하지 못하기에 위와 같이 변경되었다.

임시 테이블의 크기가 1GB를 넘어가는 경우 디스크에 임시 테이블을 기록한다. 
`temptable_max_ram` 변수로 최대 크기를 지정한다. 
이때 디스크 저장 방식은 2가지 중 1개를 선택한다.
- MMAP 파일로 디스크에 기록
- InnoDB 테이블로 기록

### 9.2.6.2 임시 테이블이 필요한 쿼리

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인 순서상 첫번째 테이블이 아닌 쿼리(드라이빙 테이블 x)
- DISTINCT와 ORDER BY가 동시에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION 이나 UNION DISTINCT가 사용된 쿼리
- 쿼리 실행 계획에서 select_type이 DERIVED인 쿼리

임시 테이블을 사용하는지 여부는 실행 계획의 Extra 컬럼에 "Using Temporary"가 있는지 확인하면 된다. 

### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

- UNION, UNION ALL에서 SELECT 되는 칼럼 중에서 길이가 512바이트 이상의 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상의 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 지정된 시스템 변수 값보다 큰 경우

### 9.2.6.4 임시 테이블 관련 상태 변수 
임시 테이블이 사용되었지만, 디스크에서 사용했는지 메모리에서 사용했는지, 몇개의 임시 테이블을 사용했는지 알 수 없다. 
따라서 MySQL 의 상태변수로 확인할 수 있다.
```SQL
SHOW SESSION STATUS LIKE 'Created_tmp%';
```
- `Craeted_tmp_tables` : 쿼리 처리를 위해 만들어진 내부 임시 테이블 개수
- `Created_tmp_disk_tables` : 디스크에 만들어진 임시 테이블 개수


# 9. 옵티마이저와 힌트
- 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업 필요

## 9.1 개요
### 9.1.1 쿼리 실행 절차
1. SQL 문장 파싱 -> SQL 파서 사용
2. SQL 파스 트리를 참조하여 어떤 테이블을 읽고 어떤 인덱스를 이용할지 선택 -> 옵티마이저에서 처리(최적화 및 실행 계획 수립)
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터 가져옴

### 9.1.2 옵티마이저의 종류
- 규칙 기반 최적화 (Rule-Based Optimizer, RBO)
  - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
  - 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만듦
  - 어래전부터 많은 DBMS에서 거의 사용되지 않는다.
- 비용 기반 최적화(Cost-Based Optimizer, CBO)
  - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 에측된 통계 정보를 이용해 실행 계획별 비용을 산출
  - 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리 실행

## 9.2 기본 데이터 처리
### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작
  - 리드 어헤드: 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에가져다 두는 것
-> 풀테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김
- `innodb_read_ahead_threshold` 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값 설정 가능
- 데이터 웨어하우스(사용자의 의사 결정에 도움을 주기 위하여 기간시스템의 데이터베이스에 축적된 데이터를 공통의 형식으로 변환해서 관리하는 데이터베이스)용으로 MySQL을 사용한다면 이 옵션을 더 낮은 값으로 설정해서 더 빨리 리드 어헤드가 시작되게 유도하는 것도 좋은 방법
- 풀 인덱스 스캔
  - 단순히 레코드의 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선책하는 것이 디스크 읽기 횟수를 줄일 수 있어 풀 인덱스 스캔 사용

### 9.2.2 병렬 처리
- 여기서의 병렬 처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것 의미
- MySQL 8.0에서는 `innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경 가능
- MySQL 8.0에서는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬 처리 가능
- 병렬 처리용 스레드 개수를 아무리 늘리더라도 *서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있음*에 주의

### 9.2.3 ORDER BY 처리(Using filesort)
|| 장점 | 단점 |
|-------|--------|---------|
| 인덱스 이용 | - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되므로 매우 빠름 | - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림 <br> - 인덱스 때문에 디스크 공간이 더 많이 필요 <br> - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요 |
| Filesort 이용 | - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀜 <br> - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름 | - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느림 |

- 다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
  - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
  - 랜덤하게 결과 레코드를 가져와야 하는 경우
- 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 `Using filesort` 메세지가 표시되는지 여부로 판단 가능

#### 9.2.3.1 소트 버퍼
- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간 = 소트 버퍼
- 버퍼의 크기는 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간으 `sort_buffer_size` 시스템 변수로 설정 가능
- 정렬해야 할 레코드의 견수가 소트 버퍼로 할당된 공간보다 크다면 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크 사용
- 모두 디스크의 쓰기와 읽기를 유발하며 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아짐
- 리눅스 계열의 운영체제에서는 너무 큰 sort_buffer_size를 사용하는 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있음
- 소트 버퍼의 크기는 56KB ~ 1MB가 적절해 보임
- 정렬을 위해 할당하는 소트 버퍼는 세션 메모리 영역
  - 커넥션이 많으면 많을수록 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미

#### 9.2.3.2 정렬 알고리즘
- 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 '싱글 패스'와 '투 패스' 모드로 나눌 수 있음
- 투 패스
  - `<sort_key, rowid>`: 정렬 키와 레코드의 로우 아이디만 가져와서 정렬하는 방식
- 싱글 패스
  - `<sort_key, additional_fileds>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
  - `<sort_key, packed_additional_fields>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈로 메모리 저장

##### 9.2.3.2.1 싱글 패스 정렬 방식
- 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식
- 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨줌

##### 9.2.3.2.2 투 패스 정렬 방식
- 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식
- 정렬에 필요한 칼럼과 프라이머리 키만 읽어서 정렬 수행 후 그 결과 순서대로 테이블을 한 번 더 읽어서 필요한 칼럼을 조회한 결과를 클라이언트 쪽으로 넘김
- 투 패스 방식은 테이블을 두 번 읽어야 하기 떄문에 상당히 불합리하지만 싱글 패스틑 이러한 불합리가 없음
- 하지만 싱클 패스는 더 많은 소트 버퍼 공간이 필요
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용
- 다음의 경우는 투 패스 정렬 방식 사용
  - 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
  - BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때
- 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적
※ * 대신 필요한 칼럼만 조회하는 것을 권장하는 이유? 정렬 버퍼를 몇 배에서 몇십 배까지 비효율적으로 사용할 가능성이 큼 

#### 9.2.3.3 정렬 처리 방법
| 정렬 처리 방법 | 실행 계획의 Extra 칼럼 내용 |
|-------|--------|
| 인덱스를 사용한 정렬 | 별도 표기 없음 |
| 조인에서 드라이빙 테이블만 정렬 | "Using filesort" |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort" |

##### 9.2.3.3.1 인덱스를 이용한 정렬
- ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY 순서대로 생성된 인덱스가 있어야 함
- WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 함
- B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스, R-Tree 등에서는 인덱스를 이용한 정렬을 사용할 수 없음
- 별도의 정렬을 위한 추가 작업을 수행하지 않음
- 정렬을 인덱스로 처리할 수 있는 경우 부가적으로 불필요한 정렬 작업을 수행하지 않음 -> ORDER BY 절을 명시해두면 성능상의 손해가 없음은 물론이고 명시되지 않았을 경우 버그로 연결되지 않음

##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
- 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성해야 함
- ORDER BY 절에 명시된 칼럼이 프라이머리 키와 연관이 없지만 드라이빙 테이블에 포함된 칼럼이라면 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고, 그 결과와 salaries 테이블을 조인

##### 9.2.3.3.3 임시 테이블을 이용한 정렬
- 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있음
- 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거침
- 3가지 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 떄문에 가장 느린 방법

##### 9.2.3.3.4 정렬 처리 방법의 성능 비교
- ORDER BY나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서는 처리 불가
- 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 비로소 LIMIT으로 건수 제한 가능
- WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우 자주 발생

###### 9.2.3.3.4.1 스트리밍 방식
- 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
- 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받음
- 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간 보장
- LIMIT처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있음
- LIMIT 조건을 추가하면 전체적으로 가져오는 레코드 건수가 줄어들기 때문에 마지막 레코드를 가져오기까지의 시간을 상당히 줄일 수 있음

###### 9.2.3.3.4.2 버퍼링 방식
- ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 함
- MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도 느려짐
- LIMIT처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않음
- 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리, 나머지는 모두 버퍼링된 후에 정렬됨
참고) JDBC의 버퍼링 처리 방식은 기본 작동 방식이며, 아주 대량의 데이터를 가져와야 할 때는 MySQL 서버와 JDBC 간의 전송 방식을 스트리밍 방식으로 변경 가능
-> JDBC 라이브러리가 자체적으로 레코드를 버퍼링하는 이유는 이 방식이 전체 처리 시간이 짧고 MySQL 서버와의 통신 횟수가 적어 자원 소모가 줄어들기 때문

#### 9.2.3.4 정렬 관련 상태 변수
- 처리하는 주요 작업에 대해서는 해당 작업의 실행횟수를 상대 변수로 저장
- 정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업(멀티 머지)은 볓 번이나 발생했는지 등을 확인 가능
  - `SHOW STATUS LIKE 'Sort%'`

### 9.2.4 GROUP BY 처리
- 스트리밍된 처리를 할 수 없게 하는 처리 중 하나
- GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요 없음
- 인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔으로 나뉨
- 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블 사용

#### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼ㄹ머으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리
- GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹 함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있음
- 이러한 그루핑 방식을 사용하는 실행 계획에서는 Extra 칼럼에 별도로 GROUP BY 관련 코멘트나 임시 테이블 사용 또는 정렬 관련 코멘트가 표시되지 않음

#### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
- 옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 Extra 칼럼에 "Using index for group-by" 코멘트가 표시됨
- 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용 가능
- 프리픽스 인덱스는 루스 인덱스 스캔 사용 불가
- 인덱스의 유니크한 값의 수가 적을수록 성능이 향상됨 -> 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만듦
- 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴
  - MIN(), MAX() 이외의 집합 함수가 사용됐을 경우
  - SELECT 절의 칼럼이 GROUP BY와 일치하지 않는 경우
  - GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않는 경우

#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY
- GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때 처리되는 방식
- MySQL 8.0 버전부터는 GROUP BY가 사용된 쿼리의 그루핑되는 칼럼을 기준으로 실행되었던 묵시적인 정렬이 더 이상 실행되지 않음 -> 이전 버전에서는 `ORDER BY NULL` 구문으로 불필요한 추가 정렬 작업 수행 안함
- MySQL 8.0에서는 GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행

### 9.2.5 DISTINCT 처리
- 특정 칼럼의 유니크한 값만 조회하려면 SELECT 쿼리에 DISTINCT 사용
- 집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블 필요
- 하지만 실행 계획의 Extra 칼럼에는 "Using temporary" 메시지 출력 안됨

#### 9.2.5.1 SELECT DISTINCT ...
- 단순히 SELCET되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용
- 이 경우에는 GROUP BY와 동일한 방식으로 처리됨
- DISTINCT는 SELECT하는 레코드를 유니크하게 SELECT하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아님 -> 모든 칼럼에 영향을 미침

#### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT
- 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져옴
`SELECT COUNT(DISTINCT s.salary) FROM employees e, salaries s` -> 내부적으로 COUNT(DISTINCT s.salary)를 처리하기 위해 임시 테이블 사용
`SELECT COUNT(DISTINCT s.salary), COUNT(DISTINCT e.last_name) ...` -> 2개의 임시 테이블 사용
- 인덱스된 칼럼에 대해 DISTINCT 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리 수행 가능

### 9.2.6 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블 사용
- 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨짐
- MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능

#### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블
- MySQL 8.0 이전 버전까지는 원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 이용
- MySQL 8.0 버전부터는 메모리는 TempTable이라는 스토리지 엔진을 사용하고 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선됨
- 기존 MEMORY 스토리지 엔진은 VARBINARY나 VARCHAR 같은 가변 길이 타입을 지원하지 못하기 때문에 임시 테이블이 메모리에 만들어지면 가변 길이 타입의 경우 최대 길이만큼 메모리를 할당해서 사용
- 디스크에 임시 테이블이 만들어질 때 사용되는 MyISAM 스토리지 엔진은 트랜잭션을 지원하지 못한다는 문제점 있음
- TempTable이 최대 사용 가능한 메모리 공간의 크기는 temptable_max_ram 시스템 변수로 제러 가능하고, 기본값은 1GB로 설정됨
- 임시 테이블의 크기가 1GB보다 커지는 경우 MySQL 서버는 메모리의 임시 테이블을 디스크로 기록하게 됨
  - TempTable 스토리지 엔진의 MMAP 파일 버전으로 디스크에 기록
    - 기본값
    - 메모리의 TempTable을 MMAP 파일로 전환하는 것은 InnoDB 테이블로 전환하는 것보다 오버헤드가 적음
  - InnoDB 테이블로 기록
- MySQL 서버는 디스크의 임시 테이블을 생성할 때, 파일 오픈 후 즉시 파일 삭제를 실행, 데이터를 저장하기 위해 해당 임시 테이블 사용 -> MySQL 서버가 종료되거나 해당 쿼리가 종료되면 임시 테이블은 즉시 사라지게 보장

#### 9.2.6.2 임시 테이블이 필요한 쿼리
- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리 -> 유니크 인덱스를 가지는 내부 임시 테이블
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리 -> 유니크 인덱스를 가지는 내부 임시 테이블
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리 -> 유니크 인덱스를 가지는 내부 임시 테이블, "Using temporary" 표시 X
- UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT인 경우) -> 유니크 인덱스를 가지는 내부 임시 테이블, "Using temporary" 표시 X
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리 -> 유니크 인덱스가 없는 내부 임시 테이블, "Using temporary" 표시 X
- 일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 처리 성능이 상당히 느림
- MySQL 8.0 버전부터는 UNION ALL을 사용하는 쿼리는 더는 임시 테이블을 사용하지 않게 개선됨

#### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우
- UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512 바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 (MEMORY 스토리지 엔진에서) tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나(TempTable 스토리지 엔진에서) temptable_max_ram 시스템 변수 값보다 큰 경우
- MySQL 8.0.13 버전부터는 BLOB이나 TEXT 칼럼을 가진 임시 테이블에 대해서도 메모리에 임시 테이블을 생성할 수 있게 개선됨

#### 9.2.6.4 임시 테이블 관련 상태 변수
- 임시 테이블이 디스크에 생성됐는지 메모리에 생성됐는지 확인하려면 MySQL 서버의 상태 변수를 확인
```
FLUSH STATUS; // 현재 세션의 상태 값 초기화
SHOW SESSION STATUS LIKE 'Created_tmp%';
```
- Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값
- Created_tmp_disk_tables: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값

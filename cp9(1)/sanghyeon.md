## 9.1 개요

### 9.1.1 쿼리 실행 절차

1. SQL 문장을 이해할 수 있는 수준으로 분리
    - SQL 파서 모듈을 통해 SQL 파싱 ⇒ SQL 파스 트리 생성
2. 파싱 정보를 통해 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
    - 불필요한 조건 제거 및 복잡한 연산의 단순화
    - 조인 시 읽을 테이블 순서 결정
    - 사용할 인덱스 결정
    - 가져온 레코드를 임시 테이블에 넣고 가공을 결정
3. 계획을 통해 스토리지 엔진으로부터 데이터를 가져옴
    - MySQL 엔진과 스토리지 엔진이 동시에 참여하여 처리

### 9.1.2 옵티마이저의 종류

옵티마이저는 DB 서버에서 두뇌와 같은 역할

규칙 기반 최적화 

- 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
- 통계 정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은  실행 방법을 만듦
- 사용자의 분포도가 다양하여 거의 사용되지 않음

비용 기반 최적화

- 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
- 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종 쿼리 실행
- 대부분의 옵티마이저가 사용

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔의 조건

- 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것이 더 느릴 경우(테이블이 페이지 1개로 구성된 경우)
- where이나 on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

InnoDB 스토리지 엔진

- 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작
- 리드 어헤드 : 필요해질 것으로 예상되는 데이터를 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
- 풀 테이블 스캔 시 포그라운드 스레드가 페이지 읽기를 실행하지만, 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘기고 한번에 읽는 페이지를 증가시킴(최대 64개까지 버퍼 풀에 저장)
- 풀 인덱스 스캔에서도 적용
- SELECT COUNT(*) from employees → 풀 인덱스 스캔을 함 → 단순 레코드 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄이기 때문 ⇒ 인덱스는 테이블의 2~3게 킬럼만으로 구성되기 떄문에 테이블 자체보다는 용량이 작음

### 9.2.2 병렬 처리

시스템 변수를 통해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경가능

병렬 처리용 스레드 개수를 아무리 늘려도, CPU의 코어 개수를 넘어서는 경우에는 성능이 떨어질 수 있음

### 9.2.3 ORDER BY 처리(USING FILESORT)

레코드 정렬

- 인덱스를 이용
    - 장점 : 이미 인덱스가 정렬되어 있음 → 매우 빠름
    - 단점 : 인덱스 추가/삭제가 느리며 더 많은 디스크 공간이 필요
- Filesort라는 별도의 처리를 이용하는 방법
    - 장점 : 정렬해야할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름
    - 단점 : 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다

모든 정렬을 인덱스를 이용하도록 튜닝하기엔 어려움

**9.2.3.1 소트버퍼**

정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하며, 해당 메모리 공간을 소트버퍼라고 함

쿼리의 실행 완료되면 반납

정렬해야할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면, 레코드를 여러 조각으로 나눠서 처리해야하며 임시 저장을 위해 디스크를 사용

멀티 머지

- 메모리의 소트 버퍼에서 정렬 수행 후 임시로 디스크에 기록
- 레코드를 가져와 해당 작업 반복

너무 큰 버퍼 사이즈를 사용하는 경우 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있음

소트 버퍼는 세션 메모리 영역에 해당하며 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아님

커넥션이 많을수록, 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미함

소트 버퍼의 크기를 10MB 이상으로 설정하면 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면서 운영체제는 메모리 부족 현상을 겪을 수 있음

**9.2.3.2 정렬 알고리즘**

레코드 전체를 소트 버퍼에 담을 것인가, 정렬 기준 칼럼만 소트 버퍼에 담을 것인가에 따라

싱글 패스 vs 투 패스

**9.2.3.2.1 싱글 패스 정렬 방식**

select 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식

정렬에 필요치 않은 칼럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행

**9.2.3.2 투 패스 정렬 방식**

정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select 할 칼럼을 가져오는 정렬 방식

처음 테이블을 읽을 때는 정렬에 필요한 칼럼과 프라이머리 키만 읽어서 정렬을 수행하고, 그 결과 순서대로 테이블을 한번 더 읽어서 데이터를 가져옴

투 패스는 두번 읽어야 함, 레코드의 크기나 건수가 많을 경우 효율적

싱글 패스는 더 많은 소트 공간이 필요, 레코드의 크기나 건수가 작은 경우 빠름 → 대부분 사용

**9.2.3.3 정렬 처리 방법**

order by 시 다음의 방법으로 정렬

- 인덱스 사용
- 조인에서 드라이빙 테이블(먼저 읽히는 테이블)만 정렬
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬

가장 먼저 인덱스 이용 가능 여부 확인 후 인덱스 순서대로 읽어서 결과를 반환

인덱스 사용 불가 시 where 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬하며 다음의 2가지 방법 중 선택

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

일반적으로 조인이 수행되면서 레코드 건수와 레코드의 크기는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 것이 효율적

**9.2.3.3.1 인덱스를 이용한 정렬**

인덱스를 이용한 정렬을 위해서는 order by에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고, order by 순서대로 생성된 인덱스가 있어야 함

where절의 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 order by는 같은 인덱스를 사용해야함

**9.2.3.3.2 조인의 드라이빙 테이블만 정렬**

조인 시 레코드의 건수와 레코드 하나하나의 크기가 계속 늘어나기 때문에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이 됨

해당 방법 처리 시, 조인에서 첫 번째로 읽히는 테이블의 칼럼만으로 order by 절을 작성해야 함

**9.2.3.3.3 임시 테이블을 이용한 정렬**

2개 이상의 테이블을 조인해서 결과를 정렬해야할 경우 임시 테이블이 필요

조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 → 3가지 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 떄문에 가장 느린 정렬 방법

ex)

order by 절의 정렬 기준이 드라이빙 테이블이 아니라 드리븐 테이블에 있는 칼럼일 경우 정렬이 수행되기 전에 테이블을 읽어야 하므로 조인된 데이터를 가지고 정렬할 수밖에 없음

이때 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리함

**9.2.3.3.4 정렬 처리 방법의 성능 비교**

**9.2.3.3.4.1 스트리밍 방식**

조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식

빠른 응답 시간을 보장하며 LIMIT 처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 줄여줌

**9.2.3.3.4.2 버퍼링 방식**

where 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보냄

전체 처리 시간이 작고, DB 서버와의 통신 횟수가 적어 자원 소모가 줄어듬

order by의 3가지 처리 방식 중 인덱스를 사용한 정렬 방식만 스트리밍의 형태이며 나머지는 모두 버퍼링

인덱스를 사용하지 못할 경우 모든 레코드를 읽어서 정렬한 후 limit 만큼 클라이언트로 전송 가능

인덱스 사용을 최우선으로 하며, 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것이 차선

**9.2.3.4 정렬 관련 상태 변수**

정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업은 몇 번이나 발생했는지 등을 명령을 통해 확인 가능

sort_merge_passes : 멀티 머지 처리 횟수

sort_range : 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수

sort_scan : 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수

sort_rows : 지금까지 정렬한 전체 레코드 건수

### 9.2.4 Group by 처리

GROUP BY 또한 ORDER BY와 같이 스트리밍 처리 할 수 없게하는 처리 중 하나

having 절은 group by 결과에 대해 필터링 역할을 수행하고, group by에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 having 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없음

group by 시 인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉘며, 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용

**9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)**

조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리

**9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY**

루스 인덱스 스캔은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미하며 인덱스의 유니크한 값의 수가 적고, 분포도가 좋지 않은 인덱스 일수록 빠른 결과를 냄

⇒ 특정키에 데이터가 몰려있을 경우 몰려있는 데이터를 건너뛰면서 읽으면 되기 떄문

아래와 같은 방식을 통해 인덱스 레인지 스캔 사용가능

group by의 조건인 컬럼과 where 조건 컬럼을 묶어서 인덱스를 차례대로 스캔하며 group by 조건의 첫 번째 유일한 값을 찾아냄.

찾아낸 값 중에서 where 조건에 걸린 값만 가져옴

**9.2.4.3 임시 테이블을 사용하는 GROUP BY**

group by의 기준 칼럼이 인덱스를 전혀 사용하지 못할 경우 임시 테이블을 사용

group by는 있지만, order by 절이 없는 쿼리에 대해서는 그루핑 칼럼으로 반환함(묵시적 정렬)

8.0 이후부터 GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행하고 조인된 결과를 한 건씩 가져와 임시 테이블에서 중복 체크와 함께 insert/update 실행 ⇒ 별도의 정렬 작업 없이 group by 처리

### 9.2.5 DISTINCT 처리

**9.2.5.1 SELECT DISTINCT …**

DISTINCT는 특정 칼럼의 유니크한 값을 조회할 떄 select 쿼리에 사용

주의할 것은 DISTINCT는 조회되는 모든 칼럼에 영향을 미치며 특정 컬럼만 유니크하게 조회하는 것이 아님

**9.2.5.2 집합 함수와 함께 사용된 DISTINCT**

count, max, min 같은 집합 함수 내에서 사용될 경우

- 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져옴
- 이때 집합 함수를 처리하기 위해 임시 테이블을 사용

### 9.2.6 내부 임시 테이블 활용

레코드를 정렬하거나 그루핑할 떄는 내부적인 임시 테이블을 사용

내부적인 임시 테이블은 명령어를 통해 만든 임시 테이블과 다름

명령어를 통한 임시 테이블은 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨짐

반면 내부 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하며 쿼리의 처리가 완료되면 자동으로 삭제됨

**9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블**

디스크에 임시 테이블이 만들어질 때 memory 스토리지 엔진은 트랜잭션을 지원하지 못하기 때문에 TempTable 스토리지 엔진이 도입됐으며, MyISAM 스토리지 엔진을 대신해서 트랜잭션 지원 가능한 InnoDB 스토리지 엔진이 사용되로고 개선됨

메모리용 임시 테이블을 TempTable과 MEMORY 중 선택 가능

서버가 MMAP파일로 기록할지 InnoDB 테이블로 전환할지는 시스템 변수로 설정 가능하며 메모리의 TempTable 크기가 1GB를 넘으면 서버는 메모리의 TempTable을 MMAP 파일로 전환

**9.2.6.2 임시 테이블이 필요한 쿼리**

다음의 경우 엔진에서 별도의 데이터 가공 작업을 필요로 하므로 내부 임시 테이블을 생성함

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION 쿼리
- 실행계획에서 select_type이 DERIVED인 쿼리

**9.2.6.3 임시 테이블이 디스크에 생성되는 경우**

다음과 같은 조건을 만족하면 메모리 임시 테이블을 사용할 수 없음

- union이나 union all 에서 select 되는 칼럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있는 경우
- group by 나 distince 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 temptable_max_ram 시스템 변수 값보다 큰 경우

**9.2.6.4 임시 테이블 관련 상태 변수**

다음의 방법을 통해 임시 테이블이 메모리에서 처리됐는지, 디스크에서 처리됐는지, 몇 개의 임시 테이블이 사용됐는지 알 수 있음

- flush status 명령을 실행해 현재 세션의 상태 값을 초기화
- select 쿼리 실행 후 상태 조회 명령을 실행

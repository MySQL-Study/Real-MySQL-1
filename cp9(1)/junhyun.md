# 개요
## 쿼리 실행 절차
쿼리 실행 과정
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리) 한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

1단계: sql파싱, sql파서가 처리. 문법적 오류 걸러짐. `sql 파스 트리`가 만들어짐. 파스 트리 이용해 쿼리 실행함.  

2단계: 파스 트리 참조  
- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

`최적화 및 실행 계획 수립` 단계이다. `옵티마이저`에처 처리.
두번째 단계가 완료되면 실행 계획이 만들어짐.

3단계: 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청, mysql엔진은 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행.  
1,2->mysql엔진, 3->스토리지 엔진+mysql엔진  

## 옵티마이저의 종류
요즘 비용 기반 최적화 많이 사용. (예전 규칙 기반 최적화)  
비용 기반 최적화: 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출 후 실행 방법별로 비용이 최소로 소요되는 처리방식  

# 기본 데이터 처리
## 풀 테이블 스캔과 풀 인덱스 스캔
풀 테이블 스캔: 인덱스 사용 안하고 테이블이 처음부터 끝까지 읽어 작업 처리.   
- 테이블 레코드 건수가 너무 작아 인덱스보다 풀 테이블 스켄이 빠른 경우
- where 절이나 on절에 인덱스를 이용할 수 있ㄴ느 적절한 조건이 없는 경우
- 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

mysql에는 풀테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수 없음.  
innodb는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 read ahead 작업이 자동으로 시작됨.  
read ahead: 미리 디스크에서 읽어 innodb 버퍼 풀에 캐시해두는 작업.  
풀 테이블 스캔 실행 -> 처음 몇 개 데이터 페이지는 Foreground thread가 페이지 읽기를 실행.  
특정 시점 -> 읽기 작업을 백그라운드 스레드로 넘김. 이때부터 한번에 4개 또는 8개씩의 페이지를 읽으며 그 수를 증가시킴.  
이때 한번에 최대 64개의 데이터 페이지까지 읽어 버퍼풀에 저장함.  
포그라운드 스레드는 버퍼풀의 데이터만 가져다 사용하면 되므로 쿼리 빨리 처리됨.  

innodb_read_ahead_threshold 설정해 이만큼 연속된 페이지가 읽히면 innodb가 백그라운드 스레드를 이용해 대량으로 그다음 페이지들 버퍼에 적재.  
디폴트도 좋고, 조금 더 낮게도 좋고.  
read ahead는 풀테이블, 풀인덱스 스캔 모두 사용됨.  

풀인덱스 스캔  
select count(*) from 테이블; 과 같이 단순히 레코드 건수만 필요로 하는 쿼리면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 줄일 수 있음.  
그래서 이건 풀테이블 스캔 안 하고 풀 인덱스 스캔 할 가능성 높음.  

## 병렬 처리
where 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능.  
```mysql
set session innodb_parallel_read_threads=4;
select count(*) from 테이블;
```

## ORDER BY 처리(Using filesort)
정렬: 인덱스 이용 || `Filesort`(별도의 처리)  
- 인덱스 이용  
  - (장점) insert, update, delete 시 이미 인덱스가 정렬돼 잇어 순서대로 읽기만 해 빠름.
  - (단점) insert, update, delete 시 부가적인 인덱스 추가, 삭제 작업이 필요해 느림. 인덱스 때문에 디스크 공간 많이 필요, 인덱스 늘어날수록 innodb버퍼풀을 위한 메모리가 많이 필요.  
- Filesort
  - (장점) 인덱스 생성 안 하기 때문에 단점이 장점.
  - (장점) 정렬할 레코드 많지 않으면 충분히 빠름
  - (단점) 정렬 작업이 쿼리 실행 시 처리되므로 레코드 건수 많으면 느려짐.

실행계획의 Extra칼럼에 Using filesort가 있으면 Filesort 사용.  

### 소트 버퍼
소트 버퍼: 정렬을 위해 할당된 별도의 메모리 공간.(정렬이 필요할때만 할당됨. 쿼리 실행 완료되면 즉시 반납.)  
**레코드 많이 소트 버퍼보다 크면?**
정렬할 레코드를 여러 조각으로 나눠 처리, 이때 임시 저장을 위해 디스크를 사용.  
메모리의 소트 버퍼에서 정렬 수행 -> 그 결과 임시로 디스크에 기록 -> 다음 레코드 가져와 정렬 후 디스크에 임시 저장  
다시 레코드 병합하며 정렬 수행. = 멀티머지  
소트버퍼 키워도 크게 성능차이 없음.  
커넥션 많으면 세션 메모리 영역인 소트 버퍼로 소비되는 공간 커짐. (또는 정렬 작업이 많으면)

### 정렬 알고리즘
3가지 정렬 방식
- <sort_key, rowid> :(투패스) 정렬키와 레코드의 로우 아이디만 가져와 정렬
- <sort_key, additional_fields> :(싱글패스) 정렬키와 레코드 전체를 가져와 정렬, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
- <sort_key, packed_additional_fields> : 정렬키와 레코드 전체를 가져와 정렬, 레코드의 칼럼들은 가변 사이즈로 메모리 저장.

**싱글 패스 정렬 방식**  
소트 버퍼에 정렬 기준 칼럼을 포함해 select 대상이 되는 칼럼 전부를 담아 정렬을 수행하는 방식.  

**투 패스 정렬 방식**
정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어 select할 칼럼을 가져오는 방식.  

싱글 패스가 더 많은 소트 버퍼 공간 필요. 싱글패스만 항상 사용되는 건 아님.  

### 정렬 처리 방법
ORDER BY있으면
- 인덱스를 사용한 정렬
  - 실행계획의 Extra에 별도 표기 없음
- 조인에서 드라이빙 테이블만 정렬
    - "Using filesort"
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
    - "Using temporary; Using filesort"

먼저 인덱스 사용할 수 있는지 확인. -> 인덱스 사용 불가능하면 where조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하며 정렬을 처리(filesort)  
정렬 대상 레코드 최소화를 위해
- 조인의 드라이빙 테이블만 정렬한 다음 조인 수행(이게 효율적)
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

**인덱스를 사용한 정렬**

**조인의 드라이빙 테이블만 정렬**
조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것  
첫번째로 읽히는 테이블(드라이빙 테이블)칼럼으로만 order by 작성  

**임시 테이블을 이용한 정렬**
조인 결과를 임시 테이블에 저장한 후 정렬을 수행하는 방식.  
느림.  

**정렬 처리 방법의 성능 비교**
웹 서비스용 쿼리에서는 order by와 limit이 거의 필수로 함께 사용됨.  
그런데 order by, group by 에서는 where 만족하는 만큼 limit 못 가져옴. 조건 만족하는 거 모두 가져와 정렬, 그룹핑 해야 limit 적용 가능.  

쿼리 처리 2가지 방법  
**스트리밍 방식**
조건에 맞는 거 찾을 때마다 클라이언트로 전송  
limit 도움됨.
**버퍼링 방식**
order by, group by는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 함.  
조건에 맞는 레코드를 모두 가져와서 정렬, 그룹핑 후 클라이언트로 전송.  
여기에서는 limit 도움 안 됨.

인덱스를 사용한 정렬만 스트리밍이고 나머진 버퍼링  
즉 인덱스 사용한 정렬에서 limit 도움 될 수 도.  

인덱스 활용하고, 안 되면 드라이빙 테이블만 정렬

### 정렬 관련 상태 변수 

## GROUP BY 처리
Having절은 group by결과에 대해 필터링 역할 수행  
- 인덱스 사용 
  - 인덱스 스캔
  - 루스 인덱스 스캔
- 인덱스 사용 불가
  - 임시테이블 사용

### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때
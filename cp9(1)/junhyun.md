# 개요
## 쿼리 실행 절차
쿼리 실행 과정
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리) 한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

1단계: sql파싱, sql파서가 처리. 문법적 오류 걸러짐. `sql 파스 트리`가 만들어짐. 파스 트리 이용해 쿼리 실행함.  

2단계: 파스 트리 참조  
- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

`최적화 및 실행 계획 수립` 단계이다. `옵티마이저`에처 처리.
두번째 단계가 완료되면 실행 계획이 만들어짐.

3단계: 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청, mysql엔진은 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행.  
1,2->mysql엔진, 3->스토리지 엔진+mysql엔진  

## 옵티마이저의 종류
요즘 비용 기반 최적화 많이 사용. (예전 규칙 기반 최적화)  
비용 기반 최적화: 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출 후 실행 방법별로 비용이 최소로 소요되는 처리방식  

# 기본 데이터 처리
## 풀 테이블 스캔과 풀 인덱스 스캔
풀 테이블 스캔: 인덱스 사용 안하고 테이블이 처음부터 끝까지 읽어 작업 처리.   
- 테이블 레코드 건수가 너무 작아 인덱스보다 풀 테이블 스켄이 빠른 경우
- where 절이나 on절에 인덱스를 이용할 수 있ㄴ느 적절한 조건이 없는 경우
- 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

mysql에는 풀테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수 없음.  
innodb는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 read ahead 작업이 자동으로 시작됨.  
read ahead: 미리 디스크에서 읽어 innodb 버퍼 풀에 캐시해두는 작업.  
풀 테이블 스캔 실행 -> 처음 몇 개 데이터 페이지는 Foreground thread가 페이지 읽기를 실행.  
특정 시점 -> 읽기 작업을 백그라운드 스레드로 넘김. 이때부터 한번에 4개 또는 8개씩의 페이지를 읽으며 그 수를 증가시킴.  
이때 한번에 최대 64개의 데이터 페이지까지 읽어 버퍼풀에 저장함.  
포그라운드 스레드는 버퍼풀의 데이터만 가져다 사용하면 되므로 쿼리 빨리 처리됨.  

innodb_read_ahead_threshold 설정해 이만큼 연속된 페이지가 읽히면 innodb가 백그라운드 스레드를 이용해 대량으로 그다음 페이지들 버퍼에 적재.  
디폴트도 좋고, 조금 더 낮게도 좋고.  
read ahead는 풀테이블, 풀인덱스 스캔 모두 사용됨.  

풀인덱스 스캔  
select count(*) from 테이블; 과 같이 단순히 레코드 건수만 필요로 하는 쿼리면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 줄일 수 있음.  
그래서 이건 풀테이블 스캔 안 하고 풀 인덱스 스캔 할 가능성 높음.  

## 병렬 처리
where 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능.  
```mysql
set session innodb_parallel_read_threads=4;
select count(*) from 테이블;
```

## ORDER BY 처리(Using filesort)
정렬: 인덱스 이용 || `Filesort`(별도의 처리)  
- 인덱스 이용  
  - (장점) insert, update, delete 시 이미 인덱스가 정렬돼 잇어 순서대로 읽기만 해 빠름.
  - (단점) insert, update, delete 시 부가적인 인덱스 추가, 삭제 작업이 필요해 느림. 인덱스 때문에 디스크 공간 많이 필요, 인덱스 늘어날수록 innodb버퍼풀을 위한 메모리가 많이 필요.  
- Filesort
  - (장점) 인덱스 생성 안 하기 때문에 단점이 장점.
  - (장점) 정렬할 레코드 많지 않으면 충분히 빠름
  - (단점) 정렬 작업이 쿼리 실행 시 처리되므로 레코드 건수 많으면 느려짐.

실행계획의 Extra칼럼에 Using filesort가 있으면 Filesort 사용.  

### 소트 버퍼
소트 버퍼: 정렬을 위해 할당된 별도의 메모리 공간.(정렬이 필요할때만 할당됨. 쿼리 실행 완료되면 즉시 반납.)  
**레코드 많이 소트 버퍼보다 크면?**
정렬할 레코드를 여러 조각으로 나눠 처리, 이때 임시 저장을 위해 디스크를 사용.  
메모리의 소트 버퍼에서 정렬 수행 -> 그 결과 임시로 디스크에 기록 -> 다음 레코드 가져와 정렬 후 디스크에 임시 저장  
다시 레코드 병합하며 정렬 수행. = 멀티머지  
소트버퍼 키워도 크게 성능차이 없음.  
커넥션 많으면 세션 메모리 영역인 소트 버퍼로 소비되는 공간 커짐. (또는 정렬 작업이 많으면)

### 정렬 알고리즘
3가지 정렬 방식
- <sort_key, rowid> :(투패스) 정렬키와 레코드의 로우 아이디만 가져와 정렬
- <sort_key, additional_fields> :(싱글패스) 정렬키와 레코드 전체를 가져와 정렬, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
- <sort_key, packed_additional_fields> : 정렬키와 레코드 전체를 가져와 정렬, 레코드의 칼럼들은 가변 사이즈로 메모리 저장.

**싱글 패스 정렬 방식**  
소트 버퍼에 정렬 기준 칼럼을 포함해 select 대상이 되는 칼럼 전부를 담아 정렬을 수행하는 방식.  

**투 패스 정렬 방식**
정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어 select할 칼럼을 가져오는 방식.  

싱글 패스가 더 많은 소트 버퍼 공간 필요. 싱글패스만 항상 사용되는 건 아님.  

### 정렬 처리 방법
ORDER BY있으면
- 인덱스를 사용한 정렬
  - 실행계획의 Extra에 별도 표기 없음
- 조인에서 드라이빙 테이블만 정렬
    - "Using filesort"
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
    - "Using temporary; Using filesort"

먼저 인덱스 사용할 수 있는지 확인. -> 인덱스 사용 불가능하면 where조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하며 정렬을 처리(filesort)  
정렬 대상 레코드 최소화를 위해
- 조인의 드라이빙 테이블만 정렬한 다음 조인 수행(이게 효율적)
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

**인덱스를 사용한 정렬**

**조인의 드라이빙 테이블만 정렬**
조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것  
첫번째로 읽히는 테이블(드라이빙 테이블)칼럼으로만 order by 작성  

**임시 테이블을 이용한 정렬**
조인 결과를 임시 테이블에 저장한 후 정렬을 수행하는 방식.  
느림.  

**정렬 처리 방법의 성능 비교**
웹 서비스용 쿼리에서는 order by와 limit이 거의 필수로 함께 사용됨.  
그런데 order by, group by 에서는 where 만족하는 만큼 limit 못 가져옴. 조건 만족하는 거 모두 가져와 정렬, 그룹핑 해야 limit 적용 가능.  

쿼리 처리 2가지 방법  
**스트리밍 방식**
조건에 맞는 거 찾을 때마다 클라이언트로 전송  
limit 도움됨.
**버퍼링 방식**
order by, group by는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 함.  
조건에 맞는 레코드를 모두 가져와서 정렬, 그룹핑 후 클라이언트로 전송.  
여기에서는 limit 도움 안 됨.

인덱스를 사용한 정렬만 스트리밍이고 나머진 버퍼링  
즉 인덱스 사용한 정렬에서 limit 도움 될 수 도.  

인덱스 활용하고, 안 되면 드라이빙 테이블만 정렬

### 정렬 관련 상태 변수 

## GROUP BY 처리
Having절은 group by결과에 대해 필터링 역할 수행  
- 인덱스 사용 
  - 인덱스 스캔
  - 루스 인덱스 스캔
- 인덱스 사용 불가
  - 임시테이블 사용

### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 group by 칼럼에 인덱스 있다면 그 인덱스를 차례로 읽어 그루핑 수행하고 결과로 조인 처리.  
이때도 그룹 함수 등 그룹값을 처리해야 해 임시 테이블이 필요.  
이 그루핑 방식은 Extra칼럼에 별도의 코멘트 표시 없음.  

### 루스(Loose) 인덱스 스캔을 이용하는 GROUP BY
인덱스 레코드를 건너뛰어 필요한 부분만 읽는 것.  
Extra에 Using index for group-by 표시됨.  
gourp by에 표시된 칼럼의 유일한 그룹키 찾고, 거기에서 where 조건에 걸린 값만 가져옴. 이게 그냥 (그룹바이컬럼, 조건컬럼) 인덱스를 검색하는 것과 유사.  
단일 테이블에서 처리되는 경우에만 사용 가능  
프리픽스 인덱스는 사용 불가능  
유니크한 그룹키가 적을수록 성능 향상  
임시 테이블 필요 없음  

사용할 수 없는 경우  
- min, max 이외의 집합 함수가 사용됨.
- group by에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치하지 않음.
- select 절의 칼럼이 group by와 일치하지 않기 때문

### 임시 테이블을 사용하는 group by
인덱스를 전혀 사용할 수 없을 때 사용  
using temporary 표시됨. 묵시적 정렬 안 되어 file sort 없음.  
8.0 이후부터는 내부적으로 group by절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어 중복 제거, 집합 함수 연산 수행 후 조인된 결과를 한 건씩 가져와 임시 테이블에서 중복 체크와 함께 insert/update 실행.  
order by와 같이 사용되면 명시적 정렬 작업 실행  

## DISTINCT 처리 
- 집합 함수와 사용 (이때 인덱스 사용하지 못 할 때 임시테이블 필요한데 using temporary 안 나옴)
- 없이 사용  

두개의 distinct 영향 범위 달라짐.  

### SELECT DISTINCT ...
select 되는 레코드 중에서 유니크한 레코드만 가져오고자 한다면 select distinct 형태의 쿼리문을 사용한다.  
group by와 동일한 방식으로 처리된다.  
select distinct first, last form table;  
(first, last) 조합이 유니크한 것을 가져옴.  
distinct 뒤에 괄호는 의미 없음.  

### 집합 함수와 함꼐 사용된 DISTINCT
집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져옴.  
select count(distinct emp_no) from table;  

## 내부 임시 테이블 활용
mysql엔진이 받은 레코드를 정렬하거나 그루핑할 때 내부적인 임시 테이블을 사용.  
쿼리 처리가 완료되면 삭제됨.  

### 메모리 임시 테이블과 디스크 임시 테이블  
메모리: TempTable(가변 길이 타입 지원)  
디스크: innodb(트렌젝션 지원 가능)  
temptable_max_ram 넘으면(기본 1GB) 디스크로 기록됨. 이때 두가지 저장 방식.  
- MMAP파일로 디스크에 기록
- innoDB 테이블로 기록

기본은 temptable_use_mmap이 on -> MMAP  
오버헤드가 적기 때문. 디스크에 생성되는 임시 테이블은 tmpdir에 정의된 디렉터리에 저장.  
처음부터 디스크에 저장되는 경우는 기본이 innoDB(internal_tmp_disk_storage_engine)  

### 임시 테이블이 필요한 쿼리
- order by, group by 에 명시된 칼럼이 다른 쿼리
- order by나 group by에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- distinct와 order by가 동시에 쿼리에 존재하는 경우 또는 distinct 가 인덱스로 처리되지 못하는 쿼리
- union 이나 union distinct 가 사용된 쿼리(select_type 컬럼이 union result인 경우)
- 쿼리의 실행 계획에서 select_type이 derived인 쿼리 (유니크 인데스가 없는 내부 임시 테이블이 생성되어 성능 느림)

마지막 3개는 using temporary 표시 안 됨.  

### 임시 테이블이 디스크에 생성되는 경우
- union이나 union all 에서 select 되는 칼럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있는 경우
- group by 나 distinct 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 temptable_max_ram(TempTable) 시스템 변수 값보다 큰 경우.

### 임시 테이블 관련 상태 변수
임시테이블이 디스크, 메모리에 생성됐는지 확인하려면  
show session status like 'created_tmp%';  
created_tmp_tables 전체 만들어진 임시테이블(디스크, 메모리 모두)  
created_tmp_disk_tables 디스크에 만들어진 임시테이블  

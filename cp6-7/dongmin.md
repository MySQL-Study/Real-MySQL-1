### 데이터 파일의 크기가 크면?

데이터 파일의 크기는 쿼리의 처리 성능과 백업 및 복구 시간과 밀접하게 연결

- 쿼리를 처리하기 위해 더 많은 데이터 페이지를 읽어야 하며, 새로운 페이지가 버퍼 풀로 적재되기 때문에 더티 페이지가 더 자주 디스크로 기록돼야 함
- 백업 및 복구 시간이 오래 걸림. ⇒ 비용 문제

### 페이지 압축

- MySQL 서버가 디스크에 저장하는 시점에 데이터 페이지가 압축되어 저장
- 디스크에서 데이터 페이지를 읽어올 때 압축 해제
    - InnoDB 스토리지 엔진은 압축이 해제된 상태로 데이터 페이지를 관리함
- 하나의 테이블은 동일한 크기의 페이지(블록)로 통일돼야 함
    - 페이지 압축 기능은 펀치 홀(Punch hole)이라는 기능을 사용함

1. 16KB 페이지를 압축 (압축 결과를 7KB로 가정)
2. MySQL 서버는 디스크에 압축된 결과 7KB를 기록

   (이때 MySQL 서버는 압축 데이터 7KB에 9KB의 빈 데이터를 기록)

3. 디스크에 데이터를 기록한 후, 7KB 이후의 공간 9KB에 대해 펀치 홀을 생성
4. 파일 시스템은 7KB만 남기고 나머지 디스크의 9KB 공간은 다시 운영체제로 반납

- 16KB 페이지에 대해 실제 디스크 공간의 7KB만 차지함
- 운영체제에서 16KB를 읽으면 압축된 데이터 7KB와 펀치 홀 공간인 9KB를 합쳐 16KB를 읽음

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd9eb0a2-9c82-43da-92ea-939474e849bb/91bd4d7b-6188-464c-a2f6-3fc3b8d1b86f/image.png)

- 펀치 홀 기능은 운영체제뿐 아니라 하드웨어 자체에서도 해당 기능을 지원해야 사용가능함.
- 파일 시스템 관련 명령어가 펀치 홀을 지원하지 못함.

### 테이블 압축

- 운영체제나 하드웨어에 대한 제약 없이 사용 가능
- 디스크의 데이터 파일 크기 줄일 수 있음
- 단점
    - 버퍼 풀 공간 활용률이 낮음
    - 쿼리 처리 성능이 낮음
    - 빈번한 데이터 변경 시 압축률이 떨어짐

1. 16KB의 데이터 페이지를 압축
    1. 압축된 결과가 8KB 이하이면 그대로 디스크에 저장(압축 완료)
    2. 압축된 결과가 8KB를 초과하면 원본 페이지를 split해서 2개의 페이지에 8KB씩 저장
2. 나뉜 페이지 각각에 대해 “1”번 단계를 반복 실행

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd9eb0a2-9c82-43da-92ea-939474e849bb/2172677b-9ab6-4eb6-b464-0c11b36f394c/image.png)

- 데이터 페이지의 압축 결과가 목표 크기보다 작거나 같을 때까지 반복해서 페이지를 split

### KEY_BLOCK_SIZE 결정

- 테이블 압축에서 가장 중요한 부분 !
    - 테이블 압축 적용 전 KEY_BLOCK_SIZE를 4KB 또는 8KB로 테이블을 생성해서 샘플 데이터를 저장해보고 적절한지 판단해보는 것이 좋음.
- 일반적으로 압축 실패율은 3 ~ 5% 미만으로 유지할 수 있게 설정하는 것이 좋음

### 압축된 페이지의 버퍼 풀 적재 및 사용

- InnoDB는 압궃된 테이블의 데이터 페이지를 버퍼 풀에 적재하면 압축된 상태와 압축이 해제된 상태 2개 버전 관리
- LRU 리스트: 디스크에서 읽은 상태 그대로의 데이터 페이지 목록을 관리
    - 압축이 적용되지 않은 테이블의 데이터 페이지
    - 압축이 적용된 테이블의 압축된 데이터 페이지
- Unzip_LRU: 압축된 페이지들의 압축 해제 버전
    - 압축을 해제한 상태의 데이터 페이지 목록

- 압축된 테이블에 대해서는 버퍼 풀의 공간을 이중으로 사용해 `메모리 낭비`
- 압축된 페이지에서 데이터를 읽거나 변경하기 위해서는 압축을 해제해야 하는데, 압축 및 해제 작업은 CPU를 많이 소모함.
    - Unzip_LRU 리스트를 별도로 관리

## 7. 데이터 암호화

### MySQL 서버의 데이터 암호화

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd9eb0a2-9c82-43da-92ea-939474e849bb/517c4277-7836-476b-92d8-ae3cd4920e42/image.png)

- MySQL 서버는 데이터베이스 서버와 디스크 사이의 데이터 읽기/쓰기 지점에서 암호화 또는 복호화를 수행-
    - InnoDB 스토리지 엔진의 I/O 레이어에서만 데이터 암호화 및 복호화 과정이 실행되는 방식
- 암호화된 테이블과 그렇지 않은 테이블은 동일한 쿼리 처리 과정을 거치며, 데이터베이스가 내부적으로 암호화를 처리하기 때문에 사용자는 일반적인 데이터베이스 작업처럼 사용할 수 있음
    - **TDE(Transparent Data Encryption, 투명한 데이터 암호화)** 방식

### 2단계 키 관리

TDE에서는 암호화 키가 **KeyRing 플러그인**에 의해 관리됨.

KeyRing 플러그인은 **2단계(2-Tier) 키 관리 방식**을 사용하며, 다음 두 가지 키를 통해 암호화를 수행

1. **마스터 키**
    - 모든 테이블스페이스 키를 보호(암호화)하는 데 사용됨
    - 외부 키 관리 솔루션 또는 디스크 파일에서 가져옴
    - 주기적으로 변경해야 하며, 변경 시 다음 명령어를 사용

        ```
        ALTER INSTANCE ROTATE INNODB MASTER KEY;
        ```

2. **테이블스페이스 키 (Private Key)**
    - 데이터 파일 암호화에 사용됨
    - 암호화된 테이블이 생성될 때마다 발급되며, 각 테이블의 데이터 파일 헤더에 저장
    - 테이블이 삭제되지 않는 이상 변경되지 않음

테이블스페이스 키는 AES-256(대칭키 암호화 알고리즘)을 사용하며, 마스터 키는 RSA-256(비대칭키 암호화 알고리즘)으로 관리

### 암호화와 성능

MySQL의 TDE 방식은 다음과 같은 성능 특성을 가짐

- **디스크에서 읽기**: 디스크에서 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재됨
    - 이후에는 암호화되지 않은 테이블과 동일한 성능을 보임
- **쿼리 지연**: InnoDB 버퍼 풀에 없는 데이터를 읽을 경우 복호화 과정을 거치므로 쿼리 처리 시간이 지연됨.
- **쓰기 지연**: 데이터 변경 시 테이블을 암호화한 후 디스크에 저장하므로 추가 시간이 발생
- **압축과 암호화**: 압축과 암호화가 동시에 적용될 경우, 압축 후 암호화를 수행하여 압축 효율을 높임

암호화된 테이블은 읽기 속도가 3~~5배, 쓰기 속도가 5~~6배 정도 느려질 수 있음

### 암호화와 복제

MySQL 서버의 복제 환경에서는 다음과 같은 암호화 방식을 따름

- **독립적인 키 관리**: 소스 서버와 레플리카 서버는 각자의 마스터 키와 테이블스페이스 키를 관리
    - 따라서 암호화된 데이터 파일은 서로 다른 값을 가짐
- **마스터 키 로테이션**: 소스와 레플리카 서버 모두 서로 다른 마스터 키를 새로 발급

    ```
    ALTER INSTANCE ROTATE INNODB MASTER KEY;
    ```

- **백업 시 주의사항**: 키링 파일을 백업하지 않으면 데이터를 복구할 수 없으므로, 반드시 마스터 키와 함께 백업해야 함

### keyring_file 플러그인 설치

`keyring_file` 플러그인은 테이블스페이스 키 암호화를 위해 마스터 키를 디스크 파일로 관리 TDE 플러그인은 가장 먼저 초기화되어야 하며, 초기화되지 않으면 데이터가 암호화되지 않은 상태로 저장될 수 있음

1. **MySQL 설정 파일 수정** (`my.cnf`):

    ```
    early-plugin-load = keyring_file.so
    keyring_file_data = /very/secure/directory/tde_master.key
    ```

2. **플러그인 초기화**: 서버를 재시작하여 초기화함

### 7.3 테이블 암호화

키링 플러그인은 마스터 키 생성과 관리만 담당하며, 테이블 암호화는 다음과 같이 수행

### 테이블 생성(TDE)

테이블 생성 시 `ENCRYPTION='Y'` 옵션을 추가

```
CREATE TABLE tab_encrypted (
    id INT,
    data VARCHAR(100),
    PRIMARY KEY (id)
) ENCRYPTION='Y';
```

모든 테이블에 암호화를 적용하려면 `default_table_encryption` 시스템 변수를 `ON`으로 설정

### 응용 프로그램 암호화와 비교

응용 프로그램 단에서 암호화를 수행하면 데이터베이스 작업에 제약이 생길 수 있음

- **제약 사항**: 암호화된 컬럼은 정렬, 범위 조회, 또는 인덱스를 제대로 활용할 수 없음
- **권장 사항**: 가능하다면 MySQL 서버 암호화를 사용하는 것이 효율적

### 테이블스페이스 이동

테이블 데이터를 다른 서버로 복사하거나 복구할 때, 테이블스페이스 이동 기능을 사용하면 효율적

1. 테이블스페이스 Export:

    ```
    FLUSH TABLES source_table FOR EXPORT;
    ```

2. 암호화된 테이블은 데이터 파일과 함께 임시 마스터 키가 저장된 `.cfp` 파일도 복사해야 함

### 언두 로그 및 리두 로그 암호화

MySQL 8.0.16부터는 InnoDB 스토리지 엔진의 언두 로그와 리두 로그도 암호화할 수 있음이를 위해 다음 시스템 변수를 사용

- **변수 설정**:

    ```
    SET GLOBAL innodb_undo_log_encrypt=ON;
    SET GLOBAL innodb_redo_log_encrypt=ON;
    ```

- **암호화 확인**:

    ```
    SHOW GLOBAL VARIABLES LIKE 'innodb_redo_log_encrypt';
    ```


암호화 설정 후에는 평문 데이터를 검색할 수 없음을 확인할 수 있음

### 바이너리 로그 암호화

바이너리 로그와 릴레이 로그 파일은 TDE 방식으로 암호화됨

### 키 관리

바이너리 로그 암호화는 2단계 키 관리 방식을 사용함

- **파일 키**: 로그 파일 데이터를 암호화
- **바이너리 로그 암호화 키**: 파일 키를 암호화하여 로그 파일 헤더에 저장

### 키 변경

바이너리 로그 암호화 키는 다음 명령으로 변경할 수 있음

```
ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

### mysqlbinlog 도구 활용

`mysqlbinlog`는 암호화된 바이너리 로그 파일을 읽고 해석하는 도구

- 외부에서 복호화는 불가능하며, 다음과 같이 사용함

```sql
mysqlbinlog --read-from-remote-server -uroot -p -vvv mysql-bin.000011
```
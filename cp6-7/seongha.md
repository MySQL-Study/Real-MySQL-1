# Chapter 6 데이터 압축

디스크에 저장된 데이터 파일의 크기는 쿼리 성능과도 직결되지만 백업 및 복구 시간과도 밀접하게 연관된다.
더 많은 페이지를 InnoDB 버퍼 풀로 읽어야하고, 더티 페이지가 더 자주 디스크로 기록되야한다. 

이러한 시간과 저장 공간 문제로 MySQL은 데이터 압축 기능을 제공한다. 


# 6.1 페이지 압축
페이지 압축은 "Transparent Page Compression"이라고도 불린다.
디스크에 저장하는 시점에 압축되어 저장하고, 불러올 때 압축이 해제되기 때문이다. 즉, 버퍼 풀에 데이터 페이지가 한 번 적재되면 InnoDB스토리지 엔진은 압축이 해제된 상태로만 데이터 페이지를 관리한다. 

그래서 MySQL 서버의 내부 코드에서는 압축과 관계없이 투명(Tranparent)하게 작동한다. 
여기서 한 가지 문제가 있는데 16KB 데이터 페이지를 압축한 결과가 용량이 얼마나 될지 예측이 불가능하다. 적어도 하나의 테이블은 동일한 페이지(블록)로 통일 되어야 한다. 

그래서 페이지 압축 기능은 펀치 홀(punch hole)이라는 기능을 사용한다. 
16KB를 압축한 결과가 7KB라면 디스크에 16KB(7KB 데이터 + 9KB 빈 데이터)를 기록하고, 실제로는 7KB를 기록한 뒤 나머지 공간(9KB의 펀치 홀을 생성하고 반납)은 운영 체제로 반납한다. 

![](https://velog.velcdn.com/images/pi1199/post/4904144a-07d6-4ee5-a907-b29242342bb9/image.png)

문제는 펀치 홀 기능은 운영체제뿐만 아니라 하드웨어 자체에서도 해당 기능을 지원해야 사용가능하다.
또한, 파일 시스템 관련 명령어가 펀치 홀을 지원하지 못하는 문제가 있다. 
그렇기에 잘 사용하지 않는다.

# 6.2 테이블 압축
테이블 압축은 운영체제나 하드웨어 제약 없이 사용가능하기 때문에 활용도가 더 높다. 

- 장점 
디스크의 데이터 파일 크기를 줄일 수 있다.

- 단점 
	- 버퍼 풀 공간 활용률이 낮다.
    - 쿼리 처리 성능이 낮다.
    - 빈번한 데이터 변경 시 압축률이 떨어진다.
    
이런 단점을 이해하기 위해서는 어떻게 압축되고 실행되는지 알아야 한다. 


## 6.2.1 압축 테이블 생성

테이블 압축을 사용하기 위한 전제 조건으로 압축을 사용하려는 테이블이 별도의 테이블 스페이스를 사용해야 한다. 

innodb_file_per_table 시스템 변수가 ON으로 설정된 상태로 테이블을 생성해야 하고, 테이블 압축을 사용하는 테이블은 ROW=COMPRESSED 옵션을 명시해야 한다. 
KEY_BLOCK_SIZE 옵션을 이용해 압축된 페이지의 목표 크기를 명시한다. 2 이상의 수 2n으로만 설정할 수 있고, 페이지 크기가 16KB라면 KEY_BLOCK_SIZE는 4, 8만 설정할 수 있다. 배수인 32, 64는 안된다. 


아래 그림은 페이지 압축의 작동 방식을 보여준다. 
압축된 결과가 목표 크기인 8KB보다 크면 split하여 다시 압축하는 식으로 진행된다. 
이 과정은 InnoDB 스토리지 엔진에서 실행되며, I/O 레이어는 관련이 없다. 
![](https://velog.velcdn.com/images/pi1199/post/45ab2d4d-73e5-48f4-b67a-b7258d3f760f/image.png)

## 6.2.2 KEY_BLOCK_SIZE 결정 
테이블 압축에서 가장 중요한 것은 압축된 결과가 어느 정도일지 예측하여 `KEY_BLOCK_SIZE`를 결정하는 것이다. 

테이블 압축을 적용하기전 KEY_BLOCK_SIZE를 다르게 설정하여 테이블을 생성하고, 샘플 제이터를 저장해 적절한 압축 크기를 찾아야 한다. 
KEY_BLOCK_SIZE는 4KB 또는 8KB로 설정하고, 최소한 데이터 페이지가 10개 정도 생성되도록 테스트 데이터를 생성하고 테스트 하자. 

p.190 페이지에서 더 자세히 알아보자 

일반적으로 압축 실패율은 3~5% 미만으로 유지하도록 KEY_BLOCK_SIZE를 선택하는 것이 좋다. 
그리고 압축 결과 데이터 크기가 비슷하다면 압축 실패율이 적은 방법을 선택하는 것이 더 효율적일 것이다.

INSERT만 되고 변경과 조희가 거의 없는 테이블(예:로그)의 경우 압축을 하는 것이 효율적이고, 데이터가 빈번히 조회 및 변경되는 테이블은 압축을 안하는 것이 좋다.
또한, 압축 알고리즘은 많은 CPU 자원을 소모한다는 것을 기억하자.

## 6.2.3 압축된 페이지의 버퍼 풀 적재 및 사용

InnoDB 스토리지 엔진은 압축된 테이블의 데이터 페이지를 버퍼 풀에 적재하면 압축된 상태와 압축 해제된 2개 버전을 관리한다. 
따라서 버퍼 풀에서 데이터 페이지를 관리하는 LRU 리스트도 별도로 2가지를 관리하게 된다. 
결국 2가지 버전을 관리하면서 버퍼 풀 공간을 이중으로 사용하여 메모리를 낭비하는 효과가 발생한다. 
또한 압축과 해제는 cpu자원을 많이 소모한다는 단점이 있다. 

이러한 단점을 보완하기 위해서 InnoDB는 어댑티브 알고리즘을 사용하여 데이터를 관리한다. 

1. 버퍼 풀 공간이 필요하면, Unzip_LRU 리스트의 데이터(압축해제)를 제거해 공간을 확보
2. 압축된 데이터 페이지가 자주 사용되면, Unzip_LRU 리스트에 압축 해제된 페이지를 계속 유지 -> 압축 및 압축 해제 작업 최소화
3. 압축된 데이터 페이지가 사용되지 않아 LRU 리스트에서 제거되면, Unzip_LRU 리스트에서도 함께 제거

압축 해제된 버전의 데이터 페이지를 적절하게 유지하기 위한 방법(알고리즘)
1. CPU 사용량이 높은 서버에서는 가능하면 압축 해제를 피하기 위해 Unzip_LRU의 비율을 높여 유지
2. Disk IO 사용량이 높은 서버에서는 가능하면 Unzip_LRU 리스트의 비율을 낮춰서 InnoDB 버퍼 풀의 공간을 더 확보

## 6.2.4 테이블 압축 관련 설정 


테이블 압축을 사용할 때 연관된 시스템 변수이다. 
모두 압축 실패율을 낮추기 위해 필요한 튜닝 포인트를 제공한다.

- innodb_cmp_per_index_enabled	
테이블 압축이 사용된 테이블의 모든 인덱스별로 압축 성공 및 압축 실행 횟수 수집
- innodb_compression_level	
zlib 알고리즘의 압축률을 설정하는 변수이다. 0~9의 범위를 갖고, 값이 작을수록 압축 속도는 빠르지만 저장 공간은 커진다. 기본값은 6이다. 
- innodb_compression_failure_threshold_pct
압축 실패율이 해당 값 보다 커지면 압축을 실행하기 전 원본 데이터 페이지 끝에 의도적으로 일정 크기의 빈공간을 추가한다. 이 빈공간은 압축률을 높여서 압축 결과가 KEY_BLOCK_SIZE보다 작어지게 만든다. 추가하는 빈 공간을 패딩이라고 한다.
- innodb_compression_pad_pct_max
패딩은 압축 실패율이 높아질수록 계족 증가하지만 해당 값 이상을 넘을 수 없다. 전체 데이터 페이지 크기 대비 패딩 공간의 비율을 의미한다. (%단위)
- innodb_log_pad_compressed_pages
압축된 페이지를 InnoDB 로그 파일에 기록할 때 패딩(padding)을 적용할지 여부를 관리하는 변수이다. 
압축된 페이지가 512바이트 단위로 맞춰져 있지 않으면, 비효율적인 디스크 쓰기 작업이 발생할 수 있다.
이 옵션을 활성화하면 압축된 데이터 크기가 512바이트의 배수가 되도록 패딩을 추가하여 디스크 I/O 성능을 개선한다. 리두 로그가 빠르게 증가하거나, 버퍼 풀에서 더티 페이지가 한꺼번에 많이 기록된다면 off하자.



# Chapter 7 데이터 암호화

응용 프로그램의 암호화는 주로 칼럼 단위로 수행, 데이터베이스 수준에서는 테이블 단위로 수행

# 7.1 MySQL 서버의 데이터 암호화


MySQL 서버의 암호화 기능은 서버와 디스크 사이의 데이터를 읽고 쓰는 지점에서 암호화 또는 복호화를 수행한다. 다른 부분에서 암호화는 전혀 쓰지 않는다. 
즉, MySQL 서버(InnoDB 스토리지 엔진)의 `I/O레이어 에서만 암호화 및 복호화` 과정이 진행된다. 
그렇기에 사용자는 암호화가 되어 있는지 여부에 관계없이 DB를 똑같이 이용할 수 있다.
이러한 암호화 방식을 TDE(Transparent Data Encryption)이라고 한다.

![](https://velog.velcdn.com/images/pi1199/post/e9b104da-e2c0-4889-a0d2-10623dd9268e/image.png)


## 7.1.1 2단계 키 관리

MySQL 서버의 TDE에서 암호화 키는 키링(KeyRing) 플러그인에 의해 관리된다. 
다양한 플러그인이 존재하지만 마스터 키를 관리하는 방법만 다를 뿐 MySQL 내부적으로 작동하는 방식은 동일하다. 
키링 플러그인은 2단계(2-Tier) 키 관리 방식을 사용한다. 

![](https://velog.velcdn.com/images/pi1199/post/60f7bd5d-17e1-4b1f-959b-070a51420cbb/image.png)

**데이터 암호화**는 마스터 키와 테이블스페이스키(private key)를 가지고 있다. 
외부 키 관리 솔루션 또는 디스크의 파일에서 마스터 키를 가져오고, 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스키를 발급한다. 
그리고 MySQL서버는 마스터키를 이용해 테이블스페이스키를 암호화해서 각 테이블의 데이터파일 헤더에 저장한다. 
테이블스페이스키는 외부에서 사용하지 않기에 노출되지 않기에 삭제하지 않는 이상 절대 변하지 않는다.
하지만, 마스터 키는 외부로 노출 될 수 있기 때문에 주기적으로 변경해야 한다. 
`ALTER INSTANCE ROTATE INNODB MASTER KEY;`

이렇게 마스터키를 변경하면 기존의 암호화를 사용할 수 없다. 따라서 마스터키를 변경할 때 각 테이블스페이스키를 복호화하고 다시 새로운 마스터키로 암호화하여 저장한다. 이 변경동안 테이블스페이스키와 데이터는 전혀 변경되지 않는다. 

이렇게 2단계 암호화를 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위함이다. 
(테이블스페이스키가 변경되면 데이터까지 모두 변경해야함)

## 7.1.2 암호화와 성능

MySQL의 암호화는 TDE 방식이므로 디스크로부터 한 번 읽은 데이터 페이지는 복호화 되어 InnoDB 버퍼 풀에 적재된다. 따라서 암호화가 없는 테이블과 동일한 성능이다. 

이 원리로 보면 암호화와 복호화에 사용되는 시간 때문에 쿼리 처리가 지연될 것으로 예상된다. 
하지만, **데이터 페이지 저장**은 사용자가 쿼리를 처리하는 스레드가 아니라 백그라운드 스레드가 수행한다. 따라서 사용자에게는 **쿼리 지연시간이 없다.**
그러나 **데이터 페이지 조회**(변경, 삭제, 조회)의 경우 InnoDB 버퍼 풀로 읽어와야 하기 때문에 복호화에 사용되는 시간으로 인해 **쿼리가 지연**된다. 

또한, AES 암호화 알고리즘을 사용하여 암호화 이전과 데이터 크기가 똑같다. 따라서, 버퍼풀이나 메모리 사용 효율이 떨어지지 않는다. 

같은 테이블에 암호화와 압축이 함께 적용된다면, **압축 -> 암호화 순**으로 진행된다.
1. 암호화된 결과문은 압축률이 떨어지는 문제가 있다.
2. 암호화가 먼저 실행된다면, InnoDB 버퍼 풀에 존재하는 데이터페이지에 대해서도 매번 암복호화 작업을 수행해야 된다. 

암호화된 테이블의 경우 읽기는 3~5배, 쓰기는 5~6배정도 느리다. 하지만 밀리초 단위라 크게 체감되진 않는다. 


## 7.1.3 암호화와 복제

소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 키를 관리한다. 
소스 서버의 마스터 키를 변경했다고 해서 마스터키 자체가 레플리카 서버로 전달되지 않는다. 

서버 백업에서 TDE의 키링(key ring)파일을 안하는 경우가 있는데, 이 키링 파일을 찾지 못하면 데이터를 복구할 수 없다. 따라서 키링 파일을 따로 백업한다면 언제 마스터키가 변경되었는지도 알아야 한다. 
이렇게 데이터와 키링을 별도로 백업하는 것을 권장한다. 하지만 복구를 생각하고 백업방식을 선택해야하고, 키링 파일의 백업도 고려해야 한다. 

# 7.2 플러그인 설치 

TDE의 암호화 키 관리는 플러그인 방식으로 제공된다. 
`keyring_file` 플러그인은 테이블스페이스 키를 암호화하기 위해 마스터 키를 디스크 파일로 관리한다. 평문으로 디스크에 저장되기에 노출에 주의가 필요하다. 

TDE 플러그인은 가장 빨리 초기화 되어야 한다. ~~TDE가 초기화되지 않으면, 새로운 데이터가 암호화되지 않고 저장될 수 있기 때문에~~

MySQL 서버의 설정 파일 (my.cnf) 에 `keyrig_file` 플러그인을 위한 라이브러리를 명시한다.
마스터 키를 저장할 파일 경로(keyring_file_data)도 설정한다. 
```
early-plugin-load = keyring_file.so
keyring_file_data = /very/secure/directory/tde_master.key
```

# 7.3 테이블 암호화 
키링 파일 플러그인은 마스터 키 생성/관리 까지만 담당하기 때문에 어떤 플러그인을 쓰더라도 테이블 생성 및 활용 방식은 동일하다.


## 7.3.1 테이블 생성
다음과 같이 `ENCRYPTION='Y'`만 추가하면 암호화를 적용할 수 있다. 
```sql
mysql> CREATE TABLE tab_encrypted (
		id INT,
        data VARCHAR(100),
        PRIMARY KEY(id)
	) ENCRYPTION='Y';
```
또한, `default_table_encryption` 시스템 변수를 ON으로 설정하여 모든 테이블에 적용할 수 있다.


## 7.3.2 응용 프로그램 암호화와의 비교

응용 프로그램에서 직접 암호화하여 저장하는 경우도 있다. 이 경우는 암호화 된 것인지 MySQL이 인지하지 못한다. 따라서 인덱스 기능을 100% 활용할 수 없다.

범위 조회나 정렬 등에 인덱스를 사용하기 위해서는 MySQL이 제공하는 암호화를 사용해야 한다.
-> 인덱스 관련 작업을 모두 처리하고 후에 암호화를 진행하기 때문에 인덱스 사용 가능 
둘중 선택해야 한다면 MySQL암호화를 선택하는게 좋다. 

## 7.3.3 테이블스페이스 이동 

테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면 테이블스페이스 이동(Export & Import)기능이 레코드를 덤프했다가 복구하는 방식보다 훨씬 빠르고 효율적이다.
```sql
mysql> FLUSH TABLES source_table FOR EXPORT;
```

복사하는 위치의 마스터키가 다르기 때문에 신경써야할 부분이 있다. 데이터 파일과 임시 마스터 키가 저장된 `*.cfp` 파일을 함께 복사하여 목적지 MySQL 서버로 전달해야 한다.

# 7.4 언두 로그 및 리두 로그 암호화

디스크에 저장할 때 암호화 및 복호화를 진행하기 때문에 MySQL서버 메모리에 존재하는 데이터는 평문으로 존재한다. 
MySQL 8.0.16 버전부터는 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있게 개선됐다. 
`innodb_undo_log_encrypt`, `innodb_redo_log_encrypt` 시스템 변수 이용

테이블은 전체 데이터가 암호화 되지만, 리두 언두 로그는 암호화가 설정된 시점의 데이터부터 암호화된다.(반대도 마찬가지)

리두 로그와 언두 로그를 위한 각각의 테이블스페이스키가 발급되고, 해당 테이블스페이스키는 마스터 키로 암호화되어 리두 로그 파일과 언두 로그 파일의 헤더에 저장된다. 


# 7.5 바이너리 로그 암호화 
바이너리 로그와 릴레이 로그 파일 또한 리두 로그나 언두 로그처럼 평문으로 저장한다.
바이너리 로그는 의도적으로 상당히 긴 시간 동안 보관하기 때문에 바이너리 로그 파일의 암호화는 상황에 따라 중요도가 높아질 수 있다.
바이너리 로그의 암호화는 주로 디스크에 저장된 로그 파일에 적용되며, 메모리 상에서는 암호화되지 않는다. 


## 7.5.1 바이너리 로그 암호화 키 관리

바이너리 로그와 릴레이 로그 파일 데이터의 암호화를 위해 2단계 암호화 키 관리 방식을 사용한다. 

바이너리 로그 파일 키로 로그 파일의 데이터를 암호화해서 디스크에 저장한다. 
파일 키는 바이너리 로그 암호화 키로 암호화해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장한다.

`바이너리 로그 암호화 키 = 마스터 키`, `파일키 = 테이블 스페이스 키` 각각 동일한 역할을 한다. 
파일키는 파일당 생성되며 해당 로그파일 암호화에만 생성된다. 

![](https://velog.velcdn.com/images/pi1199/post/b40aff07-9ca3-4a6e-acb3-fcf3620d1cbc/image.png)

### 7.5.2 바이너리 로그 암호화 키 변경 
바이너리 로그 암호화 키를 변경할 수 있다. 
```sql
ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```
마찬가지로 2단계 암호화를 사용하기에 파일키는 변경되지 않는다. 

### 7.5.3 mysqlbinlog 활용 

`mysqlbinlog` 도구는 MySQL 데이터베이스에서 바이너리 로그 파일을 읽고 해석하는 데 사용되는 유틸리티 도구이다. 
바이너리 로그 암호화 키는 해당 로그 파일을 생성한 MySQL 서버만 가지고 있기 때문에 바이너리 로그 파일을 외부에서 복호화가 불가능하다.
따라서 mysqlbinlog를 활용해서 MySQL 서버에 접속해 바이너리 로그를 가져오는 방법이 유일하다.
`linux> mysqlbinlog --read-from-remote-server -uroot -p -vvv mysql-bin.000011`


# Chapter6 - 데이터 압축

데이터를 왜 압축해야 하는가?

-   백업 및 복구 시간
-   더 많은 데이터를 메모리(버퍼 풀)에 유지할 수 있어서 디스크 I/O가 줄어든다.

## 6.1 페이지 압축

-   페이지를 압축할 때 중요한 것은 '테이블이 동일한 크기의 페이지로 통일되어야 한다'는 점이다.
-   동일한 크기의 페이지를 위해 '펀치 홀' 기능이 사용된다.
    -   16KB를 압축하여 7KB가 되었더라도, 빈 공간 9KB를 둠으로써 테이블 크기를 일관되게 유지하는 것 (실제로는 7KB의 물리적 공간, 파일의 논리적 크기는 16KB)
    -   결과적으로 애플리케이션 입장에서는 16KB를 읽은 것처럼 보인다.
-   그러나 아직 파일 시스템 관련 명령어가 펀치 홀을 지원하지 못한다는 단점으로 인해 페이지 압축은 많이 사용되지 않는 상태이다.

## 6.2 테이블 압축

-   조회 및 변경이 빈번한 테이블은 압축하지 않는 것이 좋다.
-   INSERT만 되는 로그 테이블처럼 변경이 없는 테이블은 압축하는 것이 좋다.
    <br><br>
-   InnodB 스토리지 엔진이 압축을 적용하는 방법 (KEY_BLOCK_SIZE옵션을 8로 설정한 경우)

    1.  16kb의 데이터 페이지를 압축
        1.  압축된 결과가 8KB 이하이면 그대로 디스크에 저장(압축 완료)
        2.  압축된 결과가 8KB를 초과하면 원본 페이지를 스플릿(split)해서 2개의 페이지에 8KB씩 저장
    2.  나뉜 페이지 각각에 대해 1번 단계를 반복 실행

-   압축된 페이지의 버퍼 풀 적재 및 사용
    -   버퍼 풀에서는 압축된 상태와 압축 해제 상태 두 가지를 관리한다.
        -   디스크에서 읽은 상태 그대로 데이터 페이지 목록을 관리하는 LRU 리스트
        -   압축된 페이지들의 압축 해제 버전인 Unzip_LRU 리스트
    -   즉, 압축된 테이블에 대해서는 버퍼 풀 공간을 이중으로 사용하는 낭비 발생
    -   압축된 페이지의 데이터를 읽거나 변경하려면 압축을 해제해야하는데, 이 과정에 CPU 소모크다.
    -   이를 위해 LRU 리스트에서 적절히 이 압축 테이블을 버퍼 풀에 넣거나 빼줌

# Chapter7 - 데이터 암호화

왜 암호화를 해야하는가?

-   핀테크 서비스처럼 중요한 정보를 저장하는 경우를 위해
-   중요한 정보인 경우라면 이중 암호화를 함
    -   이중 암호화: 응용 프로그램에서 한 번 암호화한 데이터를 DB 서버에서 다시 또 암호화
        -   DB 수준에서는 테이블 단위로 암호화
        -   응용 프로그램 수준에서는 컬럼 단위로 암호화

## 7.1 MySQL 서버의 데이터 암호화

-   DB 서버와 디스크 사이의 데이터를 읽고 쓰는 지점에서 암호화/복호화를 수행
    -   MySQL 내부와 사용자 입장에서는 굳이 암호화를 신경쓰지 않아도 됨.
    -   TDE(Transparent Data Encryption) 방식
    -   Data at Rest Encryption 방식

### 7.1.1 2단계 키 관리

-   마스터 키와 테이블 스페이스 키 두 단계로 키가 관리 됨.
-   마스터 키의 쓰임: 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키가 발급되는데, 이 키를 암호화하는 데에 사용됨.
-   테이블 스페이스 키는 MySQL 서버 외부 노출 X
    -   그러나 마스터 키는 노출 가능성. 그래서 키를 주기적으로 변경해야 한다.

### 7.1.2 암호화와 성능

-   암호화되면 암호를 풀어서 버퍼 풀에 적재하기 때문에 암호화되지 않았을 때보다 시간이 걸린다.
-   백그라운드에서 암호를 푼다.
-   메모리 효율이 떨어지는 건 아니다.

### 7.1.3 암호화와 복제

-   소스 서버와 레플리카 서버는 각자의 마스터 키와 테이블 스페이스 키를 관리한다. 이로 인해 서로 다른 키를 가지게 된다.
-   이로 인해 MySQL 서버에서 TDE Key Ring 파일을 백업하지 않으면 데이터를 복구할 수 없게 된다.

## 7.2 keyring_file 플러그인 설치

-   `keyring_file`: TDE 암호화 키 관리 플러그인. 마스터 키를 생성하고 관리하는 부분 담당
-   마스터 키가 저장된 파일이 외부에 노출되지 않도록 해야함
-   플러그인 설치법은 p202에 자세히 나와있음.

## 7.3 테이블 암호화

-   어떤 키링 플러그인을 사용하든 암호화된 테이블을 활용하는 방법은 동일
-   암호화된 테이블 생성 방법: `CREATE TABLE tab_encrypted ( ... ) ENCRYPTION='Y'` 맨 뒤에 `ENCRYPTION='Y'`만 붙여주면 됨
-   암호화된 테이블만 검색하고 싶을 땐 informatin_schema의 TABLES 뷰를 이용

### 7.3.2 응용 프로그램 암호화와의 비교

-   응용 프로그램에서 직접 암호화해서 MySQL 서버에 저장하는 경우
-   이런 경우는 인덱스를 생성하더라도 인덱스 기능을 100% 활용할 순 없다. MySQL 입장에선 이게 이미 암호화됐다는 사실을 모르기 때문
-   만약 birth를 암호화해서 저장했다면, birth 기준 상위 10개 가져오기 등의 범위 쿼리 사용이 어렵다.
-   MySQL 서버의 TDE를 사용하면 이러한 문제가 발생하지 않는다.
-   응용 프로그램 암호화 말고 MySQL의 TDE를 쓰자.

### 7.3.3 테이블스페이스 이동

-   테이블을 다른 서버로 복사해야하는 경우
-   레코드를 덤프했다가 복구하는 방식보단, 테이블스페이스 이동(Export & Import) 기능이 훤씬 효율적이고 빠르다.
-   TDE가 적용되었다면 원본 MySQL 서버와 목적 MySQL 서버의 마스터 키가 다르기 때문에 신경써줘야 함.
-   `FLUSH TABLES source_table FOR EXPORT`;

## 7.4 언두 로그 및 리두 로그 암호화

-   테이블 암호화를 적용해도 리두 로그, 언두 로그, 바이너리 로그(복제를 위한)에는 모두 평문으로 저장된다.
-   MySQL 8.0.16부터는 `innodb_undo_log_encrypt` 시스템 변수와 `innodb_redo_log_encrypt` 시스템 변수를 이용해 이 로그들을 암호화된 상태로 저장할 수 있게 개선됐다.
-   암호화를 활성화하면 이전 로그들은 여전히 평문이고, 암호화를 활성화한 시점부터만 암호화가 된다.
-   테이블스페이스 키(리두 로그와 언두 로그 파일을 위한 프라이빗 키)로 암호화된다.

## 7.5 바이너리 로그 암호화

-   바이너리 로그는 상당히 긴 시간 보관되기도 하고, 증분 백업 등에도 사용된다.
-   이로 인해 바이너리 로그 암호화는 상황에 따라 중요도가 높아질 수 있다.

### 7.5.1 바이너리 로그 암호화 키 관리

-   2단계 암호화 키 관리 방식 사용
-   바이너리 로그와 릴레이 로그 파일의 데이터는 파일 키로 암호화해서 디스크에 저장됨
-   파일 키는 '바이너리 로그 암호화 키'로 암호화해서 바이너리로그와 릴레이 로그 파일의 헤더에 저장됨
-   이 파일 키가 테이블 암호화의 마스터 키와 동일한 역할을 함.
-   파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동으로 생성됨

### 7.5.2 바이너리 로그 암호화 키 변경

-   바이너리 로그 암호화 키 변경 방법 : `ALTER INSTANCE ROTATE BINLOG MASTER KEY;`

### 7.5.3 mysqlbinlog 도구 활용

-   암호화된 바이너리 로그를 평문으로 복호화할 필요가 생길 수 있다.
-   직접 열어볼 수는 없다.
-   mysqlbinlog 도구가 MySQL 서버에 접속해서 바이너리 로그를 가져오는 방법으로 접근할 수 있다.
-   `mysqlbinlog --read-from-remote-server -uroot -p -vvv mysql-bin.000011`

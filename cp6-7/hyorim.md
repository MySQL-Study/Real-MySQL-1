# Chapter 6. 데이터 압축
- 데이터 압축을 제공하는 이유

  - MySQL 서버에서 디스크에 저장된 데이터 파일의 크기는 쿼리 처리 성능 & 백업 및 복구 시간에도 연관됨.
  - 데이터 파일이 크면 더 많은 데이터 페이지를 InnoDB 버퍼 풀로 읽어야하고, 더티 페이지가 더 자주 디스크로 기록됨
  - 데이터 파일이 크면 백업 시간 오래 걸리고, 복구하는 데 시간 걸림.
  - 저장공간이 많이 필요하기 때문에 비용 문제 발생

- MySQL에서 사용 가능한 압축 방식

  - 페이지 압축
  - 테이블 압축

## 6.1 페이지 압축
- Transparent Page Compression이라고도 불림.
  - MySQL 서버가 디스크에 저장하는 시점 : 데이터 페이지 압축되어 저장
  - MySQL 서버가 디스크에서 데이터 페이지 읽어올 때 : 페이지 압축 해제
  - 즉, 버퍼 풀에 데이터 페이지 한 번 적재되면 InnoDB 스토리지 엔진은 압축이 해제된 상태로만 데이터 페이지 관리

- MySQL 서버의 내부 코드에서는 압축 여부와 관계 없이 "Transparent"하게 작동
  - 데이터 페이지를 압축한 결과의 용량 예측 불가인데, 적어도 하나의 테이블은 동일한 크기의 페이지로 통일되어야 한다는 것

    - 그래서 페이지 압축 기능은 펀치 홀 사용![]
    - 펀치 홀(Punch hole) : 운영체제별로 특정 버전 파일 시스템에서만 지원됨


- 페이지 압축 방식
  ![](https://velog.velcdn.com/images/hyolim/post/260695d3-c2a7-4bf3-8f47-db86ce128521/image.png)

  - 16KB 페이지를 압축(압축 결과를 7KB로 가정)
  - MySQL 서버는 디스크에 압축된 결과 7KB를 기록 (MySQL 서버는 압축 데이터 7KB에 9K의 빈 데이터를 기록)
  - 디스크에 데이터 기록 후, 7KB 이후의 공간 9KB에 대해 펀치 홀 생성
  - 파일 시스템은 7KB만 남기고 나머지 디스크의 9KB 공간은 다시 운영체제로 반납

- 페이지 압축의 문제점
  - 펀치 홀 기능은 운영체제뿐만 아니라 하드웨어 자체에서도 해당 기능 지원해야 사용 가능함.
  - 파일 시스템 관련 명령어(유틸리티)가 펀치 홀을 지원하지 못함.
  - 실제로 페이지 압축 많이 사용되지 않음.
  - 페이지 압축 이용하려면, 테이블을 생성하거나 변경할 때 COMPRESSION 옵션 설정하면 됨.
    ```
    // 테이블 생성 시
        mysql> CREATE TABLE t1 (c1 INT) COMPRESSION="zlib";
   // 테이블 변경 시
        mysql> ALTER TABLE t1 COMPRESSION="zlib";
        mysql> OPTIMIZE TALBLE t1
    ```

## 6.2 테이블 압축
- 테이블 압축은 운영체제나 하드웨어에 대한 제약 없이 사용할 수 있기 때문에 일반적으로 더 활용도가 높은 편
- 디스크의 데이터 파일 크기를 줄일 수 있기 때문에 이득이 있음.
  <br>

- 테이블 압축의 단점
  - 버퍼 풀 공간 활용률이 낮음
  - 쿼리 처리 성능이 낮음
  - 빈번한 데이터 변경 시 압축률이 떨어짐

### 6.2.1 압축 테이블 생성
- 테이블 압축 사용 전제 조건
  - 압축을 사용하려는 테이블이 별도의 테이블 스페이스 사용해야 함.
    <br>
- 테이블 압축 사용 방법
  - `innodb_file_per_table` 시스템 변수가 ON인 상태에서 테이블 생성되어야 함.
  - 테이블 압축을 사용하는 테이블은 `ROW_FORMAT=COMPRESSED` 옵션 명시해야 함.
  - `KEY_BLOCK_SIZE`는 4KB 또는 8KB만 설정 가능
  - 페이지 크기가 32KB 또는 64KB인 경우네는 테이블 압축 적용 불가
    <br>

- InnoDB 스토리지 엔진의 압축 적용 방법
  ![](https://velog.velcdn.com/images/hyolim/post/52b3949a-5c1e-4769-83fd-df8bfb8f2194/image.png)

  - 16KB 데이터 페이지 압축
    - 압축된 결과가 8KB 이하 : 그대로 디스크에 저장(압축 완료)
    - 압축된 결과가 8KB 이상 : 원본 페이지 split 해서 2개의 페이지에 8KB씩 저장
  - 나뉜 페이지 각각에 대해 1번 단계를 반복 실행
    <br>
  - 테이블 압축에서 InnoDB 스토리지 엔진의 "InnoDB I/O 레이어"에서는 아무 역할 하지 않음.
  - 목표 크기가 잘못 설정되면, MySQL 서버 처리 능력 급격히 떨어질 수 있음.

### 6.2.2 KEY_BLOCK_SIZE 결정
- 테이블 압축에서 가장 중요한 부분 : 압축된 결과 예측하여 `KEY_BLOCK_SIZE` 결정하는 것
- 일반적으로 압축 실패율이 3~5% 미만으로 유지할 수 있도록 `KEY_BLOCK_SIZE` 선택하는 것이 좋음.
- 압축 실패율이 높다고 해서 압축 사용하지 말아야 한다는 것은 아님.
  - 예를 들어, INSERT만 되는 로그 테이블의 경우에는 한 번 INSERT되면 이후 다시 변경되지 않는다면, 한 번 정도는 압축 시도가 실패해서 페이지 스플릿 후 재압축한다고 하더라도 전체적으로 데이터 파일 크기가 큰 폭으로 준다면 나쁘지 않음.
  - 압축 실패율이 그다지 높지 않은 경우라도, 테이블 데이터가 매우 빈번하게 조회되고 변경된다면 압축하지 않는 것이 좋음.
- 테이블 압축은 zlib를 이용해 압축을 실행하년데, 압축 알고리즘은 많은 CPU 자원을 소모함.

### 6.2.3 압축된 페이지의 버퍼 풀 적재 및 사용
- InnoDB 스토리지 엔진은 압축된 테이블의 데이터 페이지를 버퍼 풀에 적재하면 `압축된 상태`와 `압축이 해제`된 상태 2개 버전 관리
  - InnoDB 스토리지 엔진은 디스크에서 읽은 상태 그대로의 데이터 페이지 목록 관리하는 LRU 리스트
  - 압축된 페이지들의 합축 해제 버전인 Unzip_LRU 리스트

  - MySQL 서버에는 압축된 테이블과 압축되지 않은 테이블 공존하므로 LRU 리스트는 압축된 페이지와 압축되지 않은 페이지 모두 가짐.

  - Unzip_LRU 리스트는 압축이 적용되지 않은 테이블의 데이터 페이지는 가지지 않고, 압축이 적용된 테이블에서 읽은 압축을 해제한 상태의 데이터 페이지 목록 관리됨.

- 압축의 문제점
  - InnoDB 스토리지 엔진은 압축된 테이블에 대해 버퍼 풀 공간을 이중으로 사용함으로써 메모리를 낭비하는 효과를 가짐.
  - 압축된 페이지에서 데이터 읽거나 변경하기 위해 압축을 해제해야 하는데, 압축 및 압축 해제 작업은 CPU를 상대적으로 많이 소요함.
  - 단점 보완하기 위해 Unzip_LRU 리스트를 별도로 관리하고 있다가 MySQL 서버로 유입되는 요청 패턴에 따라 적절히(Adaptive) 처리 수행.

- Adaptive하게 압축 수행 방법
  - InnoDB 버퍼 풀의 공간이 필요한 경우에는 LRU 리스트에서 원본 데이터 페이지(압축된 형태)는 유지하고, Unzip_LRU 리스트에서 압축 해제된 버전은 제거해서 버퍼 풀 공간 확보
  - 압축된 데이터 페이지가 자주 사용되는 경우에는 Unzip_LRU 리스트에 압축 해제된 페이지를 계속 유지하면서 압축 및 압축 해제 작업을 최소화
  - 압축된 데이터 페이지가 사용되지 않아서 LRU 리스트에서 제거되는 경우에는 Unzip_LRU 리스트에서도 함께 제거됨.

- InnoDB 스토리지 엔진이 버퍼 풀에서 압축 해제된 버전의 데이터 페이지를 적절한 수준으로 유지하기 위해 어댑티브 알고리즘 사용
  - CPU 사용량이 높은 서버에서는 가능하면 압축과 압축 해제를 피하기 위해 Unzip_LRU의 비율을 높여서 유지하고
  - Disk IO 사용ㄹ야이 높은 서버에서는 가능하면 Unzip_LRU 리스트의 비율을 낮춰서 InnoDB 버퍼 풀의 공간을 더 확보하도록 작동

### 6.2.4 테이블 압축 관련 설정
- 테이블 압축을 사용할 때 연관된 시스템 변수가 몇 가지 있는데, 모두 페이지의 압축 실패율을 낮추기 위해 필요한 튜닝 포인트를 제공
  - `innodb_cmp_per_index_enabled`
  - `innodb_compression_level`
  - `innodb_compression_failure_threshold_pct`
  - `innodb_log_compressed_pages`

# Chapter 7. 데이터 암호화
- `MySQL 5.7 이후` : 데이터 암호화 기능 지원 (테이블 파일에만)
- `MySQL 8.0 이후` : 리두 로그, 언두 로그, 복제 위한 바이너리 로그에도 암호화 지원

- 데이터 암호화 여부는 보안 감사에 필수적으로 언급됨.
- 중요한 정보 저장하는 서비스에서는 응용 프로그램에서 암호화한 데이터를 데이터베이스 서버에서 다시 암호화하는 이중 암호화하기도
  - 응용 프로그램 암호화 : 주로 중요한 정보 가진 칼럼 단위 암호화 수행
  - 데이터베이스 수준에서는 테이블 단위로 암호화 적용

## 7.1 MySQL 서버의 데이터 암호화
![Image Description](https://velog.velcdn.com/images/hyolim/post/0f534455-7756-4713-9902-7204272ed576/image.png)

- MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰는 지점에서 암호화, 복호화 수행
  - 디스크 입출력 이외의 부분에서는 암호화 처리 필요 없음.
  - MySQL 서버(InnoDB의 스토리지 엔진)의 I/O 레이어에서만 데이터 암호화 . 및 복호화 과정 실행됨.

- MySQL 서버에서 사용자 쿼리 처리 과정에서 테이블 데이터가 암호화 여부 식별 필요 없고, 암호화된 테이블도 그렇지 않은 테이블과 동일한 처리 과정 거침.

- TDE(Transparent Data Encryption)
  - 테이블 암호화 기능이 활성화돼 있다고 하더라도 MySQL 내부와 사용자 입장에서는 아무런 차이 없기 때문
  - Data at Rest Encrption이라고 하기도 함.

### 7.1.1 2단계 키 관리
- MySQL 서버의 TDE 암호화 키는 키링(KeyRing) 플러그인에 의해 관리됨.
- MySQL 8.0 버전에서 지원되는 키링 플러그인 (커뮤니티 에디션 사용 가능)
  - `keyring_file File-Based 플러그인` (엔터프라이즈 에디션에서만)
  - `keyring_encrypted_file Keyring 플러그인` (엔터프라이즈 에디션에서만)
  - `keyring_okv KMIP 플러그인` (엔터프라이즈 에디션에서만)
  - `keyring_aws Amazon Web Services Keyring 플러그인` (엔터프라이즈 에디션에서만)

![](https://velog.velcdn.com/images/hyolim/post/b14ebd4f-db1b-4fea-a182-d77f8db27228/image.png)
- 다양한 플러그인 제공되지만 마스터 키 관리하는 방법만 다르고 MySQL 서버 내부적으로 작동하는 방식은 모두 동일
- MySQL 서브의 키링 플러그인은 2단계(2-Tier) 키 관리 방식을 사용함.

<br>

- MySQL 서버의 데이터 암호화 키
  - `마스터 키 (master key)`
  - `테이블 스페이스 키 (tablespace key)` / `프라이빗 키 (private key)`
- HashipCorp Valut 같은 외부 키 관리 솔루션(KMS, Key Management Service) 또는 디스크의 파일(keyring_file 또는 keyring_encrpyed_file 플러그인 사용 시)에서 마스터 키 가져옴.
- 암호화 된 테이블이 생성될 때마다 해당 테이블 위한 임의의 테이블스테이블의 데이터 파일 헤더에 저장
- 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않음.
  - 테이블스페이스 키는 절대 MySQL 서버 외부로 노출되지 않기 때문에 테이블스페이스 키를 주기적으로 변경하지 않아도 보안상 취약점이 되지는 않음.
  - 테이블스페이스 키가 변경된다면 데이터 파일 모든 데이터를 다시 복호화했다가 다시 암호화해야 하므로 사용자 쿼리 처리에 엄청난 영향을 줌.
- 마스터 키는 외부의 파일을 이용하기 때문에 노출될 가능성이 있음.
  - 마스터 키는 주기적으로 변경해야 함.
  - 마스터 키를 변경하면 MySQL 서버는 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화
  - 마스터 키가 변경되는 동안 MySQL 서버의 테이블스페이스 키 자체와 데이터 파일의 데이터는 변경되지 않음.
- TDE에 제공되는 알고리즘은 AES 256비트

### 7.1.2 암호화와 성능
- MySQL 서버의 암호화는 TDE 방식이므로 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재됨.
  - 데이터 페이지가 한 번 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능
  - 데이터 페이지 저장은 사용자 쿼리 처리하는 스레드가 아닌 MySQL 서버의 백그라운드 스레드로 진행되기 때문에 사용자 쿼리가 지연되지는 않음.

- TDE를 적용해도 데이터 파일 크기는 암호화되지 않은 테이블과 동일한 크기를 가짐
  - AES 알고리즘을 사용하지만, 데이터 페이지는 암호화 키보다 훨씬 크기 때문에 암화화 결과가 평문의 결과와 동일한 크기를 가지기 때문
  - 암호화해도 InnoDB 버퍼 풀 효율이나 메모리 사용 효율이 떨어지지 않음.

- 같은 테이블에 대해 암호화와 압축이 동시에 적용되면 '압축 -> 암호화' 순서로 진행
  - 암호화된 결과물은 랜덤한 바이트 배열을 가지게 되어 압출률을 떨어뜨림.
  - 암호화된 테이블의 데이터 페이지는 복호화 된 상태로 InnoDB 버퍼 풀에 저장되지만, 압축된 데이터 페이지는 압축 또는 압축 해제 상태로 저장 가능

### 7.1.3 암호화와 복제
- MySQL 서버의 복제에서 레플리카 소스 서버의 모든 사용자 데이터 동기화하지만, 데이터 파일은 동일하지 않음.
  - MySQL 서버에서 노드는 각자의 마스터키를 할당해야 함.
  - 데이터베이스 서버의 로컬 디렉터리에 마스터 키를 관리하는 경우에는 당연히 소스 서버와 레플리카 서버가 다른 키 가짐.
  - 원격으로 키 솔루션 관리하는 경우에도 소스 서버와 레플리카 서버가 서로 다른 마스터 키 가져야 함.
  - 마스터 키가 레플리카로 복제되지 않기 때문에 테이블스페이스 키 또한 레플리카로 복제되지 않음.
  - 소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 . 키관리하기 때문에 실제 암호화 된 데이터 값은 완전히 다름.
- 마스터 키가 계속 변경되기 때문에 백업마다 키링 파일 백업도 고려해야 함.

## 7.2 keyring_file 플러그인 설치
- TDE의 암호화 키 관리 방식은 플러그인 방식으로 제공됨.
- `keyring_file` 플러그인은 테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크의 파일로 관리
  - 테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크 파일로 관리
  - 마스터 키는 평문으로 디스크에 저장됨.
  - 마스터 키가 저장된 파일이 외부에 노출된다면 데이터 암호화는 무용지물이 됨.
- MySQL 서버의 다른 플러그인과 달리 TDE 플러그인은 MySQL 서버가 시작되는 단계에서도 가장 빨리 초기화 해야함.

## 7.3 테이블 암호화
- 키링 플러그인은 마스터 키를 생성하고 관리하는 부분까지 담당하기 때문에 어떤 키링 플러그인을 사용해도 암호화된 테이블을 생성하고 활용하는 방법은 동일함.

### 7.3.1 테이블 생성
- 일반적인 테이블 생성 구문과 동일하고, 마지막에 `ENCRYPTION='Y'` 옵션만 추가로 넣으면 됨.
  - 테이블 데이터 기록될 때는 데이터가 자동으로 암호화되어 저장되고, 다시 디스크에서 메모리로 읽어올 때 복호화 됨.
  - MySQL 서버에서 암호화된 테이블만 검색할 때는 `information_schema`의 `TABLE` 뷰를 사용하면 됨.
  - 모든 테이블에 암호화 적용하려면 `default_table_encryption` 시스템 변수를 ON으로 설정하면 별도로 설정 안 해도 암호화된 테이블로 생성.

### 7.3.2 응용 프로그램 암호화의 비교
- 응용 프로그램에서 직접 암호화해서 MySQL에 저장을 하면, MySQL 서버가 이미 암호화 된 것읹 여부를 인지 못함.
  - 응용프로그램에서 암호화된 칼럼은 인덱스 생성하더라도 인덱스 기능 100% 활용 못함.
- 응용 프로그램의 암호화 VS MySQL 서버 암호화이면 무조건 후자!
  - TDE를 사용하면 MySQL 서버는 인덱스 관련된 작업 모두 처리 후 최종 디스크에 데이터 페이지 저장할 때만 암호화하기 때문에 제약 없음.

### 7.3.3 테이블 스페이스 이동
- 테이블스페이스 이동(Export & Import) 기능
  - 테이블을 다른 서버로 복사해야 하는 경우 OR 특정 테이블 데이터 파일만 백업하고 복구할 때 레코드 덤프했다가 복구하는 방식보다 효율적이고 빠름.

- TDE가 적용되어 암호화된 테이블도 원본 MySQL 서버와 목적지 MySQL 서버의 암호화 키가 다르기 때문에 신경써야 할 부분 존재

- 테이블스페이스를 export하는 명령
  ```
  mysql> FLUSH TABLES source_table FOR EXPORT;
  ```
  - 암호화 되지 않은 테이블의 테이블 스페이스 복사 과정
    - MySQL 서버는 `source_table`의 저장되지 않은 변경 사항을 모두 디스크로 기록하고, 접근할 수 없도록 lock 설정
    - 테이블 구조를 `source_table.cfg` 파일로 기록
    - `source_table.ibd` 파일과 `source_table.cfg` 파일을 목적지 서버로 복사
    - 복사가 완료되면, `UNLOCK TABLE` 명령을 통해 `source_table` 사용하게 함.

  - 암호화 된 테이블의 테이블 스페이스 복사 과정
    - MySQL 서버가 임시로 사용할 마스터 키 발급해 `source_table.cfp` 파일로 기록
    - 암호화된 테이블의 테이블스페이스 키를 기존 마스터 키로 복호화한 후, 임시 마스터키를 통해 다시 암호화해서 데이터 파일 헤더 부분에 저장
    - 반드시 *.cfp 파일이 있어야 함. (없어지면 복구 불가)



## 7.4 언두 로그 및 리두 로그 암호화
- 테이블의 암호화를 적용해도 리두로그, 언두로그, 복제를 위한 바이너리 로그에는 평문으로 저장됨.
- MySQL 8.0.16버전부터 `innodb_undo_log_encrypt` 시스템 변수와 `innodb_redo_log_encrypt` 시스템 변수를 이용해 InnoDB 스토리지 엔진의 리두로그와 언두로그를 암호화된 상태로 저장할 수 있게 개선됨.

- 리두로그나 언두로그를 평문으로 저장하다가 암호화가 활성화되면 그때부터 생성되는 리두 로그나 언두 로그만 암호화해서 저장하는 방식
- 리두 로그와 언두 로그 데이터 모두 각각의 테이블스페이스 키로 암호화되고, 테이블스페이스 키는 다시 마스터 키로 암호화됨.

## 7.5 바이너리 로그 암호화
- 바이너리 로그는 의도적으로 상당히 긴 시간 보관하는 서비스도 있고, 증분 백업(Incremental Backup)을 위해 바이너리 로그를 보관하기도 하여, 보안에 민감할 수 있음. -> 중요도가 높아질 수 있음.

- 바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당
  - MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터 암호화 하지 않음.
  - 복제 멤버 간의 네트워크 구간에서도 바이너리 로그 암호화하려면 MySQL 복제를 위한 계정이 SSL 사용하도록 하면 됨.

### 7.5.1 바이너리 로그 암호화 키 관리

![](https://velog.velcdn.com/images/hyolim/post/30b57668-3f83-4180-830b-fea52103677b/image.png)

- 바이너리 로그와 릴레이 로그의 데이터 : 파일 키로 암호화해서 디스크로 저장
- 파일 키는 "바이너리 로그 암호화 키"로 암호화해서 각 마이너리 로그와 릴레이 로그 파일의 헤더에 저장
- "바이너리 로그 암호화 키" : 테이블 암호화의 마스트 키와 동일한 역할
- 파일 키 : 바이너리 로그와 릴레이 로그 파일 단위, 자동 생성되어 해당 로그 파일의 데이터 암호화에만 사용됨.

### 7.5.2 바이너리 로그 암호화 키 변경
- 바이너리 로그 암호화 키 변경(로테이션 방법)
```
mysql> ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

### 7.5.3 mysqlbinlog 도구 활용
- 바이너리 로그 파일이 암호화되면 바이너리 로그 암호화 키가 없으면 복호화 불가
- 바이너리 로그 암호화 키는 MySQL 서버만 가지고 있어 복호화 불가능
- mysqlbinlog 도구만으로 복호화할 방법이 없음.
- 바이너리 로그 파일 보려면 MySQL 서버를 통해서 가져오는 방법이 유일함.

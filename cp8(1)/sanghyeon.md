## 8.1 디스크 읽기 방식

### 8.1.2 HDD와 SSD

순차 I/O : 3개의 페이지를 디스크에 기록하기 위해 1번의 시스템 콜 요청

랜덤 I/O : 3개의 페이지를 디스크에 기록하기 위해 3번의 시스템 콜 요청아이콘 추가

쿼리 튜닝의 목적 : 랜덤 I/O 자체를 줄이는 것(쿼리를 처리하는데 꼭 필요한 데이터만을 읽도록 개선하는 것)

## 8.2 인덱스

인덱스

- 프라이머리 키 : 식별자 + NULL 허용 안됨 + UNIQUE
- 세컨더리 인덱스 : 프라이머리 키를 제외한 나머지 인덱스

데이터 저장 알고리즘

- B-Tree : 칼럼의 값을 변경하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash 인덱스 알고리즘 : 칼럼의 값으로 해시값을 계산해 인덱싱하며 매우 빠른 검색을 지원 + 주로 메모리 기반의 DB에 사용

## 8.3 B-Tree 인덱스

### 8.3.1 구조 및 특성

구조 : 루트 노드 - 브랜치 노드 - 리프 노드

인덱스와 실제 데이터가 저장된 데이터는 따로 관리되며, 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가짐

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fnt7dT%2FbtsH9VH5i5B%2Fw9K1RKbvEuOysCCEXppZb1%2Fimg.png)

인덱스의 키 값은 모두 정렬

데이터 파일의 레코드는 임의의 순서 → 레코드 삭제 시 공간을 재활용하도록 파일 재배치

InnoDB에서 인덱스를 통해 데이터를 읽을 경우 :

인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색

프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽음

⇒ 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야함

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

**8.3.2.1 인덱스 추가**

테이블에 레코드 추가 작업 비용 : 해당 테이블의 인덱스에 키를 추가하는 작업 비용 = 1 : 1.5

**8.3.2.2 인덱스 키 삭제**

별도의 작업 필요하지 않음

**8.3.2.3 인덱스 키 변경**

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능

⇒ 삭제 후 추가

**8.3.2.4 인덱스 키 검색**

빠른 검색을 위해 인덱스를 관리하므로 좋은 설계 필요

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**8.3.3.1 인덱스 키 값의 크기**

인덱스는 페이지 단위로 관리

엔진의 페이지 크기 = 16KB

인덱스 페이지 = 16바이트(인덱스 키) + 12바이트(자식 노드 주소 영역)

하나의 인덱스 페이지에 저장 가능한 키 갯수

= 16*1024 / (16+12) = 585개

IF) 키 값의 크기가 32 바이트라면

16*1024/(32+12) = 372개

**8.3.3.2 B-Tree 깊이**

B-Tree의 깊이 = 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제

인덱스 키 값이 커지면 하나의 인덱스 페이지에 담기는 건수가 적어져 깊이가 깊어지고 디스크 읽기가 더 많이 필요해짐

⇒ 인덱스 키 값의 크기는 무조건 작게

**8.3.3.3 선택도(기수성)**

모든 인덱스 키 값 가운데 유니크한 값의 수 → 유니크 한 값이 많을 수록 선택도가 높고 빠르게 처리됨

10000개 중 

10개가 유니크 칼럼 : 10000/10 = 1000개의 데이터를 찾아야 하며 999개의 불필요한 데이터를 찾아야함

1000개가 유니크 칼럼 : 10000/1000 = 10 → 9개의 불필요한 데이터를 읽음

**8.3.3.4 읽어야 하는 레코드의 건수**

인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25퍼센트를 넘어서면 인덱스 이용하지 않고 테이블을 직접 읽고 필요한 레코드만 가려내는 것이 더 효율적

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

**8.3.4.1 인덱스 레인지 스캔**

검색해야할 인덱스의 범위가 결정됐을 때 사용

루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프노드까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있음

리프 노드 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔

리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요

리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 단위로 랜덤 I/O가 일어남

인덱스 레인지 스캔의 3단계

1. 조건 만족 위치 찾기(인덱스 탐색)
2. 찾은 위치부터 필요한 만큼 인덱스를 읽음(인덱스 스캔)
3. 읽어온 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어옴

**8.3.4.2 인덱스 풀 스캔**

인덱스의 처음부터 끝까지 모두 읽는 방식

**8.3.4.3 루스 인덱스 스캔**

인덱스 레인지 스캔과 비슷하게 동작하지만 필요치 않은 인덱스 키 값은 무시하고 넘어감

**8.3.4.4 인덱스 스킵 스캔**

(성별, 생일)을 인덱스로 사용할 경우

1. where 생일 조건 + 성별 조건
    
    인덱스 사용 가능
    
2. where 생일 조건
    
    성별 비교 조건이 없어서 인덱스 사용 불가
    

BUT) 인덱스 스킵 스캔 기능 활성화 하면) 두 조건 중 하나만 가지고도 인덱스 사용 가능

HOW) 조건이 없는 인덱스의 선행 칼럼(성별)으로 정렬 때려놓고 생일로 검색

단점 

- where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
    - 유니크 값의 개수가 많다면 : 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많아짐
    - 인덱스의 선행 칼럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화
    
    ```tsx
    M -> 25 -> John
      -> 30 -> David
      -> 35 -> Michael
    F -> 20 -> Sarah
      -> 25 -> Jessica
      -> 30 -> Emily
      
      ____________________________________________________________________________
    Chicago -> 35 -> Michael
    Los Angeles -> 30 -> David
    New York -> 25 -> John
    Seattle -> 30 -> Emily
    Toronto -> 20 -> Sarah
    Vancouver -> 25 -> Jessica  
    ```
    
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)
    
    성별, 생일만 필요한게 아니라 오만가지 정보가 다 필요한 경우
    

### 8.3.5 다중 칼럼 인덱스

다른 인덱스가 다른 인덱스에 의존함 → 정렬 순서가 일반적인 순서와 다름

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

**8.3.6.1 인덱스의 정렬**

인덱스를 최소값부터 읽거나 최댓값부터 읽음으로써 오름차순, 내림차순으로 값을 가져올 수 있음

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

# Chapter8 - 인덱스(1) (처음~8.3)

## 8.1 디스크 읽기 방식

### 8.1.1 HDD와 SSD

-   HDD는 기계식 저장 장치, SSD는 전자식 저장 장치
    -   HDD는 플래터를 돌려야함
    -   SSD는 플래시 메모리를 장착
-   데이터 순차 I/O에는 HDD보다 SSD가 빠르거나 비슷하다.
    -   그러나 랜덤 I/O에 SSD가 HDD보다 훠어어얼씬 빠르다. HDD는 원판을 돌려야하니까!
    -   DB입장에선 랜덤 I/O가 필수지

### 8.1.2 랜덤 IO와 순차 IO

-   순차IO: 3페이지를 디스크에 기록하는 데에 한 번의 시스템 콜
-   랜덤IO: 3페이지를 디스크에 기록하는 데에 세 번의 시스템 콜
-   디스크 원판을 가지지 않는 SSD이더라도 순차 IO가 랜덤IO보다 처리량(throughput)이 높다.
-   인덱스 레인지 스캔은 보통 랜덤IO로 수행되며, 풀스캔은 순차IO로 수행된다.
-   쿼리 튜닝을 해서 랜덤IO를 순차 IO로 바꿔 실행하긴 어렵다.
-   쿼리 튜닝의 목적은 랜덤을 순차로 바꾸는 것보단, 랜덤 횟수를 줄여 꼭 필요한 데이터만 읽도록 하는 데에 있다.

## 8.2 인덱스란?

-   책 끝의 '색인' 비유
-   SortedList: 항상 값이 정렬된 구조를 유지하는 자료구조
    -   ArrayList: 값이 들어온 순서가 유지되는 자료구조
-   Index는 SortedList.
    -   값이 INSERT될 때는 정렬을 보존해야해서 느리지만, SELECT할 땐 색인을 가지고 있기 때문에 아주 빠르다.
    -   인덱스란 INSERT/UPDATE/DELETE 성능을 희생하고, 그 대신 SELECT 속도를 높이는 것
-   인덱스의 종류: Primary Key / Secondary Key
    -   Primary Key: 레코드를 식별할 수있는 기준이 되는 대표 키
    -   Secondary Key: 보조 키. 인덱스 중 PK를 제외한 모든 키.
        -   유니크 키는 PK를 대체할 수 있어서 '대체 키'라고 불리기도 함. 별도로 구분할 때도 있고, 세컨더리로 구분하기도 함.
-   인덱스를 저장방식(알고리즘)에 따라 구분해보면: B-Tree / Hash
    -   B-Tree: 시간 복잡도 O(logN)
    -   Hash: 시간 복잡도 O(1) (해시 충돌이 많이 발생하면 O(n)까지도 가능)
    -   DB 인덱스에서 가장 일반적으로 사용되는 게 B-Tree
    -   그럼 여기서 면접관이 이렇게 물어보면? -> 왜 Hash가 더 빠른데 B-Tree를 써요?
        -   그럼 이렇게 대답해야지: B-Tree가 Hash보다 '범위 탐색'에 유리하기 때문입니다.
-   인덱스를 데이터 중복 여부로 구분해보면: Unique 인덱스 / Non-Unique 인덱스
    -   unique하면 한 레코드만 찾은 경우 더이상 스캔을 하지 않아도 된다.
    -   unique여부에 따라 쿼리 플랜의 차이가 발생한다.
-   인덱스의 기능별 구분: 전문 검색용 인덱스 / 공간 검색용 인덱스

## 8.3 B-Tree 인덱스

-   B-Tree란? `Balanced` 트리. 즉 균형잡힌 트리이다.

### 8.3.1 구조 및 특성

![[Pasted image 20250125035457.png]]

![[Pasted image 20250125035551.png]]

인덱스와 키 값은 모두 정렬되어 있고, 데이터 파일은 정렬되어 있지 않음.
![[Pasted image 20250125035727.png]]
![[Pasted image 20250125035703.png]]

-   위는 MyISAM 방식, 밑은 InnoDB 방식.
-   MyISAM은 간단히 인덱스를 토대로 바로 데이터의 ROWID를 찾아 접근하고 있음.
-   InnoDB는 인덱스를 토대로 PK를 찾고, PK 인덱스의 리프 페이지에 저장된 레코드를 읽음.
    -   즉, InnoDB는 세컨더리 인덱스를 사용할 적에 레코드 읽기를 위해서는 PK B-Tree를 다시한번 검색해야한다.
-   즉, 클러스터링 인덱스는 key 기준 데이터가 정렬되어 저장되며, 넌-클러스터링 인덱스는 무작위로 데이터가 기록된다. 이 무작위 데이터는 RID를 통해 접근한다.
-   자세한 클러스터링 관련 내용은 8.8절 커밍쑨

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

-   인덱스 키 추가
    -   인덱스 없는 레코드 하나 추가할 때 비용: 1
    -   인덱스 n개 있는 레코드 하나 추가할 때 비용: 1.5 \* n
    -   디스크로부터 인덱스 페이지를 읽고 쓰기를 해야하므로 시간이 걸림
-   인덱스 키 삭제
    -   삭제 마크만 하면 작업 완료
    -   디스크 IO 시간 걸림
    -   버퍼링을 통해 지연 처리 할 수도 있음
-   인덱스 키 변경
    -   변경 시에는 `삭제 후 재삽입`을 수행하게 된다. B-Tree 구조상 그냥 그 위치에서 수정하게 되면 정렬이 풀리기 때문이다.
    -   체인지 버퍼를 통해 지연 처리 가능
-   인덱스 키 검색 - 트리 탐색으로 O(logN)만에 검색이 끝난다. - 인덱스 키 값에 변형이 가해진 후 비교되는 경우 B-Tree 검색 기능을 활용할 수가 없다.

    ```SQL
    -- 나쁜 예시: 인덱스 컬럼에 함수 적용
    SELECT \* FROM users WHERE UPPER(name) = 'JOHN';
    -- name 컬럼의 인덱스를 활용할 수 없음

    -- 좋은 예시: 인덱스 컬럼 그대로 사용
    SELECT \* FROM users WHERE name = 'John';

    -- 나쁜 예시: 계산식 사용
    SELECT _ FROM products WHERE price _ 1.1 > 1000;
    -- price 컬럼의 인덱스를 활용할 수 없음

    -- 좋은 예시: 조건절 변경
    SELECT \* FROM products WHERE price > 1000 / 1.1;

    -- 나쁜 예시: 묵시적 형변환
    SELECT \* FROM orders WHERE order_id = '1000';
    -- order_id가 숫자 타입일 경우 인덱스 활용 불가능

    -- 좋은 예시: 명시적 형변환
    SELECT \* FROM orders WHERE order_id = CAST('1000' AS UNSIGNED);
    ```

-   UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용될 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다. 심지어 테이블의 모든 레코드를 잠글 수도 있으니 주의!

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

\*페이지란?: 디스트에 데이터를 저장하는 가장 기본 단위

1.  인덱스 키 값의 크기: 인덱스 값이 클수록 악영향
    -   페이지의 기본크기는 16KB
    -   인덱스 키 값의 크기가 클수록 디스크로부터 읽어야하는 횟수가 늘어나고 느려진다.
        -   키 값의 크기가 클수록 한 페이지 안에 들어갈 수 있는 키 개수가 줄어들기 때문
        -   또 인덱스 크기가 커지게 되면, InnoDB 버퍼 풀에 캐시 영역은 제한적이기에 캐시해둘 수 있는 레코드 수 또한 줄어들게 되고 메모리 효율이 떨어지는 결과가 발생한다.
2.  B-Tree 깊이
    -   깊이를 제어할 방법은 없다.
    -   왜 B-Tree깊이가 깊어지는가?
        -   인덱스 값이 클수록 한 페이지 안에 저장할 수 있는 키 개수가 줄어든다.
        -   그렇게 되면 B-Tree 깊이가 깊어지고, 디스크 읽기가 더 많이 필요해진다.
3.  선택도
    -   선택도: 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
    -   선택도가 높을수록, 즉 유니크한 값의 수가 많을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
    -   예를들어 만 건의 데이터가 있다면,
        -   유니크한 값의 수가 10건인 경우(10개의 그룹으로 나누어짐), 평균적으로 천 건을 다 뒤져봐야 한다.
        -   유니크한 값의 수가 1000건인 경우(천 개의 그룹으로 나누어짐), 평균적으로 10건만 뒤져보면 된다.
4.  읽어야할 레코드 건수
    -   인덱스를 통해 레코드를 읽는 것은 인덱스 없이 레코드를 읽는 것보다 비용이 드는 일임
    -   옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업으로 판단함
    -   인덱스를 통해 읽어야할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 그냥 인덱스 없이 테이블을 직접 읽는다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

1. 인덱스 레인지 스캔
    - 검색해애할 '범위'가 결정되었을 때 사용하는 방식
    1. 시작 위치를 찾고, 순서대로 인덱스를 읽어나가면 된다.
    2. 읽어들인 인덱스와 레코드 주소를 통해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽는다. 이 때에 레코드 한 건 마다 랜덤 IO가 발생한다.
        - 쿼리에서 select한 데이터에 따라 이 과정이 필요없을 수도 있다. 이미 인덱스에 모든 정보가 다 있기 때문이다. 이러한 인덱스를 '커버링 인덱스'라고 한다.
1. 인덱스 풀 스캔
    - 리프노드의 맨 앞/뒤로 이동하여 링크드 리스트 타고 쭉 스캔하는 것.
    - 인덱스 레인지 스캔보단 느리지만, 테이블 풀 스캔보다는 효율적이다.
1. 루스(Loose) 인덱스 스캔
    - 듬성듬성 인덱스를 읽는 것 (Loose)
    - 중간에 필요치 않은 인덱스 키 값은 스킵하고 다음으로 넘어가는 형태
    - GROUP BY 또는 집합 함수의 MAX() MIN()에 대해 최적화를 하는 경우 사용한다.
1. 인덱스 스킵 스캔
    - 원래는 `(A, B)`로 인덱스가 걸린 경우 `WHER B조건`만 쓰는 경우 인덱스를 사용하지 못했다. `WHERE A조건 AND B조건`으로 써야 한다.
    - MySQL 8.0부터는 `WHERE B조건`만 써도 인덱스를 '스킵'하고 스캔하는 기능이 추가됐다.
    - WHERE 조건절의 검색을 위한 용도로 쓰일것.
    - 다만 다음과 같은 단점 존재:
        - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야함.
            - WHERE A조건="MALE" AND B
            - WHERE A조건="FEMALE" AND B
            - 이런식으로 최적화가 진행되기 때문에 유니크한 값의 개수가 많으면 오래걸린다.
        - 커버링 인덱스여야 한다.
            - 디스크에서 읽어와야 한다면 옵티마이저는 풀 데이터 스캔으로 실행 계획을 수립한다.

### 8.3.5 다중 컬럼(Multi-column) 인덱스

-   첫번째 칼럼에 의존해서 정렬된다. 첫번째 칼럼이 같은 값들인 경우에 두번째 칼럼으로 정렬.. 이런 규칙으로 구현된다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

-   인덱스의 정렬
    -   각 컬럼의 오름/내림차순을 각각 지정할 수 있다. (이전에는 안 됐다고 함)
    -   인덱스 생성 시점에 오름/내림 차순이 결정되지만, 쿼리가 그 인덱스를 사용하는 시점에 또 인덱스를 읽는 방향에 따라 오름/내림차순 정렬 효과를 얻을 수 있다. 즉, 실제 오름/내림차순 여부와 관계없이 인덱스를 읽는 순서만 그때그때 바꾸어 해결한다.
-   내림차순 인덱스

    -   `SELECT * FROM t1 ORDER BY tid ASC LIMIT 12619775, 1;`
    -   `SELECT * FROM t2 ORDER BY tid DESC LIMIT 12619775, 1;`
    -   전자가 후자보다 28%가량 빠르다. 왜?
        -   페이지 잠금이 인덱스 정순 스캔에 적합한 구조이기 때문
        -   페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조!
    -   그러므로 ORDER BY ... DESC 쿼리가 드물게 실행된다면 내림차순 인덱스를 고려할 필요가 없다. 그러나 빈번하다면 내림차순 인덱스도 고려해보기
    -   우리의 프로젝트에서 인덱스를 Desc로 건 게 mysql이라면 유의미했겠구나. (그러나 postgres에선 ASC DESC 성능 차이가 크게 없다고 함)

        ```prisma
        model Chatting {
          chattingId      Int      @id @default(autoincrement()) @map("chatting_id")
          createUserToken String   @map("create_user_token")
          body            String
          createdAt       DateTime @default(now()) @map("created_at")
          sessionId       String   @map("session_id")

          @@index([sessionId])
          @@index([sessionId, chattingId(Sort.desc)])

        }
        ```

        ```sql
        -- chatId가 있을 때 (스크롤 로드)
        SELECT c.*, ut.*, u.*
        FROM chatting c
        JOIN user_session_token ut ON c.create_user_token = ut.token
        JOIN user u ON ut.user_id = u.id
        WHERE c.session_id = '특정세션ID'
        AND c.chatting_id < 123  -- 마지막으로 로드된 채팅 ID
        ORDER BY c.chatting_id DESC
        LIMIT 20;
        ```

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

-   비교 조건의 종류와 효율성
    -   `WHERE A조건 AND B조건` 이런 범위 탐색이 있는 경우, 인덱스가 `(A,B)`로 걸려있을 경우에 적합하다. `(B,A)`인덱스인 경우에는 전자보다 더 쓸데없이 많은 레코드를 탐색하게 된다.
    -   그 이유는 다중 컬럼 인덱스의 정렬 방식 때문이다.
-   인덱스의 가용성
    -   B-Tree 인덱스는 왼쪽 값에 기준해서 오른쪽 값이 정렬된다는 것이다.
        -   first_name 컬럼: `A a mer`, `A a mod`, `A b delaziz`, `A b delghani`, `A b delkader`...
        -   그래서 만약 `SELECT * FROM employees WHERE first_name LIKE '%mer` 이런 쿼리는 끝 부분을 찾을 수 없어 인덱스 효과를 얻을 수 없다.
-   가용성과 효율성 판단

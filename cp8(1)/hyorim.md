# Chapter 8. 인덱스
## 8.1 디스크 읽기 방식
- CPU나 메모리 같은 전기적 특성 띤 장치에 비해 디스크 같은 기계식 장치 성능 제한적 발전
    - 데이터베이스 성능 튜닝은 어떻게 디스크 I/O 줄이는지가 관건

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- 하드 디스크 드라이브 (HDD)
    - 기계식 장치
        - 데이터베이스 서버에서 병목이 됨. -> 전자식 저장 매체인 SSD 많이 출시됨.

- 솔리드 스테이트 드라이브 (SSD)
    - 전자식 저장 매체
    - 기존 하드 디스크 드라이브와 같은 인터페이스(SATA나 SAS) 지원하므로 내장 디스크나 DAS 또는 SAN에 그대로 사용 가능
    - SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판) 제거하고 플래시 메모리 장착
        - 회전하지 않아 빠르게 데이터 읽기 가능
        - 전원 공급되지 않아도 데이터 삭제되지 않음.
        - D-Ram(컴퓨터의 메모리)보다는 느리지만 기계식 하드 디스크보다는 훨씬 빠름.
- 랜덤 I/O가 기존 하드 디스크 드라이브보다 훨씬 빠름.
    - 데이터베이스 서버에서 순차 I/O 작업은 그다지 비중 크지 않고, 랜덤 I/O를 통해 작은 데이터 읽고 쓰는 작업이 대부분이므로 DBMS용 스토리지에 최적!

### 8.1.2 랜덤 I/O와 순차 I/O
![](https://velog.velcdn.com/images/hyolim/post/438e3187-c8c0-4704-87ba-ed2c5b07b55e/image.png)
- 랜덤(Random) I/O
    - 3개의 페이지 디스크에 기록하기 위해 3번 시스템 콜 요청
- 순차 (Sequential) I/O
    - 3개의 페이지 기록하기 위해 1번 시스템 콜 요청
- 디스크 성능은 디스크 헤더 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정됨.
    - 여러 번 쓰기 또는 읽기 요청하는 랜덤 I/O 작업이 작업 부하기 훨씬 큼.
    - 데이터베이스 대부분 작업은 이런 작은 데이터 빈번히 읽고 쓰기 때문에 MySQL 서버에는 `그룹 커밋`이나 `바이너리 로그 버퍼` 또는 `InnoDB 로그 버퍼` 등의 기능 내장되어 있음.
- SSD 드라이브에서도 랜덤 I/O는 여전히 순차 I/O보다 전체 스루풋(Throughput)이 떨어짐.
- 쿼리를 튜닝해서 랜덤 I/O -> 순차 I/O로 바꾸어 실행할 방법은 많지 않음.
    - 쿼리 튜닝하는 것이 랜덤 I/O 자체를 줄여주는 것.
    - 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리 개선하는 것.

## 8.2 인덱스란?
- DBMS 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해 보관
    - 저장되는 칼럼 값을 이용해 항상 정렬된 상태를 유지
        - 데이터가 저장될 때마다 항상 값을 정렬해야하므로 저장하는 과정이 복잡하고 느림.
        - 이미 정렬되어 있어 원하는 값 아주 빨리 가져오기 가능
- DBMS에서 인덱스는 데이터의 저장 성능(INSERT, UPDATE, DELETE) 희생하고 데이터 읽기 속도를 높이는 기능임.

#### 인덱스를 '역할'로 구분
- 프라이머리 키 (Primary key)
    - 레코드 대표하는 칼럼의 값으로 만들어진 인덱스
    - 식별자라고도 부름.
    - Null 허용하지 않음.

- 보조 키 (세컨더리 인덱스, Secondary key)
    - 프라이머리 키를 제외한 나머지 모든 인덱스
    - 유니크 인덱스는 프라이머리 키와 성격 비슷하고, 프라이머리 키를 대체해 사용할 수 있어 '대체키'라고도 하는데, 별도로 분류하기도, 세컨더리 키로 분류하기도 함.

#### 인덱스를 '데이터 저장 방식(알고리즘)'로 구분
- B-Tree 인덱스
    - 가장 일반적으로 사용되는 인덱스 알고리즘
    - 칼럼의 값 변형하지 않고 원래의 값 이용해 인덱싱하는 알고리즘.
    - MySQL 서버에서 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 B-Tree 응용 알고리즘이라고 볼 수 있음.

- Hash 인덱스
    - 칼럼의 값으로 해시값 계산해서 인덱싱하는 알고리즘
    - 매우 빠른 검색 지원
    - 값 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값 일부만 검색하거나 범위 검색할 때는 사용 불가
    - 메모리 기반 데이터베이스에서 많이 사용

- 최근에는 Fractal-Tree 인덱스나 로그 기반의 Merge-Tree 인덱스와 같은 알고리즘을 사용하는 DBMS도 개발되고 있음.

#### 인덱스를 '데이터의 중복 허용 여부'로 구분
- 유니크(Unique) 인덱스
    - 동등 조건으로 검색하면 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 냄.

- 유니크 하지 않은(Non-Unique) 인덱스

#### 인덱스를 '기능별'로 구분
- 전문 검색용 인덱스
- 공간 검색용 인덱스

## 8.3 B-Tree 인덱스
- 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입됨.
- 아직도 가장 범용적인 목적으로 사용되는 인덱스 알고리즘
- B-Tree에서 변형된 알고리즘
    - B+-Tree
    - B*Tree
- B-Tree는 칼럼의 원래 값을 변형시키지 않고(물론 값의 앞부분만 잘라서 관리하기는 하지만) 인덱스 구조체 내에서는 항상 정렬된 상태 유지
  -> 전문 검색과 같은 특수 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree 사용할 정도로 일반적인 용도에 적합한 알고리즘

### 8.3.1 구조 및 특성
- 최상위에 하나의 `루트 노드(Root node)`가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조의 가장 하위에 있는 노드를 `리프 노드(Leaf node)`, 루트 노드도 리프 노드도 아닌 중간의 노드를 `브랜치 노드(Branch node)`라고 함.
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가짐.

![](https://velog.velcdn.com/images/hyolim/post/b973229b-99e7-4188-9e92-28285ec2f9fc/image.png)
- 인덱스 값은 모두 정렬돼 있음.
- 데이터 파일의 레코드는 임의의 순서로 저장돼 있음.
    - 레코드가 삭제되어 빈 공간 생기면 그 다음 INSERT는 가능한 삭제한 공간 사용하므로 INSERT 순으로 저장되는 것도 아님.

- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼 읽으려면 데이터 파일에서 해당 레코드 찾아야 함.
  -> 인덱스의 리프 노드는 데이터 파일에 저장된 레코드 주소를 가짐.

![](https://velog.velcdn.com/images/hyolim/post/12a8575e-d1a6-4966-b2da-61d3dfd1f2e9/image.png)
- 레코드 주소 : MyISAM 스토리지 테이블 생성 옵션에 따라 레코드가 테이블에 INSERT된 순번 OR 데이터 파일 내 위치(Offset)

![](https://velog.velcdn.com/images/hyolim/post/0575c3c7-7ded-4775-a09f-1c04520aa7ff/image.png)
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 프라이머리 키가 ROWID 역할

#### MyISAM과 InnoDB 사용할 때의 차이점
- 세컨더리 인덱스를 통해 데이터 파일의 레코드 찾아가는 방식
- `MyISAM 테이블` : 세컨더리 인덱스가 물리적인 주소 가짐
- `InnoDB 테이블` : 프라이머리 키를 주소처럼 사용하기 때문에 논리적 주소를 가짐.
    - 인덱스를 통해 레코드 읽을 때는 데이터 파일 바로 찾아가지 못함.
    - 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스 한 번 더 검색 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드 읽음.
    - 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키 저장하고 있는 B-Tree 다시 한 번 검색해봐야 함.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
- 테이블 레코드 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업 발생

#### 8.3.2.1 인덱스 키 추가
- 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 아닐 수도 있음.

**인덱스 추가 과정**
- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치 검색 필요
- 저장할 위치가 결정되면 레코드 키 값과 대상 레코드 주소 정보를 B-Tree 리프 노드에 저장
- 리프 노드가 꽉 차서 더 저장 불가하면 리프 노드가 분리(Split)
    - 상위 브랜치 노드까지 처리 범위 넓어짐.
    - 이 때문에, B-Tree는 상대적으로 쓰기 작업 비용이 높음.

**인덱스 추가로 인한 영향**
- 테이블의 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성에 따라 달라짐.
- 대부분의 비용은 메모리와 CPU에서가 아닌, 디스크로부터 인덱스 페이지 읽고 쓰는 데 걸리는 시간!

<br>

- MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 새로운 키 값을 B-Tree 인덱스에 변경
- InnoDB 스토리지 엔진은 필요하다면, 인덱스 키 추가 작업 지연시켜 나중에 처리 가능
    - 단, 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요해 즉시 B-Tree에 추가하거나 삭제

#### 8.3.2.2 인덱스 키 삭제
- 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 삭제 마크만 하면 작업 완료
    - 삭제 마킹된 인덱스는 계속 방치하거나 재활용 가능
    - 인덱스 키 삭제로 인한 마킹 작업도 디스크 쓰기가 필요하므로 디스크 I/O가 필요
    - MySQL 5.5 이상 버전의 InnoDB는 버퍼링되어 지연 처리 가능

#### 8.3.2.3 인덱스 키 변경
- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드 위치가 결정되므로 B-Tree 값이 변경되는 경우에는 단순히 인덱스 상의 키만 변경하는 것은 불가능
    - 키 값을 삭제
    - 다시 새로운 키를 추가
- InnoDB 스토리지 엔진 사용하는 테이블에 대해서 이 작업 모두 체인지 버퍼 활용해 지연 처리 가능

#### 8.3.2.4 인덱스 키 검색
- INSERT, UPDATE, DELETE 작업할 때 인덱스 관리에 따르는 추가 비용 감당하면서 인덱스 구축하는 이유는 '빠른 검색' 때문
- `트리 탐색`
  : B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 노드까지 이동하면서 비교 작업 수행하는 것
  - 인덱스 트리 탐색은 SELECT 뿐 아니라, UPDATE나 DELETE 처리하기 위해 해당 레코드 먼저 검색해야 할 경우에도 사용됨.
  - B-Tree 인덱스를 이용한 검색은 100% 일치 혹은 값의 앞부분(Left-most part)만 일치하는 경우에는 사용 가능
  - 부등호 비교조건에서도 인덱스 활용 가능
  - 인덱스 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스 사용 불가
  - 인덱스를 이용한 검색에서 인덱스 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능 사용 불가
  - 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아님
  - 함수나 연산 수행 결과로 정렬하거나 검색하는 작업은 B-Tree 장점 사용 불가

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스를 구성하는 칼럼의 크기
- 레코드의 건수
- 유니크한 인덱스 키 값의 개수

#### 8.3.3.1 인덱스 키 값의 크기
- `페이지(Page)` / `블록(Block)`
  : 디스크에 데이터를 저장하는 가장 기본 단위, 디스크의 모든 읽기 쓰기 작업의 최소 작업 단위
  - InnoDB 스토리지 엔진의 버퍼 풀에서 데이터 버퍼링하는 기본 범위이기도
  - 인덱스도 결국은 페이지 단위로 관리됨.
  - 루트와 브랜치, 리프 노드를 구분한 기준이 페이지 단위
  - 이진(Binary) 트리는 각 노드가 자식 2개만 가져, DBMS의 B-Tree가 이진 트리라면 인덱스 검색이 상당히 비효율적일 것임.
  -> 그에 반해 B(Balanced)-Tree는 자식 노드의 개수가 가변적인 구조
  - 자식 노드를 몇개까지 가지는지는 인덱스 페이지 크기와 키 값 크기에 따라 결정됨.
  - MySQL 5.7버전부터는 InnoDB 스토리지 엔진의 페이지 크기를 `innodb_page_size` 시스템 변수로 4KB~6KB 사이의 값 선택 가능 (기본 값은 16KB)
  - 인덱스 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수 늘어나고, 느려짐.  + 메모리에 캐시해 둘 수 있는 레코드 수도 줄어듦.
  -> 메모리 효율이 떨어지게 됨.

#### 8.3.3.2 B-Tree 깊이
- B-Tree의 깊이(Depth)는 상당히 중요하지만, 직접 제어할 수 없음.
- B-Tree 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크 읽어야 하는지와 직결됨.
- 인덱스 키 값의 크기가 커질수록, 하나의 페이지가 담을 수 있는 인덱스 키 값 개수 적짐
  -> B-Tree의 깊이 깊어짐 -> 디스크 읽기 더 많이 필요

#### 8.3.3.3 선택도(기수성)
- 선택도(Selectivity) / 가수성(Cardinality)
  : 모든 인덱스 키 값 가운데 유니크한 값의 수
  - 인덱스 키 값 중복된 값이 많을수록 기수성이 낮아지고, 선택도 떨어짐.
  - 선택도가 높을수록 검색 대상 줄어들어 빠르게 처리됨.

#### 8.3.3.4 읽어야 하는 레코드의 건수
- `인덱스를 통해 테이블 레코드 읽는 비용` > `바로 테이블 레코드 읽는 비용`
- 인덱스를 이용한 읽기 손익 분기점에 따라 판단할 필요 있음.
    - 일반적인 DBMS의 옵티마이저에서 인덱스 통해 레코드 1건 읽는 비용이 직접 레코드 1건 읽는 것 보다 4~5배 비용으로 예츨
    - 인덱스 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20%~25% 넘어서면 모두 직접 읽어서 필터링 방식으로 처리하는 것이 효율적

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
#### 8.3.4.1 인덱스 레인지 스캔
- 인덱스 접근 방법 가운데 가장 대표적인 접근 방식
- 검색해야 할 인덱스 범위가 결정됐을 때 사용하는 방식
- 레인지 스캔 과정
    - `인덱스 탐색(Index seek)`
      : 인덱스에서 조건을 만족하는 값이 저장된 위치 찾음.
      - `인덱스 스캔(Index scan)`
      : 탐색된 위치부터 필요한만큼 인덱스 차례로 쭉 읽음.
      - 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지 가져오고, 최종 레코드를 읽어옴.
      - 이 과정이 필요하지 않는 경우 : `커버링 인덱스`
      - 이 경우 디스크 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 줄어들고 성능은 빨라짐.

#### 8.3.4.2 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
    - 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동 후, 인덱스 링크 노드 연결하는 링크드 리스트 따라 처음부터 끝까지 스캔하는 방식
- 인덱스 크기는 테이블 크기보다 작으므로 일반적으로 인덱스만 읽는 것이 효율적
    - 쿼리가 인덱스에 명시된 칼럼만으로 조건 처리할 수 있는 경우 주로 사용
    - 인덱스와 데이터 레코드까지 모두 읽어야 한다면 절대 사용 X
- 인덱스 레인지 스캔보다는 빠르지 않지만, 데이터 풀 스캔보다는 효율적

#### 8.3.4.3 루스 인덱스 스캔
- MySQL 5.7 버전까지는 MySQL 루스 인덱스 스캔 많이 제한적
- MySQL 8.0 버전부터는 다른 상용 DBMS에서 지원하는 인덱스 스킵 스캔과 같은 최적화 조금씩 지원 시작
- 타이트(Tight) 인덱스 스캔(인덱스 레인지 스캔, 인덱스 풀 스캔)과 상반된 의미로 느슨하게 인덱스 읽는 것 의미함.
- 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어감.

#### 8.3.4.4 인덱스 스킵 스캔
- MySQL 8.0 버전부터는 옵티마이저가 칼럼을 건너뛰어 다른 칼럼만으로도 인덱스 색인 가능하게 해주는 인덱스 스킵 스캔 최적화 기능 도입됨.
- 단점
    - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함.
        - 쿼리 실행 계획 비용 관련 문제
        - 유니크한 개수가 많으면 MySQL 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해짐.
    - 쿼리가 인덱스에 존재하는 칼럼으로만 처리 가능해야 함(커버링 인덱스)

### 8.3.5 다중 칼럼(Multi-column) 인덱스
- `다중 칼럼 인덱스` / `Concatenataed Index`
  : 두 개 이상 칼럼을 포함하는 인덱스
  - 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬됨.
  - 다중 컬럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 매우 중요.

### 8.3.6 B-Tree 인덱스 정렬 및 스캔 방향
- 인덱스 생성할 때 오름차순 or 내림차순으로 저장
- 인덱스 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정됨.

#### 8.3.6.1 인덱스의 정렬
- 일반적인 상용 DBMS에서는 인덱스 생성하는 시점에 인덱스 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 설정 가능
- MySQL 8.0부터는 정렬 순서 혼합한 인덱스도 생성 가능

**8.3.6.1.1 인덱스 스캔 방향**

- 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬 결정되지만, 쿼리가 그 인덱스 사용하는 시점에 인덱스 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과 얻을 수 있음.
- ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스 읽기 방향 전환해 사용하도록 실행 계획 만듦.

**8.3.6.1.2 내림차순 인덱스**

- MySQL 서버에서 실제 내림차순인지 오름차순인지 관계없이 인덱스 읽는 순서만 변경해서 해결
- 많은 쿼리가 인덱스 앞쪽 혹은 뒷쪽만 집중적으로 읽어서 인덱스 특정 페이지 잠금이 병목될 것으로 예상되면 자주 사용되는 정렬 순서대로 인덱스 생성하는 것이 잠금 병목 현상 완화에 도움됨.

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

#### 8.3.7.1 비교 조건의 종류와 효율성
- 다중 칼럼 인덱스에서 각 칼럼 순서와 각 칼럼에 사용된 조건에 따라 각 인덱스 칼럼의 활용 형태가 달라짐.

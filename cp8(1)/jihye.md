# CHAPTER 8. 인덱스

## 8.1 디스크 읽기 방식
- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많음

#### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)를 제거하고 그 대신 플래시 메모리 장착
- 플래시 메모리는 전원이 공급되지 않아도 데이터가 삭제되지 않으며 HDD보다 훨씬 빠름
- 요즘 DBMS용으로 사용할 서버에는 대부분 SSD를 채택
- 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 HDD보다 조금 빠르거나 거의 비슷한 성능
- 랜덤 I/O에서는 HDD보다 훨씬 빠름

#### 랜덤 I/O와 순차 I/O
- 랜덤 I/O: HDD의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
- 순차 I/O: 연속된 3개의 페이지를 디스크에 기록하기 위해 1번의 시스템 콜을 요청
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O를 줄여 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것

## 8.2 인덱스란?
- DBMS의 인덱스는 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지
- 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장
- DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정
- 프라이머리 키: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스, NULL 값을 허용하지 않으며 중복을 허용하지 않음
- 세컨더리 인덱스: 프라이머리 키를 제외한 나머지 모든 인덱스
- 데이터 저장 방식(알고리즘)
  - B-Tree 인덱스: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  - Hash 인덱스: 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색 지원 -> 값을 변형해서 인덱싱하므로 전방 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 사용 불가

## 8.3 B-Tree 인덱스 (Balanced-Tree)
- 칼럼의 원래 값을 변형시키지 않고(물론 값의 앞부분만 잘라서 관리하기는 하지만) 인덱스 구조체 내에서는 항상 정렬된 상태로 유지

#### 구조 및 특성
<img src="https://velog.velcdn.com/images/rg970604/post/2dc29e24-516d-4232-8802-551dcf7dc75f/image.png" width=600>

출처: https://velog.io/@rg970604/%EC%9D%B8%EB%8D%B1%EC%8A%A4-B-Tree
- 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가짐
- 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서대로 레코드가 저장되는 것은 아님
- InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장
- MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
- InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 함

#### B-Tree 인덱스 키 추가 및 삭제
- 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업 발생

###### 인덱스 키 추가
- MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경
- InnoDB 스토리지 엔진은 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간(체인지 버퍼)에 저장해 두고 사용자에게 결과를 반환하는 형태로 성능 향상
- 하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제

###### 인덱스 키 삭제
- 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업 완료

###### 인덱스 키 변경
- 먼저 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 처리

###### 인덱스 키 검색
- 트리 탐색: B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업 수행
- 인덱스의 트리 탐색은 SELECT에서만 사용하는 것이 아니라 UPDATE나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용 가능
- 부등호 비교 조건에서 인덱스 활용이 가능하지만 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스 사용 불가 -> LIKE 연산이 앞에 붙어 있는 경우 인덱스 사용 불가
- 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 불가 -> 변형된 값은 B-Tree에 존재하는 값이 아님
- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현
 
#### B-Tree 인덱스 사용에 영향을 미치는 요소
###### 인덱스 키 값의 크기
<img src="https://velog.velcdn.com/images/rg970604/post/79e9715c-07e0-4541-9cdf-684af0329638/image.png" width=600>

출처: https://velog.io/@rg970604/%EC%9D%B8%EB%8D%B1%EC%8A%A4-B-Tree
- 페이지 또는 블록: InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
- 5.7 버전부터 InnoDB 스토리지 엔진의 페이지를 시스템 변수를 이용해 값을 선택할 수 있었지만 기본값을 16KB
- 위의 인덱스 페이지(16KB)는 16 * 1024 / (16 +12) = 585개 저장 가능
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려짐

###### B-Tree 깊이
- 직접 제어할 방법이 없음
- 위의 그림에서 인덱스의 B-Tree 깊이가 3인 경우 최대 2억(585 * 585 * 585)개 정도의 키 값을 담을 수 있음
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고 그 때문에 같은 레코드 건수라 하더라도 B-Tree 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 됨

###### 선택도(기수성)
- 모든 인덱스 키 값 가운데 유니크한 값의 수
- 선택도 = 카디널리티 / 전체 데이터 개수 * 100
- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어짐
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리됨

###### 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업
- 일반적인 DBMS 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 릭는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측
- 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적

#### B-Tree 인덱스를 통한 데이터 읽기
###### 인덱스 레인지 스캔
- 인덱스 풀 스캔과 루스 인덱스 스캔보다 빠른 방법
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 루트 노드에서 시작해 브랜치 노드를 거치고 리프 노드에서 시작 지점을 찾아 순서대로 스캔
- 만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔
- 어떤 방식으로 스캔하든 관계없이 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴
- 인덱스의 리프 노드에서 검색 조건에 일피하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요
  - 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어남
- 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라짐

###### 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됨
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용됨
- 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이지만 일반적으로 효율적인 방식은 아님

###### 루스(Loose) 인덱스 스캔
- 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것
- 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리
- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용

###### 인덱스 스킴 스캔
- MySQL 8.0 버전부터는 옵티마이저가 인덱스의 두 칼럼 중 하나의 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능 도입
- WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 훨씬 넓어짐
- 단점
  - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
  - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

#### 다중 칼럼 인덱스
- 두 개 이상의 칼럼으로 구성된 인덱스
- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있음

#### B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장됨
- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정됨

###### 인덱스의 정렬
- MySQL 8.0 버전부터는 정렬 순서를 혼합한 인덱스도 생성 가능

###### 인덱스 스캔 방향
- 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻음
- 쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수등의 최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만듦

###### 내림차순 인덱스
- MySQL 서버의 InnoDB 스토리지 엔진에서 정순 스캔과 역순 스캔은 페이지 간의 양방향 연결 고리를 통해 전진하느냐 후진하느냐의 차이만 있지만 실제 내부적으로는 InnoDB에서 인덱스 역순 스캔이 정순 스캔에 비해 느릴 수 밖에 없는 이유가 있음
  - 페이지 잠금이 정순 스캔에 적합한 구조
  - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
- 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 병목 현상을 완화하는 데 도움이 됨

#### B-Tree 인덱스의 가용성과 효율성
###### 비교 조건의 종류와 효율성
- 작업 범위 결정 조건: 작업의 범위를 결정하는 조건
- 필터링 조건 또는 체크 조건: 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건
- 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 쿼리의 처리 성능을 높이지는 못함

###### 인덱스의 가용성
- B-Tree의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있음
- 하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가능

###### 가용성과 효율성 판단
- 다음 조건에서는 B-Tree 인덱스 사용 불가
  - NOT-EQUAL로 비교된 경우(<>, NOT IN, NOT BETWEEN, IS NOT NULL)
  - LIKE '%??'(앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
  - 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
  - 문자열 데이터 타입의 콜레이션이 다른 경우
- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  - column_1 칼럼에 대한 조건이 없는 경우
  - column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작은 임의의 값을 의미)
  - column_1 ~ column_(i-1) 칼럼까지 동등 비교 형태('=' 또는 'IN')로 비교
  - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
    - 동등 비교('=' 또는 'IN')
    - 크다 작다 형태('>' 또는 '<')
    - LIKE로 좌측 일치 패턴(LIKE '승환%')

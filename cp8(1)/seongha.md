# Chapter 8 인덱스

인덱스의 특성과 차이는 상당히 중요하며, 물리 수준의 모델링을 할 때도 중요한 요소가 된다. 
아무리 MySQL서버의 옵티마이저가 성능이 개선되었다고 해도 관리자의 역할이 중요하다.
인덱스에 대한 기본지식은 개발자나 관리자에게 매우 중요한 부분이며, 쿼리 튜닝의 기본이 될 것이다. 


# 8.1 디스크 읽기 방식
먼저 자주 언급되는 디스크 읽기 방식 2가지를 알아보고 인덱스를 알아보자. 
- 랜덤 I/O
- 순차 I/O
디스크 같은 장치가 매우 발전했지만, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이다. 
데이터베이스 성능 튜닝의 관건은 어떻게 디스크 I/O 를 줄이느냐가 관건이다. 

## 8.1.1 하드디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
컴퓨터의 모든 장치는 전자식이지만 하드 디스크만 기계식이기에 병목 현상이 일어난다. 
`SSD`는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)을 제거하고 그 대신 플래시 메모리를 장착하고 있다. 그래서 디스크를 회전시키지 않아도 되므로 빠르게 읽고 쓸 수 있다. 또한, 전원이 공급되지 않아도 데이터가 삭제되지 않는다. 
`SSD`는 랜덤 I/O가 하드디스크에 비해 훨씬 빠르다. 데이터베이스 서버는 랜덤 I/O를 통해 데이터를 읽고 쓰는 것이 대부분 이므로 DBMS용 스토리지로 최적이다. 

## 8.1.2 랜덤 I/O와 순차 I/O

랜덤 I/O와 순차 I/O는 디스크를 돌려서 저장된 위치로 이동한 후 데이터를 읽는 것은 똑같다.

그렇다면 어떤 차이가 있을까? 
예를 들어 3개의 페이지 (3*16KB)를 읽는 경우 순차 I/O는 1번의 시스템 콜을 요청하지만, 랜덤 I/O는 3번의 시스템 콜을 요청한다. 따라서 순차는 디스크의 헤드를 1번 움직이고, 랜덤은 3번 움직인다. 
**디스크에 데이터를 읽고 쓰는데 걸리는 시간은 헤더를 옮기는 시간이 결정**한다. 따라서 순차가 랜덤보다 약3배 빠르다.

디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
데이터베이스의 대부분 작업은 이런 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에서는 그룹 커밋이나 바이너리 로그 버퍼나 InnoDB 로그 버퍼 등의 기능이 내장되어 있다. 

랜덤 I/O를 순차 I/O로 변경하는 방법은 많지 않다. 
**따라서 쿼리 튜닝은 랜덤 I/O 횟수를 줄이는 것 자체가 목적이다. **


# 인덱스란? 
DBMS가 데이터베이스 테이블의 모든 데이터를 검색해 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 컬럼들의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어두는 것이다.
DBMS의 인덱스는 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

인덱스는 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해서 항상 정렬된 상태를 유지한다. 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장한다.

인덱스도 SortedList와 마찬가지로 정렬된 상태를 유지하기 때문에 데이터를 저장하는 과정은 복잡하고 느리지만, 조회시에는 매우 빠르다. 
즉, 저장 성능을 희생하여 조회 성능을 높이는 것이다. 


역할별로 인덱스를 구분한다면, 프라이머리 키와 보조키로 구분할 수 있다.
- 프라이머리키: 식별자이고 중복과 Null이 허용되지 않는다.
- 세컨더리 키: 프라이머리키가 아닌 나머지 모든 인덱스 

저장 방식별로 인덱스를 구분하면 대표적으로 B-Tree, Hash가 있다.
- B-Tree: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash: 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.

데이터 중복 허용 여부로 분류하면, 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
인덱스의 기능별로 분류하면, 전문 검색용 인덱스나 공간 검색용 인덱스 등이 있다.

# 8.3 B-Tree 인덱스 
B는 Balanced를 의미한다 균형 트리라는 뜻이다. 
칼럼의 원래 값을 변형하지 않고 정렬된 상태를 유지하는 방식이다. 

![](https://velog.velcdn.com/images/pi1199/post/edec6947-eb74-4be9-957c-ec582d8cffb8/image.png)
## 8.3.1 구조 및 특성

최상위에 루트노드, 가장 하위에 있는 리프노드, 둘다 아닌 모든 노드를 브랜치 노드라고 한다. 
데이터베이스에서 인덱스와 실제 저장된 데이터는 따로 관리되는데, 리프노드는 항상 실제 데이터를 찾아가기 위한 주소값이 저장되어 있다. 

![](https://velog.velcdn.com/images/pi1199/post/225f93d6-6d44-4945-92e6-45b553d9aa21/image.png)

InnoDB의 경우에는 인덱스로 프라이머리키를 찾고, 다시 프라이머리키로 B-Tree를 탐색한다. 이 장단점은 클러스터링 인덱스에서 설명한다. 

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제
추가 삭제가 어떻게 처리되는지 알면 쿼리 성능을 쉽게 예측할 수 있을 것이다. 

### 8.3.2.1 B-Tree 인덱스 키 추가
데이터가 저장될 위치가 결정되면 레코드의 키 값과 레코드의 주소정보를 B-Tree의 리프 노드에 저장한다. 
리프 노드가 꽉찼다면 B-Tree 확장이 필요할 수 있기에 비용이 많이 들 수 있는 것이다.

### 8.3.2.1 B-Tree 인덱스 키 삭제
간단하게 리프노드를 찾아 삭제 마킹 하기만 하면된다. 삭제 마킹이된 인덱스 키 공간은 방치하거나 재활용 할 수 있다. 

### 8.3.2.1 B-Tree 인덱스 키 변경
B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

### 8.3.2.1 B-Tree 인덱스 키 검색
데이터 저장에 비용이 많이 드는 것을 감수하고도 인덱스를 추가하는 이유는 검색 속도 때문이다. 
중요한 점은 인덱스 키 값에 변형이 생기면 B-Tree의 빠른 검색을 이용할 수 없으므로 주의해야 한다.

InnoDB 검색에서는 인덱스가 없으면 불필요하게 많은 레코드를 잠그므로 인덱스 설계가 중요하다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

인덱스를 구성하는 칼럼크기, 레코드 건수, 유니크한 인덱스 값 개수 등에 의해 영향을 받는다. 

### 8.3.3.1 인덱스 키 값의 크기
인덱스도 결국 **페이지** 단위로 관리된다. (버퍼 풀, 디스크 읽고 쓰기에 사용되는 단위)
또한, B-Tree에서 노드를 구분하는 기준도 페이지 단위이다. 

![](https://velog.velcdn.com/images/pi1199/post/6dc17457-8a39-4226-8220-e8d28a1a2ab3/image.png)

B-Tree의 자식노드 개수는 페이지 크기와 키값의 크기에 따라 결정된다. 
인덱스 키가 16KB라고 가정하면 하나의 페이지에 `16*1024 /(16+12) = 585` 개 저장할 수 있다.
키값이 32바이트로 늘어난다면 `16*1024 /(32+12) = 372`개 저장할 수 있다.

즉, 500개의 데이터를 읽는경우 키값이 작으면 1개의 페이지만 읽으면 되지만, 2번째 키값이 큰 경우에는 2개의 페이지를 읽어야하므로 디스크를 읽는 횟수가 늘어나고, 느려지는 현상이 발생한다. 
또한, 인덱스 키값이 커지면 캐시 공간을 많이 차지하므로 캐시할 수 있는 데이터 수도 줄어들어 효율성이 줄어든다. 

### 8.3.3.2 B-Tree 깊이

B-Tree 깊이는 중요하지만 직접 제어할 방법은 없다. 
위에서 보았듯이 인덱스 키값이 커지면 페이지 1개에 담기는 데이터 수가 줄어들고, 따라서 디스크 읽기 횟수도 증가한다. 
또한, 하나의 페이지에 담기는 데이터 수가 줄어들기에 B-Tree의 깊이도 깊어질 수 밖에 없다. 깊이가 깊어지면 디스크 읽기가 더 많이 필요하므로 더 느려진다. 

결론적으로 **인덱스 키는 가능한 작게** 유지하는 것이 좋다. 


### 8.3.3.3 선택도 (기수성)
선택도(기수성)은 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 전체 인덱스 키 값 100개인데, 유니크한 값의 수가 10개라면 기수성이 10이다. 
이러한 기수성이 높으면 높을수록 검색 대상이 줄어들기에 빨라진다. 
인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.

예를 들어 1만개의 데이터인 경우를 보자.
- 유니크 키가 10개인 경우 : 1000개의 데이터를 읽어 1개를 찾는다. 
- 유니크 키가 1000개인 경우 : 10개의 데이터를 읽어 1개를 찾는다.

이처럼 유니크 키의 개수에 따라 불필요한 데이터를 얼마나 읽느냐의 차이가 있다. 

### 8.3.3.4 읽어야 하는 레코드의 건수 

인덱스를 통한 읽기 작업은 보통 4~5배 많은 비용이 발생한다. 
따라서 전체를 읽는 것이 효율적인지 인덱스를 활용하는게 효율적인지는 레코드 건수에 따라 판단해야한다. 
인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 필터링 방식으로 처리하는 것이 효율적이다.



## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

인덱스를 사용하게 유도할지 못하게 할지 판단하려면 MySQL엔진이 어떻게 인덱스를 이용해서 실제 데이터를 읽는지 알아야한다. 
대표적인 3가지 방법을 알아보자

### 8.3.4.1 인덱스 레인지 스캔
가장 대표적이고 빠르다. 
검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 인덱스가 정렬되어 있기에 조건에 따른 레인지 스캔이 가능하다. 
아래 그럼처럼 리프노드를 찾아서 스캔하고 다음 페이지로 넘어갈 때는 링크를 이용해서 넘어간다. (B-Tree탐색 방식 참고)

![](https://velog.velcdn.com/images/pi1199/post/9f71f757-55a6-401e-a257-30038267977b/image.png)

인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 
레코드 한 건 단위로 랜덤 IO가 한 번씩 일어나므로, 인덱스를 통해 데이터 레코드를 읽는 것은 비용이 많이 드는 작업이다. 따라서 인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 방식이다.

- 레인지 스캔의 3단계
1. 인덱스에서 조건을 만족하는 값이 저장된 위치 찾기 (인덱스 탐색)
2. 1번에서 탐색된 위치부터 필요한 만큼 레인지 스캔 (인덱스 스캔)
3. 2번에서 탐색된 인덱스 키와 레코드 주소를 통해 실제 레코드가 저장된 페이지와 데이터를 읽음


3단계가 필요하지 않는 경우도 있는데 이를 **커버링 인덱스** 라고 한다.
커버링 인덱스는 필요한 데이터가 인덱스에 포함되어 있기 때문에 실제 데이터를 조회할 필요가 없다. 따라서 
디스크에 접근하는 랜덤 I/O횟수가 줄어들기 때문에 성능이 빠르다. 


### 8.3.4.2 인덱스 풀 스캔
레인지 스캔과는 달리 인덱스의 처음부터 끝까지 읽는 방법이다. 
인덱스가 (A,B,C)의 복합 인덱스로 설정되어 있을 때, B나 C칼럼으로 검색하는 경우에 인덱스 풀 스캔을 사용한다. 
주로 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있을 때 사용한다. (어댑티브 인덱스인 경우?)
일반적으로 테이블보다 인덱스의 크기가 작기 때문에 테이블 풀스캔 보다 인덱스 풀 스캔이 효율적이다. 


하지만, 인덱스 풀 스캔은 효율적이지 않으며 일반적으로 말하는 인덱스를 생성하는 목적이 아니다. (비효율 적이다) 

![](https://velog.velcdn.com/images/pi1199/post/099ed082-044c-4060-bf20-cc9f040005cc/image.png)

### 8.3.4.3 루스 인덱스 스캔 
오라클의 "인덱스 스킵 스캔"과 같은말이다. 말 그대로 느슨하게 읽는 방법이다. 
인덱스 레인지 스캔과 비슷하게 동작하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 넘어간다. 
GroupBy, Min, Max 함수에 대해 최적화할 때 사용한다. 

인덱스에서 WHERE 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다.

예를들어 아래 쿼리는 dept_no 와 emp_no가 인덱스로 생성도이 있고 정렬도 되어 있다. 
따라서 조건에 맞는 가장 작은 emp_no는 dept_no 로 그룹화 한것의 맨 처음 값을 가져오면 된다. 그이후 값은 불필요하므로 건너 뛴다. 이러한 방식이 루스 인덱스 스캔이다.  
```sql
mysql> SELECT dept_no, MIN(emp_no)
		FROM dept_emp
        WHERE dept_no BETWEEN 'd002' AND 'd004'
        GROUP BY dept_no;
```
![](https://velog.velcdn.com/images/pi1199/post/c356307f-dbbd-489f-8078-6c772d61c195/image.png)


### 8.3.4.4 인덱스 스킵 스캔 

인덱스의 핵심은 값이 정렬되어 있다는 것이다. 이로 인해 인덱스를 구성하는 칼럼 순서는 매우 중요하다. 
```sql
mysql> ALTER TABLE employees
		ADD INDEX ix_gender_birthdate (gender, birth_date);
```        
이 인덱스를 사용하려면 WHERE 조건절에 gender 컬럼에 대한 비교 조건이 필수다.
```
// 인덱스를 사용하지 못하는 쿼리 (인덱스 풀 스캔으로 진행함)
mysql> SELECT * FROM employees WHERE birth_date>='1965-02-01';
        
// 인덱스를 사용할 수 있는 쿼리
mysql> SELECT * FROM employees WHERE gender='M' birth_date>='1965-02-01';
```
이전까지는 위와 같이 인덱스의 순서에 따라 사용이 제한되었다. 
8.0 버전 부터는 이를 해결해주는 인덱스 스킵 스캔이 도입되었다. 

인덱스 스킵 스캔은 먼저 gender의 유니크 키 값을 모두 조회하고, 유니크 키값을 조건으로 추가하여 나머지 where절을 레인지 스캔하는 형식으로 진행한다. 
예를들면 gender = M 인 경우 레인지스캔 1번, gender = F 인경우 레인지스캔 1번 이렇게 동작한다.

단점은 2가지가 있다. 
- 선행 칼럼(gender)의 유니크 값이 적어야 한다. (성능 문제)
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 한다(커버링 인덱스여야 한다)는 점이다. (커버링 인덱스가 아니면 테이블 풀스캔 해야 한다)

```
mysql> SELECT * FROM employees WHERE birth_date>='1965-02-01';
```
![](https://velog.velcdn.com/images/pi1199/post/643a6f50-3b25-4f6f-b97c-e5d44028c0cf/image.png)


## 8.3.5 다중 칼럼 인덱스 
2개 이상의 칼럼으로 인덱스를 생성하는 것을 다중 칼럼 인덱스(복합 인덱스)라고 한다. 
복합 인덱스에서는 칼럼의 순서가 중요하다. 1번 칼럼에 2번 칼럼이 의존하는 형태로 정렬된다. 
예를 들어 아래 그림과 같이 dept_no 가 같아야 emp_no로 정렬되는 형태이다. 
따라서 칼럼 순서가 중요하다. 

![](https://velog.velcdn.com/images/pi1199/post/c52738b0-0985-4976-81f7-e7204e773282/image.png)



## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

정렬 방향에 상관없이 옵티마이저의 실행 계획에 따라 앞에서 또는 뒤에서 읽는 것이 가능하다. 


### 8.3.6.1 인덱스의 정렬 
아래와 같이 인덱스를 오름차순 내림차순으로 생성하는 것이 가능하다. 

```sql
mysql> CREATE INDEX idx_teamname_userscore ON employees (team_name ASC, user_score DESC);
```
#### 8.3.6.1.1 인덱스 스캔 방향 
옵티마이저는 더 효율적, 더 적은 데이터를 읽도록 판단하여 정렬 방향에 관계없이 앞,뒤 효율적인 방향에서부터 탐색을 진행한다. 
예를 들어 오름차순으로 정렬되어 있는데 찾으려는 값이 가장 큰 값과 가깝다면 뒤에서부터 읽어온다. 
![](https://velog.velcdn.com/images/pi1199/post/5140c5a0-1090-4990-989d-90c28624beef/image.png)



하지만 인덱스의 역순으로 읽어오는 것은 정순으로 읽어오는 것보다 느리다. 
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이다. 
- 페이지 내에서 인덱스 레코드가 단방향으로 연결된 구조이다. 

![](https://velog.velcdn.com/images/pi1199/post/2d59c0fa-628e-41da-acb8-b561a9d5077e/image.png)

## 8.3.7 B-Tree 인덱스의 가용성과 효율성 

쿼리의 where 조건이나 group by, order by 절이 어떤 경우에 인덱스를 사용할 수 있고, 어떤 방식으로 사용할 수 있는지 알아야 최적화를 할 수 있다. 


### 8.3.7.1 비교 조건의 종류와 효율성 

다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등비교인지 아니면 크다 작다와 같은 범위 조건인지에 따라 각 인덱스의 활용 형태와 효율이 달라진다. 

작업 범위 결정조건과 필터링 조건이 있다. 복합 인덱스에서 2개의 인덱스로 복합 인덱스를 만들었다면 첫번째가 작업범위 결정조건이고 두번째가 필터링 조건이다. 

### 8.3.7.2 인덱스의 가용성 

B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다는 것이다. 
이러한 정렬 특성이 빠른 검색의 전제 조건이다. 이 때문에 복합인덱스나 like문에서 오른쪽 값이 조건인 경우 쿼리가 느려질 수 있다. 

#### 8.3.7.3 가용성과 효율성 판단 

B-Tree 인덱스 특성상, 작업 범위 결정 조건으로 사용할 수 없는 조건들 (체크 조건으로는 가능)

- NOT-EQUAL로 비교된 경우 (NOT IN, NOT BETWEEN, IS NOT NULL)
WHERE column <> 'N'
WHERE column NOT IN (10,11,12)
WHERE column IS NOT NULL

- LIKE %?? 형태의 문자열 패턴 비교인 경우
WHERE column LIKE '%test‘
WHERE column LIKE '%test%‘
WHERE column LIKE '_test‘

- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
WHERE SUBSTRING(column,1, 1) = 'X'
WHERE DAYOFMONTH(column) = 1

- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
WHERE column = deterministic_function()

- 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
WHERE char_column = 10

- 문자열 데이터 타입의 콜레이션이 다른 경우
WHERE utf8_bin_char_column = euckr_bin_char_column


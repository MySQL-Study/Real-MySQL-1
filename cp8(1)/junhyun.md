# 8.1
시간 순차I/O < 랜덤I/O

ssd도 마찬가지

일반적으로 쿼리튜닝 = 랜덤I/O 줄인다. = 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선한다.

상황에 따라(데이터 웨어하우스, 통계작업) 주로 랜덤I/O를 사용하는 인덱스 레인지 스캔보다는 풀 테이블 스캔(순차I/O이용) 의도적으로 이용할 수 있다.

# 8.2 인덱스란?

칼럼: 해당 레코드 저장 주소

형태로 원하는 결과를 가져올때 사용

칼럼의 값을 주어진 순서로 미리 정렬해 보관함. 빠르게 찾기 위해

sortedList 처럼 항상 정렬을 유지함.

장단점

저장하는 과정이 복잡하지만 빨리 찾을 수 있다.

인덱스가 많은 테이블은 `insert` , `update` , `delete` 처리가 느려진다.

하지만 `select` 는 매우 빠르게 처리 가능하다. select쿼리의 where절에 사용되는 컬럼이라고 모두 인덱스 생성하면 저장성능이 저하되고, 오히려 역효과 생길 수 있다.

인덱스 = 키로 사용

인덱스역할별 구분

Primary Key, Secondary Key(보조키)

Secondary index: 프라이머리키를 제외하고 모든 것, 유니크 인덱스는 프라이머리키와 성격이 비슷하고 대체할 수 있어 대체키라고도 함. 별도로 분류하기도 하고 그냥 세컨더리로 분류하기도 함.

중복허용 non-unique

하용x unique → 명시(create unique index 인덱스이름 on 테이블(컬럼, 컬럼 … );

데이터 저장방식(알고리즘)

대표적으로 B-Tree, Hash

전문검색용인덱스, 공간검색용인덱스

show index from 테이블;

# 8.3 B-Tree인덱스 (Balanced)
구조: 최상위 루트 노드, 그 하위에 자식 노드, 가장 하위에 리프 노드, 중간은 브랜치 노드  
리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 갖고 있다.  
innodb에서는 디폴트로 클러스터링 테이블이 생성됨. 프라이머리 키 순서로 정렬된.  
innodb의 테이블에서는 프라이머리 키가 ROWID역할을 함.  
innodb는 세컨더리 인덱스가 프라이머리키를 주소처럼 사용.  
세컨더리로 바로 찾지 못하고 프라이머리 키 인덱스를 한 번 더 검색 후 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드 읽음.  

## B-Tree 인덱스 키 추가 및 삭제  
새로운 키 값이 추가 될 때는 키 값과 대상 레코드 주소 정보를 리프 노드에 저장한다.  
리프 노드가 꽉 찼으면 리프 노드가 분리 되어야한다. 이런 것 때문에 쓰기 작업 비용 커짐.  
innodb는 필요시 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있음. 프라이머리키나 유니크 인덱스는 중복 체크 필요로 즉시 추가 및 삭제

### 인덱스 키 삭제
삭제는 간단함. 리프노드에서 삭제하면됨.  
삭제에서는 걱정 없음.  

### 인덱스 키 변경
단순 변경 불가능.  
우선 삭제 후, 새로운 키 값을 추가하는 형태.  
innodb 사용되는 테이블 에서는 체인지 버퍼를 활요해 지연 처리.  

### 인덱스 키 검색
빠른 검색을 위해 인덱스 구축함.  
트리 탐색은 select 뿐 아니라 update, delete에서도 해당 레코드를 먼저 검색할 경우 사용됨.  
주의: 이미 변형된 인덱스 키 값은 B-Tree 빠른 검색 사용 못함. 변형되면 B-Tree에 존재하는 값이 아님.  
따라서 함수나 연산을 수행한 결과로 정렬하는 건 B-Tree 장점 이용 못함.
innodb는 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블 레코드 잠금.   
따라서 update, delete 실행 될 때 테이블에 적절한 인덱스가 없으면 불필요하게 많은 레코드 잠금.

## B-Tree 인덱스 사용에 영향을 미치는 요소
B-Tree 인덱스는 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 성능 영향 받음.  

### 인덱스 키 값의 크기
페이지: 디스크 저장 가장 기본 단위, 최소 작업 된위, 버퍼풀에서 버퍼링하는 기본 단위.  
인덱스도 페이지 단위로 관리. 루트와 브랜치, 리프노드 구분 기준이 페이지 단위.  
B-Tree는 자식 노드 개수 가변적.  
그럼 자식 몇개 까지?  
인덱스 페이지 크기와 키 값의 크기에 따라 결정됨. (16KB 기본)  
16 * 1024/(키값크기 + 자식노드주소크기(12바이트)) -> 한 페이지에 인덱스 키를 저장할 수 있는 개수.  
키값 커지면 디스크 읽는 회수 늘어남. 느려짐.  
키값 커지면 메모리에 캐시할 레코드 수 줄어듬.  

### B-Tree 깊이
깊이 중요한데 제어할 방법 없음.  
키값이 커지면, 깊이 깊어지고, 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수 적어지고, 깊이가 깊어져서 디스크 읽기 더 많이 필요.  
인덱스 키 값의 크기는 작게 만드는 게 좋음.  

### 선택도(기수성)
선택도 = 기수성  
모든 인덱스 키 값 중 유니크한 값의 수.  
인덱스는 선택도가 높을수록 빠름.  

### 읽어야 하는 레코드의 건수
인덱스 통해 레코드 읽는 것은 바로 읽는 것 보다 높은 비용.  
100만건 중 50만건 읽을 때 모두 읽어서 50만건 버릴 건지, 인덱스로 50만건만 읽을 건지 판단해야함.  
일반적으로 인덱스를 통해 1건 = 직접 레코드 1건의 4-5배 비용. 
인덱스를 통해 읽어야할 건수가 전체 레코드의 20%-25% 이상일때는 인덱스 사용하지 않고 직접 필요한 레코드만 가려내는 방식이 좋음.  

## B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레이지 스캔
대표적 방식  
검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식.  
시작할 위치를 찾으면 리프 노드의 레코드만 순서대로 읽음.  
스캔을 멈춰야 하 위치면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝냄.  
해당 인덱스를 구성하는 컬럼의 정렬된 상태로 레코드 가져옴.  
별도 레코드 정렬이 아니라 인덱스에서 정렬되어 있기 때문.  

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. `인덱스 탐색`
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. `인덱스 스캔`
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.  

쿼리에 따라 3번이 필요하지 않을 수도 있는데 이를 커버링 인덱스라 한다.(디스크 안 읽어 성능 좋음)  

### 인덱스 풀 스캔
처음부터 끝까지 모두 읽음.  
쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 사용됨.  
리프노드의 처음부터 끝까지 스캔. 테이블 풀 스캔보다는 효율적. 레코드를 읽을 필요가 없기 때문.  

### 루스 인덱스 스캔
중간에 필요하지 않은 인덱스 키 값은 무시하고 그 다음으로 넘어감.  
group by, max(), min() 함수에 대해 최적화를 하는 경우에 사용됨.  

### 인덱스 스킵 스캔
인덱스를 구성하는 칼럼의 순서가 매우 중요.  
a,b순서로 인덱스 있을때  
b만 이용할때 옵티마이저가 a를 건너뛰고 b만으로 인덱스 검색이 가능하게 해주는 방식.  
where에도 사용 가능  

단점  
- a같은 게 유니크 값이 적어야하고, 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야함.

## 다중 칼럼 인덱스
2개 이상 칼럼을 포함하는 인덱스  
인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있음.  
두 번째 칼럼을 첫 번째 칼럼이 똑같은 레코드에서만 의미있음.  
칼럼 순서가 중요.  

## B-Tree 인덱스의 정렬 및 스캔 방향
### 인덱스의 정렬
인덱스 생성할때 오름, 내림 정할 수 있다.  
각각 오름, 내름 할 수 있음.  

### 인덱스 스캔 방향
인덱스는 오름차순으로 정렬되어있어도 역순 정렬을 통해 역순으로 읽어올 수 있음.    
### 내림차순 인덱스 
실제 내부적으로 역순 스캔이 느릴 수 밖에 없다.  
- 잠금이 정순에 적합.
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

자주 사용되는 순서로 인덱스 정렬하는 것도 방법.  
## B-Tree 인덱스의 가용성과 효율성
잘 고려해 써라.

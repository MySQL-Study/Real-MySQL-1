### 4.1 MySQL 엔진 아키텍쳐

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fba6Jtb%2FbtrCtvpA6Ac%2FGEmkstU3hKbnfXM8kjqyOk%2Fimg.png)

**MySQL 엔진**

커넥션 핸들러 + SQL 파서 및 전처리기, 옵티마이저 등

**스토리지 엔진**

디스크 스토리지 write, read

여러개 동시 사용 가능하며 특정 테이블이 사용할 엔진 정의 가능

**핸들러 API**

스토리지 엔진에 쓰기, 읽기 요청을 할 때 사용하는 API

`SHOW GLOBAL STATUS LIKE Handler%;` : 핸들러 API를 통해 데이터 작업이 얼마나 있었는지 확인 가능

**MySQL 스레딩 구조**

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb78WFz%2FbtrCumzIwon%2FdPBhyBQhl4z9wtWfkUAir1%2Fimg.png)

스레드 기반 작동

- 포그라운드 스레드
- 백그라운드 스레드

**포그라운드 스레드(클라이언트 스레드)**

클라이언트가 요청하는 쿼리 문장 처리

접속된 클라이언트 수만큼 존재하며 커넥션을 종료하면 스레드 캐시로 돌아감

thread_cache_size 시스템 변수에 따라 종료 or 캐시로 돌아갈지 결정

데이터를 MySQL 데이터 버퍼나 캐시로부터 가져오지만 없으면 디스크의 데이터나 인덱스 파일로부터 읽어옴

MyISAM : 사용자 - 디스크 : 포그라운드가 처리

InnoDB : 사용자 - 데이터버퍼 : 포그라운드, 데이터버퍼 - 디스크 : 백그라운드

**백그라운드 스레드**

쓰기는 지연 가능, 읽기는 지연 불가능 

⇒ InnoDB : 쓰기 작업을 버퍼링해서 처리

⇒ MyISAM : 포그라운드 스레드가 쓰기 작업까지 처리

**메모리 할당 및 사용구조**

![image](https://velog.velcdn.com/images/semi-cloud/post/5323b203-d854-4b6b-a647-45168d1f3901/image.png)

**글로벌 메모리 영역**

모든 메모리 공간이 MySQL 서버가 시작되면서 운영체제로부터 할당됨

하나의 메모리 공간만 할당(클라이언트 스레드 수와 무관)

**InnoDB Buffer Pool**

데이터와 인덱스를 디스크에서 읽기 전에 메모리에 캐싱

**Redo Log Buffer**

InnoDB의 트랜잭션 로그를 디스크에 기록하기 전에 임시 저장

**로컬(세션) 메모리 영역**

클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역

클라이언트 스레드별로 독립적으로 할당되며 공유되지 않음

**Sort Buffer**

MySQL이 데이터를 정렬할 떄 사용하는 메모리 공간

**Join Buffer**

Nested Loop join을 처리할 때 사용하는 메모리 공간

**플러그인 스토리지 엔진 모델**

핸들러

- 스토리지 엔진을 조정하기 위해 사용
- 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하기 위해서 필요
- Group By 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리

스토리지 엔진

- SHOW ENGINES를 통해 지원되는 스토리지 엔지 확인 가능
- support 컬럼을 통해 활성화 상태인지 아닌지 등을 알 수 있음

**컴포넌트**

- 기존의 플러그인 아키텍처를 대체
- 기존 플러그인의 단점
    - MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신 불가
    - 캡슐화 안됨
    - 상호 의존 관계 설정이 불가해 초기화 어려움

**쿼리 실행 구조**

쿼리 파서

- 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만듦
- 기본 문법 오류 검출

전처리기

- 뭐리 파서에서 만든 트리를 기반으로 구조적인 문제점 확인
- 존재하지 않거나 권한문제가 있는 개체의 토큰 검출

옵티마이저

- 쿼리 문장을 빠르고 저렴한 비용으로 처리

실행 엔진

- 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하거나 사용자에게 넘김

핸들러(스토리지 엔진)

- 데이터를 디스크에 쓰거나 읽어옴
- 스토리지 엔진을 의미

**쿼리 캐시**

실행 결과를 메모리에 캐시하고 동일 SQL 쿼리가 실행될 경우 테이블을 읽지 않고 결과를 반환

그러나 데이터가 변경되면 저장된 캐시 중 관련된 것들을 모두 삭제해야하고 이로 인해 성능저하와 버그가 발생함

따라서 쿼리캐시를 제거하는 것이 더 좋음

**스레드 풀**

사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많아도 CPU가 제한 개수의 스레드 처리에만 집중할 수 있게하여 서버의 자원 소모를 줄이기 위함

스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우 쿼리 처리가 더 느려질 수 있음 그러나 잘 작동하면 컨텍스트 스위치를 줄여 오버헤드를 낮출 수 있음

CPU 코어의 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는데 좋음

MySQL 서버가 처리해야할 요청이 생기면 스레드 풀로 처리를 이관하는데 만약 스레드 풀이 처리 중인 작업이 있는 경우 thread_pool_oversubscribe 시스템 변수에 설정된 개수만큼 추가로 더 받아 들여서 처리함(만약 해당 값이 너무 커지면 스레드 풀이 비효율적으로 동작할 수 있음)

**트랜잭션 지원 메타데이터**

시스템 테이블 : MySQL 서버가 작동하는데 기본적으로 필요한 테이블들을 묶은 것

시스템 테이블과 딕셔너리 정보를 모두 mysql DB에 저장

딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선 → 서버가 종료되어도 완전 실패 or 성공으로 정리

### 4.2 InnoDB 스토리지 엔진 아키텍쳐

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FO6sBJ%2FbtsvjglYzhX%2F9kfCfjstxQno0KKlBpa8o0%2Fimg.png)

**프라이머리 키에 의한 클러스터링**

InnoDB의 모든 테이블은 프라이머리 키 값의 순서대로 디스크에 저장됨(프라이머리키 기준 클러스터링 → 레인지 스캔이 빠름)

모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용

쿼리 실행 계획에서 프라이머리 키는 다른 보조 인덱스에 비해 비중이 높게 설정됨(MyISAM에서 프라이머리키는 유니크 제약을 가진 세컨더리 인덱스일 뿐)

**외래 키 지원**

외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요

변경시 부모, 자식 테이블에 데이터가 있는지 체크 → 잠굼이 여러 테이블로 전파, 데드락 발생 가능

foreign_key_checks 변수를 off로 설정해 외래 키 체크작업을 멈출 수 있음

**MVCC**

undo log를 통해 잠금을 사용하지 않는 일관된 읽기를 제공

테이블의 데이터를 update할 경우

- 디스크 데이터 파일에는 체크포인트나 InnoDB의 write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고, 아닐 수도 있음
- commit이나 롤백이 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회한다면 → 시스템 변수에 설정된 격리 수준에 따라 조회 위치가 다름
    - READ_UNCOMMITTED라면 : 변경된 상태의 데이터 반환
    - READ_COMMITTED이상이라면 : 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터 반환
- MVCC : 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 데이터가 선별적으로 보여짐

정리 : update 실행 후 InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경되고, 기존 데이터는 언두영역으로 복사됨

commit 할 경우 : 변경 작업 없이 지금의 상태를 영구적인 데이터로 만듦

rollback 할 경우 : 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 복구하고 언두 영역의 내용을 삭제(언두 영역을 필요로 하는 트랜잭션이 없을 경우)

**잠금 없는 일관된 읽기**

MVCC를 통해 잠금 없는 읽기 작업 수행 → 다른 트랜잭션이 가진 잠금을 기다리지 않고 읽기 작업 가능

⇒ 특정 사용자가 레코드 변경 + No 커밋 → 이 트랜잭션이 다른 사용자의 select 작업을 방해하지 않음(잠금 없는 일관된 읽기)(변경 없는 데이터를 읽기 위해 언두 로그 사용)

가능한 빠른 롤백이나 커밋을 통해 트랜잭션을 완료시켜 오랜시간 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 유지하는 경우를 방지

**자동 데드락 감지**

트랜잭션의 언두 로그 양을 통해 어떤 트랜잭션을 강제 종료할 것인지 판단

언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상(언두 레코드가 적다 = 언두 처리 할 내용이 적다)

- 언두 레코드 : 트랜잭션이 데이터 변경 작업 수행시 변경 전 데이터 저장 공간
- 트랜잭션 롤백 : 트랜잭션 작업 취소 후 데이터베이스를 이전 상태로 되돌리는 것

동시 처리 스레드가 많아지거나 트랜잭션이 가진 잠금 개수가 많아지면 데드락 감지 스레드가 느려지고, 서비스 처리 중인 스레드는 대기하면서 서비스에 악영향을 끼침

**자동화된 장애 복구**

InnoDB 데이터 파일은 MySQL 서버가 시작될 때 항상 자동 복구 수행

복구 불가 손상이 있다면 서버 종료(innodb_force_recovery 시스템 변수를 설정해 서버 시작)

mysqldump를 이용해 데이터를 백업하고 db와 테이블을 다시 생성

## **9.3 고급 최적화**

서버의 옵티마이저는 통계 정보와 옵티마이저 옵션을 결합하여 최적의 실행 계획을 수립했습니다. 이러한 옵션은 크게 조인 관련 옵션과 스위치로 구분할 수 있습니다.

### **옵티마이저 스위치 옵션**

- 스위치 옵션은 `optimizer_switch` 시스템 변수를 통해 제어했습니다. 이는 글로벌과 세션별 모두 설정할 수 있는 변수이므로 서버 전체 및 커넥션에 대해 설정이 가능했습니다.

### **MRR과 배치 키 액세스**

- `Multi-Range Read`는 조인 시 드라이빙 테이블에서 하나의 레코드를 읽어 드리븐 테이블의 일치하는 레코드를 찾는 방식입니다. 이를 네스티드 루프 조인이라고 불렀습니다.
- MySQL 엔진이 내부적으로 조인을 처리했지만, 레코드를 검색하고 읽는 것은 스토리지 엔진이 담당했습니다.
- MySQL 서버는 이를 최적화하기 위해 조인 대상 테이블 중 하나로부터 레코드를 읽어 조인 버퍼에 버퍼링했습니다.
- 드라이빙 테이블의 레코드를 읽어 조인을 즉시 실행하지 않고 대상을 버퍼링함으로써, 스토리지 엔진은 데이터 페이지에 정렬된 순서로 접근하여 디스크 읽기를 최소화할 수 있었습니다.
- 이러한 방식을 MRR이라 했으며, 실행 중인 조인 방식을 BKA(Batched Key Access) 조인이라고 불렀습니다.

### **블록 네스티드 루프 조인**

- 서버의 대부분 조인은 네스티드 루프 조인이었으며, 이는 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이었습니다.
- 네스티드 루프 조인과의 차이점은 조인 버퍼의 사용 여부와 조인에서 드라이빙 테이블과 드리븐 테이블의 조인 순서였습니다.

실행 과정은 다음과 같았습니다

1. `dept_emp` 테이블의 `ix_fromdate` 인덱스를 이용해 레코드를 검색했습니다.
2. 조인에 필요한 나머지 칼럼을 모두 `dept_emp` 테이블로부터 읽어서 조인 버퍼에 저장했습니다.
3. `employees` 테이블의 프라이머리 키를 이용해 조건에 만족하는 레코드를 검색했습니다.
4. 검색된 결과에 캐시된 조인 버퍼의 레코드를 결합하여 반환했습니다.
- 주목할 점은 조인 버퍼가 사용되는 쿼리에서는 조인 순서가 거꾸로인 것처럼 실행되었다는 것입니다.
- `employee` 테이블을 기준으로 병합했다는 의미였으며, 이로 인해 결과의 정렬 순서가 흐트러질 수 있었습니다.

### **인덱스 컨디션 푸시다운**

인덱스 컨디션 푸시다운은 쿼리의 처리 성능을 크게 향상시킬 수 있는 중요한 기능입니다.

- `last_name='Action'` 조건으로 인덱스 레인지 스캔 후 레코드를 찾고, `first_name LIKE '%sal'` 조건을 파악하는 과정에서, 첫 번째 조건에 부합하는 레코드가 3건이더라도 10만 건 중 1건만 사용한다면 불필요한 작업이 많이 발생할 수 있었습니다.
- 이러한 문제를 해결하기 위해 MySQL 5.6 버전부터는 인덱스를 범위 제한 조건으로 사용하지 못하더라도, 인덱스에 포함된 칼럼의 조건이 있다면 모두 모아서 스토리지 엔진으로 전달할 수 있도록 핸들러 API가 개선되었습니다.
    - 이는 인덱스를 이용해 최대한 필터링을 완료하여 1건의 레코드만 테이블 읽기를 수행할 수 있게 되었다는 의미입니다.
- 인덱스 비교 작업은 실제 InnoDB 스토리지 엔진이 수행하지만, 테이블에서의 비교 작업은 MySQL 엔진이 수행하는 작업이었습니다.
    - 이러한 개선은 고도의 기술력을 요하는 기능은 아니지만, 쿼리의 성능을 수십 배로 향상시킬 수 있는 매우 중요한 기능이 되었습니다.

### **인덱스 확장**

- `use_index_extensions` 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션입니다.
- 이는 보조 인덱스의 효율성을 높이고 쿼리 성능을 개선하는 데 도움을 주었습니다.

### **인덱스 머지**

- 일반적으로 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립했습니다.
- 하지만 인덱스 머지 옵션을 통해 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리할 수 있었습니다.
    - 이는 각각의 조건이 서로 다른 인덱스를 활용할 수 있고, 그 조건을 만족하는 레코드가 많을 것으로 예상될 때 선택되었습니다.

### **인덱스 머지 - 교집합**

- 두 개의 칼럼에 각각의 인덱스가 존재할 때 인덱스 머지 최적화 기법을 사용할 수 있었습니다.
    - 예를 들어, A를 만족하는 레코드가 253건, B를 만족하는 레코드가 10,000건이며, A,B를 모두 만족하는 레코드가 14건인 경우, 옵티마이저는 각 인덱스를 검색해 두 결과의 교집합만을 찾아 반환함으로써 효율적인 처리가 가능했습니다.

### **인덱스 머지 - 합집합**

- 인덱스 머지 합집합은 2개 이상의 조건이 각각의 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용하는 최적화 방식이었습니다.
    - 이는 각각의 인덱스를 통해 검색된 결과를 하나로 합쳐 최종 결과를 만들어내는 방식으로 동작했습니다.

### **인덱스 머지 - 정렬 후 합집합**

- Union 알고리즘은 두 결과 집합의 중복을 제거하기 위해 정렬된 결과가 필요한 경우에 사용되었습니다.
    - 이는 여러 인덱스를 사용한 검색 결과에서 중복된 레코드를 효과적으로 제거하면서도 정렬된 상태를 유지할 수 있게 해주는 중요한 최적화 방식이었습니다.

### **세미 조인**

- 세미 조인은 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리였습니다.
    - 이는 효율적인 쿼리 처리를 위한 중요한 최적화 방식이었습니다.

### **테이블 풀-아웃**

- 테이블 풀-아웃은 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화였습니다.
    - 이는 서브쿼리 최적화가 도입되기 전부터 DBA들이 수동으로 쿼리를 튜닝하던 대표적인 방법이었습니다.

### **퍼스트 매치**

- First Match 최적화 전략은 IN 형태의 세미 조인을 EXISTS 형태로 튜닝하는 것과 비슷한 방법으로 실행되었습니다.
    - 이 방식은 조건을 만족하는 첫 번째 레코드만을 찾아 처리함으로써 쿼리의 효율성을 높일 수 있었습니다.

### **루스 스캔**

- 루스 스캔은 GROUP BY 최적화 방법에서의 루스 인덱스 스캔과 비슷한 읽기 방식이었습니다.
    - 예를 들어, 루스 인덱스 스캔을 통해 유니크한 `dept_no`만 읽어 부서 테이블을 조회한다면 효과적으로 쿼리를 실행할 수 있었습니다. 이는 불필요한 데이터 읽기를 최소화하여 성능을 향상시켰습니다.

### **구체화**

- 구체화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화하는 방식이었습니다. 여기서 구체화란 내부 임시 테이블을 생성한다는 것을 의미했습니다.
    - 이 방식은 복잡한 서브쿼리를 효율적으로 처리할 수 있게 해주었습니다.

### **중복 제거**

- 중복 제거는 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔 실행하고 마지막에 중복된 레코드를 제거하는 방법이었습니다.
    - 이 방식은 때로는 단순하지만 효과적인 최적화 방법이 될 수 있었습니다.

### **컨디션 팬아웃**

- 컨디션 팬아웃에서는 조인을 실행할 때 테이블의 순서가 쿼리의 성능에 매우 큰 영향을 미쳤습니다.
    - 이러한 이유로 옵티마이저는 여러 테이블이 조인되는 경우 가능한 일치하는 레코드 건수가 적은 순서대로 조인을 실행했습니다. 이는 전체적인 쿼리 실행 시간을 최소화하는데 큰 도움이 되었습니다.

### **파생 테이블 머지**

- 파생 테이블 머지는 서버 내부적으로 임시 테이블이 만들어질 때 발생할 수 있는 성능 저하를 방지하기 위한 최적화 방식이었습니다.
- 레코드 건수가 많아지면 임시 테이블이 디스크에 저장되므로, 이러한 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화가 도입되었습니다.

### **인비저블 인덱스**

- 인비저블 인덱스는 인덱스의 가용 상태를 제어할 수 있는 기능이었습니다. 이를 통해 인덱스의 효율적인 관리와 테스트가 가능해졌습니다.

### **스킵 스캔**

- 인덱스의 핵심은 정렬이었으며, 이로 인해 인덱스 구성 칼럼의 순서가 매우 중요했습니다.
    - (A, B, C) 칼럼으로 구성된 인덱스는 B, C로 구성된 조건에 활용되기 어려웠지만, 인덱스 스킵 스캔은 제한적이나마 이러한 제약 사항을 뛰어넘을 수 있는 최적화 기법이었습니다.
- 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼만으로도 인덱스를 이용한 쿼리 성능 개선이 가능했습니다.
- 옵티마이저는 테이블에 존재하는 모든 선행 칼럼 값을 가져와 조건이 있는 것처럼 최적화했습니다.
- 다만 선행 칼럼이 매우 다양한 값을 가지면 비효율적일 수 있었지만, 소수의 유니크한 값이라면 충분히 활용할 수 있었습니다.

### **해시 조인**

해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리되었습니다.

- 빌드 단계에서는 조인 대상 테이블 중 레코드 건수가 적어 해시 테이블로 만들기 용이한 테이블을 골라 메모리에 해시 테이블을 생성했습니다.
    - 이때 사용되는 원본 테이블을 빌드 테이블이라고 불렀습니다. 프로브 단계에서는 나머지 테이블의 레코드를 읽어 해시 테이블의 일치 레코드를 찾는 과정을 수행했습니다.
- 해시 조인은 높은 성능을 보였지만, 첫 번째 레코드를 찾는 데에는 상대적으로 긴 시간이 걸렸습니다.
- 따라서 해시 조인 쿼리는 최고 스루풋 전략에 적합했으며, 네스티드 루프 조인은 최고 응답 속도 전략에 적합했습니다.

### **인덱스 정렬 선호**

- 옵티마이저는 ORDER BY 혹은 GROUP BY를 인덱스를 사용해 처리 가능한 경우, 쿼리 실행 계획에서 인덱스의 가중치를 높이 설정해 실행되었습니다.
- 그러나 두 개의 인덱스 중 가끔 잘못된 실행 계획으로 비효율적인 인덱스가 선택될 수 있었습니다.
- 이전에는 이런 경우를 방지하기 위해 특정 인덱스를 사용하지 못하도록 힌트를 사용했습니다.
- 하지만 이후에는 인덱스에서 ORDER BY를 위한 인덱스에 너무 많은 가중치를 부여하지 않도록 하는 옵션이 추가되어 더욱 효율적인 쿼리 최적화가 가능해졌습니다.
# 9.3 고급 최적화
옵티마이저가 실행 계획을 수립할때 통계 정보 + 옵티마이저 옵션 -> 최적의 실행 계획 수립.  
옵티마이저 옵션 = 조인 관련 옵티마이져 옵셔 + 옵티마이저 스위치

## 9.3.1 옵티이마이저 스위치 옵션
`optimizer_switch` 시스템 변수로 제어. 여러 개의 옵션을 세트로 묶어서 설정.  
각각 옵티마이저 스위치 옵션은 default on off 중 하나 선택.  
글로벌, 세션별 모두 설정 가능.  
![Image](https://github.com/user-attachments/assets/e52f6703-a8b7-4987-aa5c-ceaf64e1c824)

### 9.3.1.1 MRR과 배치 키 액세스
MRR: Multi-Range Read.  
네스티드 루프 조인 : 드라이빙 테이블의 레코드를 한 건읽어 드리븐 테이블의 일치하는 레코드를 찾아 조인. 기존 방식. 이러면 스토리지 엔진에서 최적화 불가.  
이런 단점 극복하고자  
조인 대상 테이블 중 하나로부터 레코드를 읽어 조인 버퍼에 버퍼링함.  
드라이빙 테이블의 레코드를 읽어 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링 함.  
조인 버퍼에 레코드가 가득 차면 비로소 MySQL 엔진은 버퍼링된 레코드르르 스토리지 엔진으로 한 번에 요청.  
스토리지 엔진은 읽어야할 레코드들을 데이터 페이지에 정렬된 수서로 접근해 디스크의 데이터 페이지 읽기 최소화.  

이러한 읽기 방식을 `MRR`이라고 한다. 이것을 이용한 조인 = BKA(Batched Key Access)  
BKA 조인 최적화는 기본적으로 비활성화돼 있음. 부가적인 정렬 작업이 필요해져 오히려 안 좋을 수도 ~  

### 9.3.1.2 블록 네스티드 루프 조인
대부분 조인 = Nested Loop Join(이중 루프 같음)  
- 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식.  

네스티드 vs 블록 네스티드  
가장 큰 차이  
조인 버퍼 사용 여부.  
조인에서 드라이빙 테이브로가 드리븐 테이블이 어떤 순서로 조인되는냐.  

조인 알고리즘에서 `Block` 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐음.  
조인 쿼리의 실행 계획에서 Extra에 `Using join buffer`라고 표시되면 그 실행 계획은 조인 버퍼를 사용했다는 것.  

조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하며 처리됨.  
즉 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블은 여러 번 읽음.  
옵티마이저는 드리븐 테이블 풀스캔을 피하기 위해 인덱스를 사용할 수 있게 실행 계획 수립.  

드리븐 테이블 풀스캔 피할 수 없으면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리.  
이때 사용되는 메모리의 캐시를 `조인 버퍼`라고 함.  
join_buffer_size 시스템 변수로 크기 제한 가능.  
조인 완료되면 버퍼 바로 해제  

```sql
SELECT * 
FROM dept_emp de, employees e 
WHERE de.from_date>'1995-01-01' AND e.emp_no<109004;
```
1. dept_emp 테이블에서 from_date칼럼의 인덱스를 통해 조건 만족하는 레코드 검색.
2. 조인에 필요한 나머지 칼럼을 모두 dept_emp 테이블에서 읽고 조인 버퍼에 저장.
3. employees 테이블에서 pk를 이용해 조건을 만족하는 레코드 검색.  
4. 3번에서 검색된 결과를 조인 버퍼에 저장되어있던 정보와 join처리하여 결과 반환.  

드라이빙 테이블 결과는 조인 버퍼에 담아두고, 드리븐테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드 찾는 방식.  
일반적으로는 드라이빙 테이블의 순서에 의해 결정되지만 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있음.  
 
### 9.3.1.3 인덱스 컨디션 푸시다운
5.5 버전까지 인덱스를 범위 제한 조건으로 사용하지 못하는 조건은 MySQL 엔진이 스토리지 엔진으로 아예 전달해주지 않았음.  
5.6 부터는 인덱스를 범위 제한 조건으로 사용하지 못하더라도 인덱스에 포함된칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러API가 개선됐다.  
인덱스 컨디션 푸쉬다운 쿼리 성능 아주 향상시킬 수 있음.  
SET optimizer_switch='index_condition_pushdown=on'; 권장  

### 9.3.1.4 인덱스 확장
`use_index_extensions`  
옵티마이저 옵션은 innodb 엔진을 사용하는 테이블에서 세컨덛리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지 결정하는 옵션.  
PRIMARY_KEY (a, b),  
KEY ix (c)  
처럼 되어있으면 마치 (a, b, c)인덱스가 있는 것처럼 사용 가능.  
그래서 mysql서버도 이걸 인지하고 실행 계획을 수립하도록 개선됨.  

### 9.3.1.5 인덱스 머지
보통은 테이블별로 하나의 인덱스만 사용하도록 실행 계획 수립.  
인덱스 머지 사용하면 2개 이상의 인덱스를 이용해 쿼리 처리.  
where조건에 각각이 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드들이 많은 경우 사용  

머지 방식에 따라 3가지 방식  

### 9.3.1.6 인덱스 머지 - index_merge_intersection(교집합)
실행계획 extra에 `Using intersect(index1, index2)` 표시됨.  

### 9.3.1.7 인덱스 머지 - index_merge_union(합집합)
where절에 2개 이상의 조건이 각각 인덱스 사용하되 or연산자로 연결된 경우
실행계획 extra에 `Using union(index1, index2)` 표시됨.  
합집합 가져옴 여기에서 어떻게 중복 제거 했을까?  
각각의 컬럼의 검색 결과는 이미 pk로 정렬되어있음.  
그래서 두집합에서 하나씩 가져와 비교하며 중복된 것을 정렬 없이 걸러냄.  (우선순위 큐 이용)  

### 9.3.1.8 인덱스 머지 - index_merge_sort_union(정렬 후 합집합)
만약 인덱스 머지 작업 중 결과의 정렬이 필요한 경우 sort union 알고리즘 사용함.  
인덱스 머지 최적화에서 중복 제거를 위해 강제로 정렬 수행  
extra에 using sort_union  

### 9.3.1.9 세미 조인
다른 테이블과 실제 조인 수행하지 않고, 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크  

"= (subquery)" "IN(subquery)" 형태의 세미 조인 쿼리
- 세미 조인 최적화
- IN-toEXISTS 최적화
- MATERIALIZATION 최적화

"<> (subquery)" "NOT IN(subquery)" 형태의 안티 세미 조인 쿼리
- IN-toEXISTS 최적화
- MATERIALIZATION 최적화

세미조인 최적화 최적화 전략들
- Table Pull-out
- Duplicate Weed-out
- First Match
- Loose Scan
- Materialization

### 9.3.1.10 Table Pull-out
세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성하는 형태의 최적화.  
- 세미 조인 서브쿼리에서만 사용 가능.
- 서브쿼리 부분이 unique 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능.
- 이걸 적용하더라도 기존 쿼리에서 가능했던 최적화 방법이 사용 불가능한 것이 아니므로 가능한 최대한 활용
- 테이블을 아우터 쿼리로 가져와 조인으로 풀어쓰는 최적화 수행, 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체 없어짐.
- 이제는 서브쿼리를 조인으로 풀어서 사용할 필요가 없다. 알아서 해줌.

### 9.3.1.11 퍼스트 매치
IN (subquery) -> EXISTS (subquery)로 튜닝한 것과 비슷.  
explain에서 id칼럼이 1로 동일함. 이 역시 조인으로 처리됨.  
extra에 `FirstMatch(e)` 표시됨.  
일치하는 첫번째 레코드 1건만 찾음.  
- 서브쿼리에서 하나의 레코드만 검색되면 더이상의 검색을 멈추는 단축 실행 경로이기 때문에 firstmatch 에서 서브쿼리는 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다. 
- 실행 계획의 extra 항목에 FirstMatch(table-N)라고 표시된다.
- 상관 서브쿼리에서도 사용될 수 있음.
- GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용할 수 없음.

### 9.3.1.12 loose scan







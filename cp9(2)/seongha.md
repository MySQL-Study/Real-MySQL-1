# 9.3 고급 최적화
MySQL 옵티마이저는 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립한다. 
여기서 옵티마이저 옵션은 크게 조인과 관련된 옵티마이저 옵션과 옵티마이저 스위치로 구분할 수 있다.

## 9.3.1 옵티마이저 스위치 옵션

- 옵티마이저 스위치 옵션은 optimizer_switch 시스템 변수를 이용해서 제어한다. 
- 옵티마이저 스위치 마다 default, on, off 중 하나로 설정할 수 있다. (기본값, 활성, 비활성)
- 옵티마이저 스위치는 세션, 글로벌 모두 적용가능한 시스템 변수이다. 

옵션 목록은 p.318~319 참고

### 9.3.1.1 MRR과 배치 키 액세스
MRR은 `Multi-Range Read`를 줄여서 부르는 이름이다. 
Nested Loop Join 방식은 드라이빙 테이블에서 레코드를 읽고, 드리븐 테이블의 레코드를 조인시키는 방식이었다. MySQL엔진이 join을 처리하고 레코드를 읽는 것은 스토리지 엔진이므로 읽기만 담당하는 스토리지 엔진에서는 아무런 최적화를 할 수 없다. 

이를 보완하기 위해 드라이빙 테이블에서 레코드를 읽고 바로 드리븐 테이블과 조인하는 것이 아니라, 조인 버퍼에 해당 드라이빙 레코드를 임시 저장해놓고, 버퍼가 다 찼을 때 실제 조인을 수행하도록 개선되었다.
이렇게 하면 스토리지 엔진은 읽어야할 레코드들을 페이지 순으로 정렬해서 읽으면 되므로 디스크 I/O가 많이 줄어들게 된다. 이것이 MRR 이다. 

### 9.3.1.2 블록 네스티드 루프 조인
`block nested_loop join` 의 차이점은 `조인 버퍼 사용 여부`와 어떤 순서로 드라이빙 테이블과 드리븐 테이블이 조인되는지이다. 

대부분의 조인은 nested_loop join을 수행하는데 조인 연결 조건이 되는 칼럼에 모두 인덱스가 있어야 사용가능하다. 드리븐 테이블에서 참고할 인덱스가 없으면 결국 풀 스캔 하게 된다.

어떤 방식으로도 드리븐 테이블의 테이블 풀스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블의 레코드를 메모리에 캐시하고, 드리븐 테이블과 메모리에 캐시된 내용을 조인하여 처리한다. 
이 메모리 캐시를 조인 버퍼라고 한다. 
조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다

### 9.3.1.3 인덱스 컨디션 푸시다운 
```SQL
Alter table employees add index ix_lastname_firstname (last_name, first_name);

select * from employees where last_name='Acton' and first_name like '%sal';
```
위의 Select 쿼리에서 `index_condition_pushdown`을 off 로 설정하면 last_name을 기준으로 인덱스로 검색하고, first_name like '%sal' 조건은 레코드에 직접 접근해서 검사를 한다.
-> MySQL엔진에서 last_name을 처리하고, first_name은 스토리지 엔진이 처리해서 불필요하게 데이터를 2번씩 읽어서 처리해야 했다. 

그러나 `index_condition_pushdown`을 on으로 설정하면 index 내에서 비교를 수행하고 비교한 대상 레코드에만 접근해서 데이터를 가져올 수 있다.
-> 스토리지 엔진으로 두가지 조건 모두를 전달하여 한번에 검색 가능하다. 

고도의 기술력을 필요로하는 기능은 아니지만, 잘쓰면 쿼리 성능을 몇십배 향상시킬 수 있다.


### 9.3.1.4 인덱스 확장
`use_index_extensions` 옵티마이저 옵션은 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.
InnoDB 스토리지 엔진에서 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키를 포함한다.

프라이머리 키가 (dept_no, emp_no) 이고 세컨더리 인덱스가 (from_date) 로 되어있으면 실제로 세컨더리 인덱스는 (from_date, dept_no, emp_no)로 작동한다.


### 9.3.1.5 인덱스 머지
인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.

하나의 인덱스를 사용해서 작업 범위를 충분히 줄일 수 있는 경우라면 하나의 인덱스만 활용하는 것이 효율적이다. 하지만 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상 될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

인덱스 머지는 다음의 3개의 세부 실행 계획으로 나누어 볼 수 있다.
- index_merge_intersection
- index_merge_union
- index_merge_sort_union

### 9.3.1.6 인덱스 머지 - 교집합
여러 개의 인덱스를 각각 검색해서 그 결과의 교집합을 반환한다. 실행계획의 extra 컬럼에 using intersect로 표시된다.
두 조건에 대한 인덱스가 모두 존재하고 모두 상대적으로 많은 레코드를 가져와서 처리해야 한다면 인덱스를 각각 검색해서 교집합 하는 방식이 더 효율적일 수 있다. 
물론 옵션을 통해 비활성화 할 수도 있다. 


### 9.3.1.7 인덱스 머지 - 합집합
여러 개의 인덱스를 각각 검색해서 그 결과의 합집합을 반환한다. 실행계획의 extra 컬럼에 using union으로 표시된다. or 조건으로 연결된 경우 사용하는 최적화이다.

이때 중복된 레코드가 조회되면 1개만 나오는데 어떻게 그런지 알아보자. 
각각의 인덱스로 조회했을 때 프라이머리키를 기준으로 정렬되어 있다. 따라서 인덱스 머지를 수행할 때 두 집합에서 하나씩 가져와 비교하면서 중복을 제거할 수 있다. (우선순위 큐...?)

### 9.3.1.8 인덱스 머지 - 정렬 후 합집합

위의 Union 알고리즘에서 정렬된 결과로 중복제거를 하는데 정렬이 이미 되어있으므로 필요하지 않았다.
하지만 인덱스를 이용한 2개의 조회에서 1개라도 프라이머리키로 정렬되어 있지 않다면 중복을 제거하기 위해 정렬 후 중복제거를 수행한다. 

### 9.3.1.9 세미 조인
다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 세미 조인이라 한다.

아래는 세미조인 최적화들이다.
- Table Pull-out
- Duplicate Weed-out
- First Match
- Loose Scan
- Materialization


### 9.3.1.10 테이블 풀-아웃
세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화다. IN(subquery) 형태의 세미 조인이 가장 빈번하게 사용되는 형태의 쿼리일 것이다. 

explain 명령을 통해 살펴보면 IN(subquery) 형태는 사라지고 join으로 재작성된 것을 확인할 수 있다.

### 9.3.1.11 퍼스트 매치
IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다. extra 칼럼에 firstmatch() 문구가 출력된다.

테이블의 레코드에 대해 일치하는 레코드(서브쿼리의) 1건만 찾으면 테이블 검색을 중단하고 다음 레코드로 이동한다. 
즉, 불필요한 추가 검색을 방지하여 성능을 최적화한다. 

### 9.3.1.12 루스 스캔 
Loose Index Scan과 비슷한 읽기 방식을 사용한다. 
아래 그림은 dept_emp 테이블에서 존재하는 모든 부서 정보를 불러오기 위한 쿼리이다.
![](https://velog.velcdn.com/images/pi1199/post/e74ecaaf-b791-43a8-a052-08d0ca96638f/image.png)

### 9.3.1.13 구체화 (Materialization)
세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다. 
여기서 구체화는 내부 임시 테이블을 만드는 것을 의미한다.

### 9.3.1.14 중복 제거
세미 조인 서브쿼리를 일반적인 Inner Join 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.

Inner Join + Group By 로 바꿔서 처리하고 마지막에 중복을 제거한다. 


### 9.3.1.15 컨디션 팬 아웃 

조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다. 
MySQL 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다.

다음과 같은 조건을 만족하는 경우에 옵티마이저는 condition_fanout_filter 최적화 기능을 활성화하여 더 정교한 계산을 할 수 있다. -> 이를 통해 더 효율적인 쿼리를 선택한다. 
- WHERE 조건절에 사용된 칼럼에 인덱스가 있는 경우
- WHERE 조건절에 사용된 칼럼에 히스토그램이 존재하는 경우


### 9.3.1.16 파생 테이블 머지 

이전에는 서브쿼리를 먼저 실행하여 임시테이블을 만들고 외부 쿼리를 처리했다.
서브 쿼리의 조회결과가 많아지면 임시테이블을 디스크에 저장하게 되고 다시 읽어야하는 오버헤드가 생긴다.

FROM 절의 서브쿼리(파생 테이블)를 외부 쿼리로 병합하는 최적화가 도입됐다. 
그런데 외부 쿼리로 병합할 수 없는 경우도 있으니 수작업이 필요하다.

### 9.3.1.17 인비저블 인덱스 

8.0 버전부터는 인덱스의 가용 상태를 제어할 수 있는 기능이 추가됐다. 
인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어할 수 있다.
(...? 왜...?)

### 9.3.1.18 스킵 스캔

인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.
(A, B, C)로 구성된 인덱스가 있을 때 B와 C 칼럼에 대한 조건을 가지고 있다면 인덱스를 활용할 수 없다.

인덱스 스킵 스캔 최적화가 도입되어 후행 칼럼만으로 인덱스를 이용한 쿼리 성능 개선이 가능하다. (선행 칼럼이 소수의 유니크 칼럼을 가질때)
9장이 아니라 8장에서 살펴보았던 인덱스 스킵스캔과 똑같다. 

### 9.3.1.19 해시 조인

네스티드 루프 조인보다 해시 조인이 빠르다고 생각하지만 항상 그렇지 않다. 

해시조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 많이 걸리지 않는다. (최고 스루풋 전략에 적합) -> RDBMS에 적합하지 않다. 
네스티드 루프 조인은 첫 번째 레코드를 찾는 것은 빠르지만 마지막 레코드를 찾는 데에 시간이 많이 걸린다. (최고 응답 속도 전략에 적합)


해시 조인은 빌드 단계와 프로브 단계로 나누어져 처리된다. 
- 빌드 단계 : 조인 대상 테이블 중에서 레코드 건수가 적은 테이블을 골라서 해시 테이블을 생성
- 프로브 단계 : 나머지 테이블의 레코드를 읽어 해시 테이블의 일치 레코드를 찾는 과정 


### 9.3.1.20 인덱스 정렬 선호 
옵티마이저는 ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행한다.
이로인해 옵티마이저가 잘못된 계획을 사용하는 경우가 있다. 너무 빈번하게 잘못 사용한다면 `prefer_ordering_index` 옵션을 끌 수 있다. 

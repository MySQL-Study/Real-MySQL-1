# Chapter 1

# 소개

- 엔터프라이즈 버전, 커뮤니티 버전이 있음
  커뮤니티 버전이 공개된 버전임
- 5.7 버전 까지는 안정성에 집중, 8.0부터는 상용 DBMS의 기능들을 장착

# 왜 MySQL인가?

- 가격과 비용
  오라클은 방대한 데이터를 저장하기에 너무 비싸다.
- 자신이 가장 잘 활용할 수 있는 걸 골라라
  그럼에도 기준을 제공한다면 다음과 같은 순서이다.
  - 안정성
  - 성능과 기능
  - 커뮤니티나 인지도

<br>
<br>
<br>

# Chapter 2

# 설치

다양한 형태로 설치가 가능하지만 운영체제 별 인스톨러를 활용하기를 권장한다.

버전을 선택할 때도 갓 출시된 버전은 버그가 있을 수 있기에 15~20번 릴리즈된 버전을 추천한다.

- mac: homebrew 로 간단설치
- linux(ubuntu) :
  - `apt-update`
  - `sudo apt-get install mysql-server`

### 시작과 종료

```tsx
//리눅스 환경
//상태 확인
systemctl status mysqld
//시작
systemctl start mysqld
//종료
systemctl stop mysqld

//원격 셧다운
mysql> SHUTDOWN;
```

원격 셧다운을 하기 위해서는 권한을 가지고 있어야 한다.

### 셧다운 시 주의할 사항

실제 트랜잭션이 정상적으로 커밋되어도 데이터 파일에 변경된 내용이 기록되지 않고 로그(리두 로그) 파일에만 기록되어 있을 수 있다. 심지어 서버가 종료된 후 다시 시작해도 계속 이상태로 남아있을 수 있다.

커밋된 내용을 모두 반영하고 종료하는 방법도 있는데 mysql 서버 옵션을 변경하고 종료하면 된다.

이렇게 모든 변경사항을 데이터 파일에 적용하고 종료하는 것을 클린 셧다운(clean shutdown) 이라고 한다.
클린 셧다운 이후 다시 시작하면 트랜잭션 복구 과정을 진행하지 않기에 빠르게 다시 시작할 수 있다.

```tsx
mysql> SET_GLOBAL innodb_fast_shutdown=0;
linux> systemctl stop mysqld
```

> ❗ mysql 서버가 시작하고 종료될 때는 버퍼 풀의 내용을 백업하고 복구하는 과정이 내부적으로 실행된다. 다만 버퍼풀의 내용이 아니라 메타데이터를 백업하기에 용량은 작고 빠르게 백업된다. 하지만, 새로 시작될 때는 디스크에서 데이터 파일들을 모두 읽어서 적재해야 하므로 상당한 시간이 걸릴 수 있다.

## 서버 연결 테스트

```tsx
// 1. 소켓 파일 이용
mysql -uroot -p --host=localhost --socket=/tmp/mysql.lock
// 2. tcp/ip로 로컬호스트 접속
mysql -uroot -p --host=127.0.0.1 --port=3306
// 3. 로컬 접속
mysql -uroot -p
```

1. mysql의 소켓 파일을 이용하여 접속한다.
2. tcp/ip 를 통해 로컬 호스트로 접속하는 경우 포트를 명시하는게 일반적이다.
   원격 호스트로 접속할때는 반드시 이 방법을 이용해야 한다.
   localhost 와 127.0.0.1 은 각각 의미가 다르다.
   - `localhost`
     이 옵션은 항상 소켓 파일을 통해 mysql 서버에 접속하게 된다. 이는 unix domain socket 을 이용하는 방식으로 tcp/ip 방식이 아니라 유닉스 프로세스간 통신(inter process communication)의 일종이다.
   - `127.0.0.1`
     이 방식은 자기 서버를 가리키는 루프백(loop back) ip 이기는 하지만 tcp/ip 방식을 이용한다.
3. 별도로 호스트와 ip를 입력하지 않는다.
   따라서 기본값인 localhost와 소켓 파일을 사용하게 된다.

- telnet 테스트
  글자가 깨졌지만 접속에 성공
  
<img width="609" alt="스크린샷 2024-12-19 오후 5 42 45" src="https://github.com/user-attachments/assets/802a8db3-bea2-4622-90a1-750c6d163442" />

<br>

## MySQL 서버 업그레이드

업그레이드 하는 방법은 다음과 같이 2가지 방법이 있다.

1. MySQL 서버의 데이터 파일을 그대로 두고 업그레이드 하는 방법
2. mysqldump 도구 등을 이용해 MySQL 서버의 데이터를 SQL문장이나 텍스트 파일로 덤프한 후, 새로운 MySQL 서버에 덤프된 데이터를 적재하는 방법

1번 방법은 `인플레이스 업그레이드(in-place upgrade)` 라고 하며 2번 방법은 `논리적 업그레이드(logical upgrade)` 라고 한다.

인플레이스 업그레이드는 여러가지 제약사항이 있지만, 시간을 크게 단축할 수 있다.
반대로 논리적 업그레이드는 제약사항이 거의 없지만, 시간이 매우 많이 소요될 수 있다.

<br>

### 인플레이스 업그레이드 제약사항

업그레이드는 `마이너(패치) 버전간 업그레이드`와 `메이저 버전 업그레이드`로 생각할수있다.

동일 메이저 버전끼리의 업그레이드는 대부분 데이터 파일의 변경 없이 진행된다. 예를들어 8.0.16 에서 8.0.21로 업그레이드 시 mysql 서버 프로그램만 재설치하면 된다.

하지만 메이저 버전 간 업그레이드는 대부분 크고 작은 데이터 파일의 변경이 필요하기에 반드시 직전 버전에서만 업그레이드가 가능하다. 예를들어 5.5 → 5.6은 가능하지만, 5.5 → 5.7로는 불가능하다.

따라서 `여러 버전을 건너뛴다면 논리적 업그레이드가 나을 수 있다.`

GA(general availability) 버전인 경우만 메이저 업그레이드가 지원된다. GA는 어느정도 안정성이 확인된 버전을 의미한다.

<br>

### MySQL 8.0 업그레이드시 고려사항

5.7 버전에서 8.0 버전으로 업그레이드 되면서 많은 변화가 일어났다.
8.0으로 업그레이드 하기 전 다음과 같은 사항을 검토해보자.

- 사용자 인증 방식 변경
  5.7 버전에서는 Native 인증 방식을 사용했지만 8.0부터는 Caching SHA-2 방식이 기본 인증 방식으로 변경되었다.
- MySQL 8.0과의 호환성 체크
  5.7버전에서 손상된 FRM 파일이나 호환되지 않는 데이터 타입 또는 함수가 있는지 mysqlcheck 유틸리티를 이용해 확인해볼 것을 권장한다.
- 외래키 이름 길이
  8.0에서는 64글자로 제한된다
- 인덱스 힌트
  8.0에서는 인덱스 힌트가 오히려 성능을 저하할 수 있다. 성능측정을 해보고 비교하자
- GROUP BY 정렬 옵션
  GROUP BY 절의 칼럼 뒤에 ASC 나 DESC 를 하고 있다면 제거하거나 다른 방식으로 변경하자
  (GROUP BY field_name [ASC | DESC])
- 파티션을 위한 공용 테이블 스페이스
  8.0이상에서는 파티션의 각 테이블 스페이스를 공용 테이블 스페이스에 저장할 수 없다.

### 서버 설정

mysql 서버는 단 하나의 설정파일을 사용하는데 유닉스 계열 에서는 `my.cnf`, 윈도우 계열에서는 `my.ini` 라는 이름을 사용한다. mysql은 서버가 시작될 때만 이 설정파일을 참고한다. 디렉터리를 순차적으로 탐색하며 처음 발견된 my.cnf 을 사용한다.

다만 단 하나의 설정파일만 사용하지만 설정파일이 위치한 디렉터리는 여러개일 수 있다는 점이다.
다음과 같은 명령어로 어떤 my.cnf 파일을 읽는지 파악할 수 있다.

```tsx
mysql --help
```
<img width="672" alt="스크린샷 2024-12-20 오후 4 59 39" src="https://github.com/user-attachments/assets/8441213f-9131-483e-8051-04de77259eb2" />



`my.cnf` 파일에 여러개의 설정 그룹을 담을 수 있다.

mysqldump 그룹은 mysqldump 설정을, mysqld 그룹은 mysqld 설정 영역을 사용하면 된다.

```bash
[client]
# client 옵션
default-character-set = utf8
port = 3306
socket = /home/centos/mysql/mysql.sock

[mysqld]
# MySQL 서버 기본 옵션
basedir = /home/centos/mysql
datadir = /home/centos/mysql/data
socket = /home/centos/mysql/mysql.sock
log-error = /home/centos/mysql/mysql-log/mysqldb.log
pid-file = /home/centos/mysql/mysql-log/mysqldb.pid
user = centos
innodb_buffer_pool_size = 10G

[mysql]
# MySQL 설정그룹
soket = /home/centos/mysql/mysql.sock
port = 3304

[mysqld_safe]
# mysqld_safe는 mysqld를 감시하는 데몬. mysqld_safe가 내부에서 mysqld를 실행
log-error = /home/centos/mysql/mysql-log/mysqldb.log
pid-file = /home/centos/mysql/mysql-log/mysqldb.pid
```

<br>
<br>

### MySQL 시스템 변수

MySQL 서버는 기동하면서 설정 파일의 내용을 읽어 메모리나 작동 방식을 초기화 하고, 접속된 사용자를 제어하기 위해 이러한 값을 별도로 저장한다. 이 값들을 `시스템 변수`라고 한다.
아래와 같은 명령으로 확인할 수 있다.

```bash
SHOW GLOBAL VARIABLES;
```

시스템 변수값이 어떻게 mysql 서버와 클라이언트에 영향을 미치는지 확인하려면 각 변수가 `글로벌 변수`인지 `세션 변수` 인지 구분해야한다.

- 글로벌 변수
  하나의 MySQL 서버 인스턴스에서 전체적으로 영향을 미치는 시스템 변수
  주로 MySQL 서버 자체 관련 설정이 많다. 예를들어 innoDB 버퍼 풀의 크기, MyISAM의 키 캐시크기 등이 대표적이다.
- 세션 변수
  클라이언트가 MySQL 서버에 접속할 때 기본적으로 부여하는 옵션의 기본값을 제어하는데 사용한다.
  세션 변수는 커넥션 별로 설정값을 다르게 지정할 수 있으며, 한번 연결된 커넥션의 변수는 서버에서 변경할 수 없다. auto commit 을 대표적으로 볼 수 있다.

<br>

### 정적 변수와 동적 변수

MySQL 서버가 기동 중인 상태에서 변경 가능한지에 따라 동적 변수와 정적 변수로 구분된다.

디스크에 저장된 변수(my.cnf파일)와 기동 중인 MySQL 서버의 메모리에 있는 MySQL 서버의 시스템 변수를 변경하는 경우로 구분할 수 있다.

동적 변수를 set 명령을 통해 변경한 경우 인스턴스에만 적용되기 때문에 다음 실행에서는 적용되어 있지 않다.
영구적으로 변경하기 위해서는 `my.cnf` 파일에서 변경해야 한다.

또는 `SET PERSIST` 를 이용해서 동적 시스템 변수를 설정파일까지 변경할 수 있다. 그러나 `my.cnf` 파일에 적용되지 않고 별도의 파일에 기록된다.

<br>

### SET PERSIST

서버를 재시작하지 않고, `SET` 명령을 이용하여 동적 변수를 변경하여 문제를 해결한 뒤 이를 잊고 서버를 재시작 하는 경우 똑같은 문제가 발생한다. 이를 보완하기 위해 `SET PERSIST` 명령이 추가되었다.

`SET PERSIST` 명령으로 시스템 변수를 변경하면 즉시 적용함과 동시에 별도의 설정파일 `mysqld-auto.cnf` 에 변경 내용을 추가로 기록한다. 이를 통해 서버를 재시작할 때, my.cnf 와 mysqld-auto.cnf 를 함께 참조하여 서버를 재실행 한다.

`SET PERSIST_ONLY` 명령은 인스턴스에 변경을 적용하지 않고 `mysqld-auto.cnf` 파일만 변경할 수 있다.
또한, 정적 변수를 영구적으로 변경할 때도 이용할 수 있다. 이렇게 동적 변수뿐만 아니라 정적 변수도 변경할 수있다. (누가 언제 어떤 값이 변경 되었는지도 기록된다 json 형태로)

<br> 
<br> 

# Chapter 3 
MySQL 은 다른 RDBMS와 다르게 사용자의 아이디 뿐만 아니라 ip 주소도 확인한다. 
또한, 8.0이상 부터는 권한을 묶어둔 Role 을 생성하여 미리 준비된 권한을 사용할 수 있다

## 사용자 식별

계정 뿐만 아니라 도메인, 호스트명, ip 등도 계정의 일부가 된다. 

따라서 항상 아이디와 호스트를 함께 명시해야 한다. MySQL의 사용자는`<username>@<host>`형식으로 표현됩니다. 예를 들어, `user1@localhost` 와 `user1@192.168.1.10`은 서로 다른 계정으로 간주됩니다.

계정의 호스트 부분을 `%` 로 교체하면 모든 외부 컴퓨터에서 접속할 수 있다는 의미이다. 
또한, `user1@192.168.1.10` 과 `user1@%` 2개의 계정이 존재한다면, 항상 작은 것을 먼저 선택한다. 따라서 `192.168.1.10` 에서 접속시 `user1@192.168.1.10` 계정 정보로 로그인하게 된다. 

## 사용자 계정 관리

### 시스템 계정과 일반 계정

8.0 버전 부터는 SYSTEM_USER 권한을 가지고 있느냐에 따라 시스템 계정과 일반 계정으로 구분된다. 
시스템 계정도 일반 계정과 같이 사용자를 위한 계정이다. 그냥 DBA관리자 계정과 개발자 계정 정도로 생각하면 쉽다. 

시스템 계정만 가능한 기능은 다음과 같은 것들이 있다.

- 계정 관리
- 다른 세션 또는 그 세션에서 실행중인 쿼리 강제종료
- 스토어드 프로그램 생성시 definer를 타 사용자로 설정

### 계정 생성

8.0 부터는 계정 생성과 권한 부여가 분리되었다. 계정 생성시 옵션을 사용할 수 있는데 하나씩 알아보자

```bash
create user 'user'@'%'
	identified with 'mysql_native_password' by 'password'
	require none
	password expire interval 30 day
	account unlock
	password history default 
	password reuse interval default
	password require current default;
```

`identified with`  

사용자 인증 방식과 비밀번호를 설정한다. 기본 인증방식을 사용하고 싶다면 with ~~ 만 빼고 작성하면 된다. 
인증방식에는 대표적으로 4가지 종류가 있지만 그냥 읽어보고 넘어가자 
또한 이전 챕터에서 설명했듯이 5.7과 8.0버전의 비밀번호 인증 방식이 다르다. 따라서 8.0부터는 기존과 다른 방식으로 접속해야 한다. 따라서 기존 버전과 호환성을 고려한다면 옵션을 변경하자
`require`  
접속시 암호화된 SSL/TLS 채널을 사용할지 여부를 결정한다. 8.0에서 기본으로 사용하는 Caching SHA-2 방식을 사용한다면 기본적으로 암호화 된 채널로 접속하게 된다.
- `Password expire`  
비밀번호 유효기간을 설정한다. 여러 옵션이 있지만 기본은 시스템변수에 저장된 기간으로 설정된다.
- `password history`  
한번 사용했던 비밀번호를 재사용하지 못하게 하는 옵션이다. 
이전 비밀번호를 mysql 서버가 기억하고 있어야 하는데 db의 password_history 테이블을 사용한다.
- `password reuse interval`  
비밀번호 재사용 금지 기간을 설정하는 옵션이다.
- `password require`  
비밀번호 만료시 새 비밀번호를 설정할 때 이전 비밀번호가 필요한지 설정한다 .
- `account lock/unlock`  
계정 정보를 변경하지 못하게 잠글지 여부를 결정한다.

# 비밀번호 관리

### 고수준 비밀번호

mysql 서버는 유효성을 체크하거나 글자의 조합을 강제하는 비밀번호 관리 컴포넌트가 존재한다.

다양한 옵션을 시스템 변수를 이용하여 설정할 수 있다. 아래 명령을 통해 비밀번호 관리 시스템 변수를 확인한다.

```bash
show global variables like 'validate_passowrd%'
```

비밀번호 정책은 크게 3가지 중에 설정할 수 있고 기본은 Medium 이다.

- Low : 비밀번호 길이만 검증
- Medium : 길이, 숫자와 대소문자, 특수분자 배합 검증
- Strong : medium + 금칙어까지 검증

금칙어를 설정하는 파일은 validate_password.dictionary_file 이라는 시스템 변수에 금칙어들이 저장된 사전 파일을 등록하면 된다. 

`SET global validate_password.dictionary_file=’word.txt’;`

### 이중 비밀 번호

비밀번호 변경은 서비스를 종료해야하기에 서비스를 운영하는 중에는 변경이 어려웠다. 그러나 8.0부터는 2개의 비밀번호를 사용할 수 있도록 하여 종료하지 않고도 보안을 위해 주기적으로 비밀번호를 변경할 수 있게 되었다. 

`primary` 는 최근에 설정된 비밀번호, `secondary`는 이전에 설정된 비밀번호이다.

```bash
// 비밀번호 변경 (secondary 없는 상태)
alter user 'root'@'localhost' identified by 'old_password';

// 새 비밀번호 설정 및 이전 비밀번호를 secondary로 보내기 
ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password' RETAIN CURRENT PASSWORD;
```

이렇게 변경해 두고 mysql을 사용하는 모든곳에서 새 비밀번호로 변경하고 재시작을 완료했다면 secondary비밀번호를 삭제한다. 

### 권한

5.7 까지는 글로벌 권한과 객체단위 권한으로 구분됐다. 데이터베이스나 테이블 이외의 객체에 적용되는 권한을 글로벌 권한이라고 하며, 데이터 베이스나 테이블을 제어하는데 필요한 권한은 객체 권한이라고 한다. 
객체는 Grant로 권한을 부여할 대상을 명시해야하며, 글로벌 권한은 대상을 명시할 수 없다. 

8.0부터는 동적 권한을 통해 관리자도 백업관리자, 복제 관리자 등 꼭 필요한 권한만 부여할 수 있게 됐다. 또한, 존재하지 않는 사용자에게 권한 부여시 에러가 발생한다. 

```bash
// 명령
Grant privilege_list on db.table to 'user'@'host';

//기본 예시 (모든 db와 테이블의 super 권한을 localhost로 접속한 user 에게 부여)
Grant super on *.* to 'user'@'localhost';
```

보통은 데이터베이스 단위까지만 권한을 설정한다. 

칼럼이나 테이블 단위로 부여할 수도 있지만, 성능상의 문제를 일으킨다. 하나의 칼럼에 대해서만 권한을 설정하더라도 나머지 모든 칼럼에 대해 권한체크가 진행되기 때문에 성능에 영향을 미칠 수 있다. 

## 역할

8.0부터 권한을 묶어서 역할(Role)을 사용할 수 있다. 
기본적으로 역할은 그 자체로 사용할 수 없고 계정에 부여하여 사용해야 한다. 

서버 내부적으로 역할은 계정과 똑같은 모습을 하고 있다. 실제로 mysql의 유저 정보를 조회하면 역할도 함께 조회된다. 따라서 구분하기위해 `role_` 과 같은 Prefix를 붙여 사용하는걸 권장한다.

- 그렇다면 역할과 계정을 어떻게 구분할까? 
→ 하나의 계정에 다른 계정의 권한을 병합 하기만 하면 되므로 서버는 역할과 계정을 구분할 필요가 없다.

MySQL 서버는 역할(Role)과 계정(Account)을 별도로 구분하지 않습니다.

서버는 단지 권한의 집합을 관리하며, 사용자가 어떤 역할을 활성화하거나 계정의 권한을 병합하여 사용하면 그 권한을 실행하도록 설계되어 있습니다.

역할과 계정은 권한을 직접 사용(계정)하거나 간접 제공(역할)하는 방식의 차이만 있을 뿐, 동일한 관리 메커니즘을 따릅니다.

- 그렇다면 굳이 create user 와 create role 이 존재할까?
→ 데이터 베이스 관리 직무를 분리할 수 있게 만들기 위해서이다. create role은 데이터 베이스만 할 수 있도록 하는 등의 관리가 가능하기 때문에 직무별로 권한을 분리할 수 있다.

# 4.2

## 4.2.7 InnoDB 버퍼 풀

### 4.2.7.1 버퍼 풀의 크기 설정

- 버퍼 풀은 InnoDB에서 가장 중요한 메모리 캐싱 영역으로, 디스크 I/O를 최소화하고 성능을 최적화합니다.
- **설정 기준**:
    - 메모리가 8GB 미만인 경우: 메모리 크기의 **50%**로 설정.
    - 메모리가 50GB 이상인 경우: **전체 메모리(MEM)에서 15GB~30GB를 제외한 값**으로 설정.
- **변수 설정**:
    - innodb_buffer_pool_size 변수로 크기를 조정할 수 있습니다.
    - **버퍼 풀 크기를 줄이는 작업은 피해야** 하며, 크기 변경이 필요한 경우 서버를 재시작하는 것이 권장됩니다.
- 버퍼 풀은 **128MB 단위 청크**로 관리되며, 다중 버퍼 풀 인스턴스를 사용하여 동시성을 높일 수 있습니다.

### 4.2.7.2 버퍼 풀의 구조

- **LRU 리스트**:
    - 최근 사용된 페이지(MRU, Most Recently Used)와 오래된 페이지(LRU, Least Recently Used)를 관리.
    - 변경된 페이지는 LRU 리스트 상단(MRU 영역)에서 유지되며, 시간이 지나면서 하단으로 이동.
- **플러시 리스트**:
    - 디스크로 플러시(저장)해야 할 더티 페이지를 추적.
    - 페이지가 변경되면 플러시 리스트에 추가.
- **프리 리스트**:
    - 비어 있는 페이지의 리스트.
    - 새로운 데이터를 로드할 때 사용됩니다.

### 4.2.7.3 버퍼 풀과 리두 로그

- **클린 페이지**:
    - 디스크에서 로드되었으나 변경되지 않은 페이지.
    - 메모리에서 제공되며, 디스크 쓰기가 불필요.
- **더티 페이지**:
    - 데이터가 변경된 페이지로, 디스크에 기록되지 않은 상태.
- **활성 리두 로그**:
    - 더티 페이지의 변경 사항을 기록한 로그.
- **체크포인트 에이지**:
    - 마지막 LSN - 최근 체크포인트 LSN.
    - 디스크 쓰기와 데이터 복구를 관리하기 위한 주요 지표.

### 4.2.7.4 버퍼 풀 플러시

**4.2.7.4.1 플러시 리스트 플러시**

- 변경된 페이지를 플러시 리스트에서 추적하며, 주기적으로 디스크로 기록.
- 시스템 부하를 줄이기 위해 백그라운드 쓰레드에서 처리.(클리너 스레드)

**4.2.7.4.2 LRU 리스트 플러시**

- 오래된 페이지를 LRU 리스트에서 제거.
- 메모리 확보 및 새로운 페이지 로드 시 활용.

### 4.2.7.5 버퍼 풀 상태 백업 및 복구

- 워밍업이 중요
- InnoDB는 버퍼 풀 상태를 디스크에 저장하고, MySQL 서버 재시작 시 이를 복원할 수 있습니다.
- 복구 시 버퍼 풀을 초기화하지 않으므로, 서버 가동 후 빠르게 성능을 회복할 수 있습니다.

### 4.2.7.6 버퍼 풀의 적재 내용 확인

## 4.2.8 Double Write Buffer

- 묶어서 한번에 먼저 쓰고, 랜덤 쓰기가 실패할 경우에만 사용됨
- SSD는 랜덤과 순차가 비슷해서 오히려 성능에 영향을 줄 수 있음
- 리두 로그 동기화 설정이 1이 아니라면 같이 끄는게 좋음

## 4.2.9 언두 로그

- 트랜잭션 보장 → 롤백 시 이전 버전으로 안전하게 복구
- 격리 수준 보장 → 알맞게 조회가능하게 해줌

Q: 언두로그는 메모리에 있나 디스크에 있나

부족하면 메모리에서 언두 테이블 스페이스로 플러시된다. → 대규모 트랜잭션

메모리는 트랜잭션 종료시 언두로그 삭제

디스크는 주기적으로 정리

### 4.2.9.1 언두 로그 모니터링

- 언두 로그양이 많아지면 안좋음 → 트랜잭션이 장시간 유지 된다는 것

### 4.2.9.2 언두 테이블 스페이스 관리

- 자동 모드: 커밋되면 언두로그에 복사된 이전값 삭제(퍼지 스레드가 주기적으로 삭제)
- 수동 모드: 자동이 답답한 경우

## 4.2.10 체인지 버퍼

- 인덱스 작업용 버퍼

## 4.2.11 리두 로그 및 로그 버퍼

- 비정상 종료시에 활용되는 로그
- 커밋됐지만 데이터 파일에 기록되지 않은 데이터
- 롤백됐지만 데이터 파일에 이미 기록된 데이터 → 롤백이 가능하다는건 트랜잭션 중이라는건데 데이터파일에 기록은 왜되는지 말이안된다고 생각
- 리두 로그 버퍼에서 디스크로 플러시 되는 타이밍은 innodb_flush_log_at_trx_commit으로 설정 할 수 있음 → 1이 가장 기본(커밋 시 바로 플러시)

### 4.2.11.1 리두 로그 아카이빙

### 4.2.11.2 리두 로그 활성화 및 비활성화

- 비활성화 → 대규모 적재시 잠깐 할 수도 있음 → 바로 다시 키는게 좋음

## 4.2.12 어댑티브 해시 인덱스

- (B-Tree 인덱스 고유 번호(ID) & B-Tree 실제 키 값) : 해당 인덱스 키 값이 저장된 데이터 페이지 주소(버퍼풀 내에서의 메모리 주소)
- 접근해서 인덱스 읽기
- 디스크 읽기가 많은 경우, 특정패턴의 쿼리(조인이나 LIKE 패턴 검색), 매우 큰 데이터 테이블을 넓게 읽기 → 해시 인덱스가 도움을 주지 못함
- 이론이랑 다를 수도 있기 때문에 검색률 보면됨 → 100%에 가까워야 효율이 좋은것, 낮다면 비활성화 해도 괜찮

## 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- 무조건 InnoDB가 좋으니까 이상한 생각 하지 말 것

# 4.3 MyISAM 스토리지 엔진 아키텍처

## 4.3.1 키 캐시

## 4.3.2 운영체제의 캐시 및 버퍼

## 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

# 4.4 MySQL 로그 파일

## 4.4.1 에러 로그 파일

### 4.4.1.1 MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지

### 4.4.1.2 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지

### 4.4.1.3 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지

### 4.4.1.4 비정상적으로 종료된 커넥션 메시지

### 4.4.1.5 InnoDB의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS같은)의 결과 메시지

### 4.4.1.6 MySQL의 종료 메시지

## 4.4.2 제너럴 쿼리 로그 파일

## 4.4.3 슬로우 쿼리 로그

### 4.4.3.1 슬로우 쿼리 통계

### 4.4.3.2 실행 빈도 및 누적 실행 시간순 랭킹

### 4.4.3.3 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보

###

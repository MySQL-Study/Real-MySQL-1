### 4.2.7 InnoDB 버퍼 풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분

    - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
    - 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 함.
    - 랜덤한 디스크 작업을 버퍼 풀이 변경된 데이터를 모아 처리하여 랜덤한 디스크 작업의 횟수 줄일 수 있음.

#### 4.2.7.1 버퍼 풀의 크기 설정
- 운영체제와 각 클라이언트 스레드가 사용할 메모리 충분히 고려해 InnoDB의 버퍼 풀을 설정해야 함.
- MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만, 아주 독특한 경우 레코드 버퍼가 상당한 메모리 사용하기도 함.
- `레코드 버퍼` : 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간

    - 커넥션이 많고 사용하는 테이블이 많다면 버퍼 용도로 사용되는 메모리 공간 꽤 많이 필요해질 수도
    - MySQL 서버가 사용하는 레코드 버퍼 공간 별도 설정 불가
    - 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블 개수에 따라 결정됨.
    - 동적으로 해제되기도 하여 정확히 필요한 공간 계산 불가

<br>

- MySQL 5.7버전부터 InnoDB 크기 동적 조절 가능하게 개선됨.

    - 적절히 작은 값으로 설정해서 상황에 따라 증가시키는 방법이 최선 (ex. 50%에서 증가시키며 사용)
    - `innodb_buffer_pool_size` 시스템 변수로 크기 설정 가능 (동적으로 버퍼 풀 크기 확장 가능)
    - 버퍼 풀 크기 변경은 크리티컬한 변경 -> MySQL 서버가 한가한 시점 골라서 진행하는 것이 좋음.
    - 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리됨. -> 크기 줄이거나 늘릴 때에도 128MB 단위로 관리됨.

- 버퍼 풀이 여러 개의 작은 버퍼 풀로 쪼개지면서 개별 버퍼 풀 전체 관리하는 잠금(세마포어) 자체도 경합이 분산되는 효과 내게 됨.


#### 4.2.7.2 버퍼 풀의 구조
- InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기(`innodb_page_size` 시스템 변수에 설정된)의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장함.
- 버퍼 풀 페이지를 관리하기 위해 InnoDB 스토리지 엔진이 관리하는 자료 구조

    - LRU(Least Recently Used) 리스트

        - 엄밀하게는 LRU와 MRU(Most Recently Used) 리스트가 결합한 형태
        - Old 서버 리스트가 LRU, New 서버 리스트가 MRU로 이해하면 됨.
        - LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기 최소화하기 위함.
    - Flush(플러시) 리스트

        - 더티 페이지(디스크로 동기화 되지 않은 데이터를 가진 페이지)의 변경 시점 기준의 페이지 목록 관리
        - 한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록되어야함.
        - 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영
          -> 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결됨.
        - 리두 로그가 디스크로 기록되어도 데이터 페이지가 디스크로 기록됨을 항상 보장하지는 않음.
        - InnoDB 스토리지 엔진은 체크 포인트 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태 동기화 함.
        - 체크포인트는 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점 만드는 역할
    - Free (프리) 리스트

        - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
        - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용됨.

#### 4.2.7.3 버퍼 풀과 리두 로그

- InnoDB 버퍼 풀과 리두 로그 밀접한 관계 맺고 있음.
- InnoDB 버퍼 풀은 서버 메모리가 허용하는 만큼 크게 설정할 수록 쿼리 성능 빨라짐.

    - 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 공간이면 늘려도 성능에 도움이 되지 않지만, 그 이외의 경우에는 성능 좋아짐.

- InnoDB 버퍼 풀의 용도

    - `데이터 캐시` : 버퍼 풀 메모리 공간만 단순히 늘리는 것
    - `쓰기 버퍼링` : InnoDB와 버퍼 풀과 리두 로그 관계 이해 필요

<img
src="https://velog.velcdn.com/images/hyolim/post/09fb8fac-a425-40ca-a8f1-b25d69a1cc22/image.png" width="500" height="auto">

- InnoDB는 클린 페이지(Clean Page)와 더티 페이지(Dirty Page) 모두 가짐.

    - 더티 페이지는 디스크와 메모리(버퍼 풀)의 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록되어야 함.
    - 더티 페이지는 버퍼 풀에 무한정 머무를 수 없음.
    - InnoDB 스토리지 엔진에서 리두 로그는 1개 이상의 고정 파일을 연결해 순환 고리처럼 사용
      -> 즉, 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 새로운 로그 엔트리로 덮어 쓰임.

- InnoDB 스토리지 엔진은 전체 리두 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간 구분해서 관리 필요

    - `활성 리두 로그(Active Redo Log)`: 재사용 불가능한 공간

- `LSN(Log Sequence Number)` : 리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 증가된 값을 갖게됨.

    - InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화
    - `Checkpoint Age` : 가장 최근 체크 포인트의 LSN과 마지막 리두 엔트리 LSN 차이 -> 활성 리두 공간의 크기
- InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가짐.

    - 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 함.

- 무조건 리두 로그 파일의 크기가 클 수록 좋은 것이 아니라, 버퍼 풀 크기가 100GB 이하의 경우에는 5~10GB에서 점차 늘려가면 최적 값 찾는 것이 좋음.

#### 4.2.7.4 버퍼 풀 플러시(Buffer Pool Flush)
- `MySQL 5.6 버전 이전` : InnoDB 스토리지 더티 페이지 플러시 기능이 그다지 부드럽게 처리되지 않음.
- `MySQL 8.0 버전 이후` : 더티 페이지 동기화 하는 부분(더티 페이지 플러시)에서 디스크 쓰기 폭증 현상은 발생 X

- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 플러시 기능 백그라운드로 실행

    - 플러시 리스트(Flush_list) 플러시
    - LRU 리스트(LRU_list) 플러시

**4.2.7.4.1 플러시 리스트 플러시**

- InnoDB 스토리지 엔진은 리두 로그 공간의 재활용 위해 주기적으로 오래된 리두 로그 엔트리가 활용하는 공간 비워야 함.
  -> 오래된 리두 로그 공간 지워지려면 반드시 InnoDB 버퍼풀의 더티 페이지가 먼저 디스크로 동기화돼야 함.
  -> 이를 위해 InnoDB 스토리지 엔진은 주기적으로 플러시 리스트(Flush_list) 플러시 함수를 호출해 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업 수행
  -> 이때 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크로 기록하느냐에 따라 사용자 쿼리가 악영향 받지 않으면서 부드럽게 처리됨.
  <br>

- InnoDB가 제공하는 시스템 변수

    - `innodb_page_cleaners`

        - 클리너 스레드(Cleaner Thread) 개수 조정
        - 클리너 스레드 : 더티 페이지를 디스크로 동기화하는 스레드
        - 버퍼 풀 인스턴스 개수보다 많은 경우에는 `innodb_buffer_pool_instances` 설정 값으로 자동으로 변경
        - 버퍼 풀 인스턴스 개수보다 적은 경우에는 하나의 클리너 스레드가 여러 개의 버퍼 풀 인스턴스 처리
        - 가능한 `innodb_buffer_pool_instances`와 동일하게 설정하는 것이 좋음.
    - `innodb_max_dirty_pages_pct_lwn`

        - 일정 수준 이상의 더티 페이지가 발생하면, 조금씩 더티 페이지를 디스크로 기록하게 함.
        - 기본 값은 10%, 높은 값으로 조정하는 것이 디스크 쓰기 횟수 줄이는 효과 줄 수도!
    - `innodb_max_dirty_pages_pct`

        - 더티 페이지 비율 설정 가능
        - InnoDB 버퍼 풀은 클린 페이지 뿐 아니라 사용자의 DML(INSERT, UPDATE, DELETE)에 의해 변경된 데이터도 가짐.
        - 무한정 더티 페이지 그대로 유지할 수 없기 때문에 전체 버퍼 풀이 가진 페이지의 90%까지 기본적으로 더티 페이지를 가짐.
        - 버퍼 풀이 더티 페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링함으로써 여러 번의 디스크 쓰기를 한 번으로 줄이는 효과 극대화 가능
          -> 기본값 유지하는 것이 좋음
    - `innodb_io_capacity`

        - 이 변수를 기준으로 더티 페이지 쓰기를 진행
        - 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값 설정
        - 더티 페이지가 많을수록, 디스크 쓰기 폭발(Disk IO Burst) 현상이 발생할 가능성 높아짐.

    - `innodb_io_capacity_max`

        - 각 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지 설정하는 값
        - 디스크가 최대의 성능을 발휘할 때 어느 정도 디스크 읽고 쓰기가 가능한지 설정
        - 디스크가 읽고 쓰는 작업은 InnoDB 스토리지 엔진의 백그라운드 스레드가 수행하는 작업과 사용자의 쿼리를 처리하기 위한 디스크 읽기 쓰기까지 처리해야하므로, 디스크의 최대 성능을 이 변수에 넣어서는 안됨.
    - `innodb_flush_neighbors`
        - 더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중 더티 페이지가 있다면, InnoDB 스토리지 엔진이 함께 묶어서 디스크로 기록하게 해주는 기능 활성화 여부 결정
        - 요즘은 HDD가 아닌 SDD를 대부분 사용하므로, 기본 값인 `비활성`을 추천
    - `innodb_adaptive_flushing`
        - 활성화하면, 설정값에 의존하지 않고 새로운 알고리즘 사용
    - `innodb_adaptive_flushing_lwn`
        - 기본 값 : 10%
          -> 활성 리두 공간이 10%미만이면 어댑티브 플러시 알고리즘 수행하는 것

**4.2.7.4.2 LRU 리스트 플러시**

- LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간 만들어야 함.
- LRU 리스트의 끝 부분부터 최대 `innodb_lru_scan_depth` 시스템 변수에 설정된 개수만큼의 페이지들을 스캔

    - 스캔하면서 더티 페이지는 디스크에 동기화
    - 클린 페이지는 즉시 프리(Free) 리스트로 페이지 옮김
- 버퍼 풀 인스턴스별로 최대 `innodb_lru_scan_depth` 개수 만큼 스캔하므로, 실질적으로 LRU 리스트의 스캔은 `innodb_buffer_pool_instances * innodb_lru_scan_depth` 수만큼 수행


#### 4.2.7.5 버퍼 풀 상태 백업 및 복구
- `워밍업(Warming Up)` : 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태

    - 버퍼 풀이 작 워밍업된 상태에서는 그렇지 않은 경우보다 몇십 배 쿼리 속도 보이는 것이 일반적
    - MySQL 5.5 버전 이전 : 서버 셧다운 하는 경우에 강제 워밍업을 위해 주요 테이블과 인덱스에 대해 풀스캔 진행
    - MySQL 5.6버전 이후 : 버퍼 풀 덤프 및 적재 기능 도입됨.
    ```
    // MySQL 서버 셧다운 전에 버퍼 풀의 상태 백업
    mysql> SET GLOBAL innodb_buffer_pool_dump_now=ON;
    
    // MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
    mysql> SET GLOBAL innodb_buffer_pool_load_now=ON;
    ```
- InnoDB 버퍼 풀의 백업 : `ib_buffer_pool`이라는 이름의 파일로 생성됨.

    - LRU 리스트에 적재된 데이터 페이지의 메타 정보만 저장하기 때문에 몇십 MB이하이고, 백업 작업이 빨리 완료됨.
    - 백업된 버퍼 풀의 내용을 다시 버퍼 풀로 복구하는 과정은 InnoDB 버퍼 풀의 크기에 따라 상당한 시간이 걸릴 수 있음. (각 테이블의 데이터 페이지를 다시 디스크에서 읽어와야하기 때문)
    - 중간에 복구를 멈추려면 `innodb_buffer_pool_load_abort` 시스템 변수 사용하면 됨.

- 버퍼 풀의 백업과 복구를 자동화하려면 `innodb_buffer_pool_dump_at_shutdown` 과 `innodb_buffer_pool_load_at_startup` 설정을 MySQL 서버의 설정 파일에 넣어두면 됨.


#### 4.2.7.6 버퍼 풀의 적재 내용 확인
- MySQL 5.6 버전 이후 : `information_schema` 데이터베이스의 `innodb_buffer_page` 테이블을 이용해 InnoDB 버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적재돼 있는지 확인 가능
  -> 테이블 조회가 부하를 많이 일으켜 실질적으로는 버퍼 풀 상태 확인 거의 불가능

- MySQL 8.0 버전 이후 : `information_schema` 데이터베이스의 `innodb_cached_indexes` 테이블 새로 추가됨.
  -> 인덱스 별로 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인 가능

### 4.2.8 Double Writer Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록
- `파셜 페이지(Partial-Page)`, `톤 페이지(Torn-Page)` : 페이지가 일부만 기록되는 현상

    - 소프트웨어의 오작동이나 시스템 비정상 종료 등으로 발생 가능

<br>

**Double-Write 기법**
- 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록
- 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기 실행
- Double Write 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용됨.
- `innodb_double_write` 시스템 변수로 기능 사용 여부 설정
- 데이터 무결성이 중요한 경우에는 사용하는 것이 좋음(SSD 처럼 랜덤 IO나 순차 IO 비용이 비슷한 경우에는 부담이 될 수 있지만...)

<img src="https://velog.velcdn.com/images/hyolim/post/52ee67fa-965b-4f73-a7b5-e5f2b5674356/image.png" width="500">


### 4.2.9 언두 로그
- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준 보장하기 위해 DML로 변경되기 이전 버전의 데이터 별도로 백업
- 이러한, 백업된 데이터를 `언두 로그`라고 함.
  <br>
- 언두 로그의 사용

    - 트랜잭션 보장
      : 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 이전 데이터로 복구해야 하는데, 언두 로그에 백업해 둔 이전 버전의 데이터를 이용해 복구
      - 격리 수준 보장
      : 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 함.

- 언두 로그는 InnoDB 스토리지 엔진에서 매우 중요한 역할 담당하지만 관리 비용 많이 듦.

#### 4.2.9.1 언두 로그 모니터링
- 언두 로그 데이터의 사용 용도

    - 트랜잭션의 롤백 대비용
    - 트랜잭션의 격리 수준 유지하면서 높은 동시성 제공

- MySQL 8.0 이후에는 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간 줄이기 가능 & MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여주기도

- MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 안 좋음

    - 모니터링을 통해 언두 로그 건수 및 급중 여부 확인하여 관리 필요

#### 4.2.9.2 언두 테이블스페이스 관리
- `언두 테이블스페이스(Undo Tablespace)` : 언두 로그가 저장되는 공간
- `MySQL 5.6 버전 이전` : 언두 로그가 모두 시스템 테이블스페이스 ibdata.ibd)에 저장됨.
- `MySQL 5.6 버전` : `innodb_undo_tablespaces` 시스템 변수 도입
  -> 2이상으로 설정하면, 별도의 언두 로그 파일 사용하게 됨.
- `MySQL 8.0 버전` : `innodb_undo_tablespaces` 시스템 변수 descreted & 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선
  <br>

- 언두 테이블스페이스 형태 구성
  <img src="https://velog.velcdn.com/images/hyolim/post/53c96fcb-2796-43b5-bd86-fd879bb54e9a/image.png" width="400">
- 하나의 언두 테이블 스페이스는 1개 이상 128개 이하의 롤백 세크먼트 가짐
- 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가짐.

- 최대 동시 트랜잭션 수 = (InnoDB의 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)

- **Undo tablespace truncate**
  : 언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것

    - 자동모드
    - 수동모드

### 4.2.10 체인지 버퍼
- 버퍼 풀에 변경해야 할 인덱스 페이지가 있으면 바로 수행하지만, 그렇지 않으면 디스크로부터 읽어와서 업데이트 해야하면 임시공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능 향상시킴
- `체인지 버퍼(Change Buffer)` : 임시 메모리 공간

- 인덱스 업데이트의 경우에는 랜덤하게 디스크 읽는 작업이 필요함.
- 유니크 인덱스의 경우 체인지 버퍼 사용 불가 : 결과 전달 전 반드시 중복 여부 체크 필요하기 때문
- `체인지 버퍼 머지 스레드(Merge thread)` : 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이때의 스레드

### 4.2.11 리두 로그 및 로그 버퍼
- 리두 로그(Redo Log)는 트랜잭션의 4가지 요소인 ACID 중 Durable에 해당하는 영속성과 가장 밀접하게 연관
- 리두 로그는 하드웨어나 소프트웨어 등 여러 문제점으로 인해 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터 잃지 않게 해주는 안전장치
- 리두 로그는 대체로 쓰기 비용이 낮은 자료 구조를 가진 형태

- 리두 로그의 필요성

    1. 커밋됐지만 데이터 파일에 기록되지 않은 데이터
       : 리두 로그에 저장된 데이터를 데이터 파일에 복사하면 됨.
       2. 롤백됐지만 데이터 파일에 이미 기록된 데이터
       : 변경이 커밋, 롤백, 실행 중이엇는지 확인하기 위해 필요

- 데이터베이스에서 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 하는 것이 좋음.

- `innodb_flush_log_at_trx_commit` : InnoDB 스토리지 엔진에서 리두 로그를 어느 주기로 디스크에 동기화할지 결정

#### 4.2.11.1 리두 아카이빙
- MySQL 8.0 버전부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙 할 수 있는 기능 추가됨.
- MySQL 엔터프라이즈 백업이나 Xtrabackup 툴은 데이터 파일 복사하는 동안 InnoDB 스토리지 엔진의 리두 로그에 쌓인 내용 추적하면서 새로 추가된 리두 로그 엔트리 복사함.
  -> 데이터 변경이 많아서 리두 로그가 덮어쓰인다 하더라도 백업 실패하지 않게 해줌.
- 백업 툴이 리두 로그 아카이빙 사용하려면 `innodb_redo_log_archive_dirs` 시스템 변수 설정 필요

    - `innodb_redo_log_archive_start UDF` 실행
    - 이 세션이 끊어지지 않고 유지돼야 리두 로그 아카이빙이 계속 실행됨.
    - 작업이 끝나면 반드시 `innodb_redo_log_archive_stop UDF`로 아카이빙 정상 종료해야 함.

#### 4.2.11.2 리두 로그 활성화 및 비활성화
- 리두로그는 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화되어 있음.
- MySQL 서버에서는 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두 로그(트랜잭션 로그)는 항상 디스크로 기록됨.
- MySQL 8.0버전부터는 수동으로 리두 로그 활성화하거나 비활성화 가능

### 4.2.12 어댑티브 해시 인덱스
- `어댑티브 해시 인덱스(Adaptive Hash Index)` : 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동 생성하는 인덱스
- `innodb_adaptive_hash_index` 시스템 변수로 활성 / 비활성 가능
- B-Tree 검색 시간을 줄여주기 위해 도입된 기능

    - 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스 만듦.
    - 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지 즉시 찾아갈 수 있음.
    - B-Tree의 루트 노드부터 리프 노드까지 찾아가는 비용은 없어지고, CPU는 적은 일을 하고, 쿼리 성능은 빨라짐.

- 해시 인덱스

    - '인덱스 키 값'과 해당 인덱스 키 값이 저장된 '데이터 페이지 주소'의 쌍으로 관리됨.
    - 인덱스 키 값은 'B-Tree 인덱스의 고유번호(Id)'와 'B-Tree 인덱스의 실제 키 값' 조합으로 생성됨.
    - 'B-Tree 인덱스의 고유번호(Id)'를 가지는 이유는 InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재하기 때문
    - B-Tree 인덱스의 실제 키 값'은 데이터 페이지의 메모리 주소, 즉 InnoDB 버퍼 풀에 로딩된 페이지의 주소 의미

<br>

**어댑티브 해시 인덱스가 성능 향상에 도움이 안 되는 경우**
- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(JOIN or Like 패턴 검색)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

**어댑티브 해시 인덱스가 성능 향상에 도움이 되는 경우**
- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
- 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
  <br>
- 'hash searches/s'를 사용하여 어댑티브 해시 인덱스 활성 여부 결정하는 것이 좋음.

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
- MySQL 8.0버전부터는 MyISAM 스토리지 엔진만이 가지는 장점 없는 상태
- MEMORY 엔진도 동시성 처리 기능에 있어서 InnoDB 스토리지 엔진을 따라가지 못함.
----
## 4.3 MySAM 스토리지 엔진 아키텍처

### 4.3.1 키 캐시
- InnoDB의 버퍼 풀과 비슷한 역할을 함.
- MyISAM 키 캐시는 인덱스만을 대상으로 작동 & 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할

### 4.3.2 운영체제의 캐시 및 버퍼
- MyISAM 테이블의 데이터에 대해서 디스크로부터 I/O를 해결해 줄 만한 내시나 버퍼링 기능을 갖지 않음.
  -> 데이터 읽기 쓰기 작업은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청될 수 밖에 없음.
  -> 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모리를 비워둬야만 쿼리 처리가 느려지는 문제 방지 가능

### 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조
- `InnoDB` : 프라이머리 키에 의해 클러스터링되어 저장됨.
- `MyISAM` : 프라이머리 키에 대해 클러스터링 없이 데이터 파일이 힙(Heap) 공간처럼 활용됨. -> INSERT되는 순서대로 데이터 파일에 저장

    - 모두 ROWID라는 물리적인 주소값을 가짐 & 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 가지는 포인터를 가짐.
    - 가변 길이와 고정 길이 두 가지 방법으로 ROWID 저장됨.

----
## 4.4 MySQL 로그 파일
### 4.4.1 에러 로그 파일
- MySQL 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일
- MySQL 설정 파일(my.cnf)에서 log_eror라는 이름의 파라미터로 정의된 경로에 생성됨.
    - 별도 정의되지 않은 경우 .err라는 확장자가 붙은 파일로 생성됨.

#### 4.4.1.1 MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
- MySQL 서버가 정상 기동('mysqld: ready for connections')한 경우와 새로 변경하거나 추가한 파라미터에 대한 특별한 에러나 경고 메시지가 없으면 정상적으로 적용된 것
- 특정 변수가 무시(ignore)된 경우에는 MySQL 서버는 정상적으로 기동하지만 해당 파라미터는 MySQL에 적용되지 못했음을 의미
- 변수명을 인식하지 못하거나 설정된 파라미터 값의 내용을 인식하지 못하는 경우에는 MySQL 서버가 에러 메시지 출력 & 시작 못했다는 메시지 보여줌

#### 4.4.1.2 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
- 문제가 복구되지 못할 때 에러 메시지 출력하고 재종료 될 것
- `innodb_force_recovery` 파라미터를 0보다 큰 값으로 설정하고 재시작해야만 MySQL 시작 가능

#### 4.4.1.3 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
- 에러 로그 검토 과정에서 알게됨.

#### 4.4.1.4 비정상적으로 종료된 커넥션 메시지(Aborted connection)
- 너무 많이 기록된다면 애플리케이션 커넥션 종료 로직 검토 필요
- `max_count_errors`가 너무 작은 경우에 "Host 'host_name' is bllocked" 발생 가능

#### 4.4.1.5 InnoDB의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS 같은)의 결과 메시지
- InnoDB의 테이블 모니터링이나 락 모니터링 또는 InnoDB의 엔진 상태를 조회하는 명령은 상대적으로 큰 메시지를 에러 로그에 기록함.
- 모니터링 활성화 상태로 만들어 놓고 유지하는 경우에는 사용 후에 다시 비활성화하여 에러 로그 파일 커지지 않게 해야 함.

#### 4.4.1.6 MySQL의 종료 메시지
- 왜 MySQL 서버가 종료됐는지 확인하는 유일한 방법

### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)
- MySQL 서버에서 실행되는 쿼리 전체 목록 뽑아서 검토할 때, 쿼리 로그 활성화해서 쿼리를 쿼리 로그 파일로 기록한 다음 그 파일 검토하면 됨.
- 쿼리 로그 파일에는 시간 단위로 실행됐던 쿼리 내용 모두 기록됨.
- 제너럴 쿼리 로그는 쿼리 요청 받으면 바로 기록 -> 실행 중 에러 발생해도 로그 파일에 기록됨.
- `general_log_fle` 파라미터에 설정되어 있음.

### 4.4.3 슬로우 쿼리 로그
- MySQL 서버의 쿼리 튜닝

    - 서비스 적용되기 전 전체적으로 튜닝하는 경우
    - 서비스 운영 중 MySQL 서버의 전체적인 성능 저하 검사 OR 정기적인 점검을 위한 튜닝
        - 어떤 쿼리가 문제인지 파악 어려움
        - 슬로우 쿼리가 많은 도움됨.

- 슬로우 쿼리 로그 파일에는 `long_query_time` 시스템 변수에 설정한 시간 이상 소요된 쿼리 모두 기록됨.


#### 4.4.3.1 슬로우 쿼리 통계
- 분석 결과의 최상단에 표시됨.
- 모든 쿼리 대상으로 슬로우 쿼리 로그 실행 시간(Exec time), 잠금 대기 시간(Lock time) 등에 대해 평균, 최소 / 최대 값 표시

#### 4.4.3.2 실행 빈도 및누적 실행 시간순 랭킹
- 각 쿼리별로 응답 시간과 실행 횟수 보여줌.

#### 4.4.3.3 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보
- Query ID 별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용 보여줌.
- 쿼리가 얼마나 실행됐는지, 쿼리 응답 시간에 대한 히스토그램 같은 상세한 내용 보여줌.

# Chapter4 - 아키텍처 (4.2.7~끝)

### 4.2.7 InnoDB 버퍼 풀

-   디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
-   쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 수행
    -   왜 쓰기 작업을 지연시켜야 하는가?
        -   변경된 데이터를 모아서 처리하면 랜덤한 디스크의 작업 횟수를 줄일 수 있기 때문

#### 크기 설정

-   InnoDB 버퍼 풀 크기 설정 시 고려할 사항
    -   운영체제
    -   클라이언트 스레드
    -   MySQL 서버 내에서는 특별한 경우 레코드 버퍼가 커지는 경우를 고려해야 함
-   버퍼 풀 크기 동적으로 설정하기
    -   가능하면 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 증가시키는 게 최적
    -   버퍼 풀의 크기를 증가시킬 땐 MySQL 서버가 여유로울 때 진행하기
    -   버퍼 풀의 크기를 줄이는 건 서비스 영향도가 매우 크므로 웬만해서는 X
-   버퍼 풀 인스턴스
    -   버퍼 풀을 여러 개로 쪼개서 관리 (각 버퍼 풀을 `버퍼 풀 인스턴스`라고 함)
    -   왜 쪼개서 관리하나?
        -   기존에는 버퍼 풀이 하나였는데, 이를 관리하는 잠금(세마포어) 때문에 경합(여러 스레드가 같은 자원을 사용하기 위해 대기하는 상황 -> 성능 저하)이 발생함
        -   버퍼 풀을 쪼개서 관리하면 개별 버퍼 풀 마다 잠금(세마포어)이 걸리고, 덕분에 경합을 분산시킬 수 있음

#### 버퍼 풀의 구조

-   버퍼 풀의 공간 단위

    -   버퍼 풀 메모리를 **페이지 크기**(innodb_page_size 시스템 변수에 설정된)의 조각으로 쪼개어 관리
        -   디스크에서의 페이지 (데이터베이스 문맥): 데이터베이스가 디스크에 데이터를 저장하는 기본 단위
        -   테이블의 데이터, 인덱스 등이 이 페이지 단위로 저장됨
    -   디스크에서 메모리(버퍼 풀)로 데이터를 읽어올 때 페이지 단위로 읽어옴

-   버퍼 풀의 페이지 크기의 조각들을 관리하기 위해 다음과 같은 자료구조를 사용:

    -   LRU(Least Recently Used) 리스트
        -   LRU와 MRU(Most Recently Used)가 결합된 리스트
        -   한번 읽어온 페이지를 최대한 오랫동안 InnoDB의 버퍼 풀의 메모리에 유지해 디스크 읽기를 최소화하기 위함이다.
    -   플러시(Flush) 리스트
        -   더티 페이지(디스크로 동기화되지 않은 페이지)들의 변경 시점을 관리하는 자료구조
        -   이 리스트를 바탕으로 디스크와 동기화(플러시)가 필요한 페이지들을 결정
    -   프리(Free) 리스트
        -   버퍼 풀에서 사용되지 않고 있는 조각 명단을 기록

-   [버퍼 풀/리두 로그/디스크]에 쓰기가 발생 상황
    -   데이터 변경 시점
        -   버퍼 풀: 변경된 데이터가 페이지에 즉시 반영 (더티 페이지가 됨)
        -   리두 로그: 변경 내용이 로그에 기록되고 디스크에 기록됨 (WAL)
            -   WAL: Write Ahead Logging
        -   데이터 파일(디스크): 아직 변경되지 않은 상태 유지
    -   체크포인트 발생 시점
        -   버퍼 풀의 더티 페이지들이 디스크의 데이터 파일과 동기화됨
        -   이 시점을 리두 로그에 기록 (복구 시작점 표시)

#### 버퍼 풀과 리두 로그

-   버퍼 풀과 리두 로그의 저장 형식의 차이점
    -   버퍼 풀: 실제 데이터 페이지의 현재 상태를 그대로 담고 있음. (변경되면 변경된 최종 상태만을 저장)
        -   예: users 테이블의 id=1인 row의 현재 상태는 {name:"Kim", age:30}
    -   리두 로그: 변경 이력을 순차적으로 기록
        -   예: users 테이블의 id=1인 row의 name을 'Lee'에서 'Kim'으로 변경
    -   이렇게 다르게 저장하는 이유는, 버퍼 풀은 빠른 데이터 읽기와 변경을 위해 현재 상태를 바로 사용하는 데에 목적이 있고, 리두 로그는 장애 시 변경 과정을 순차적으로 재실행하여 복구하는 데에 목적이 있기 때문이다.

![Pasted image 20250102112336](https://github.com/user-attachments/assets/4f056754-55bd-47a2-b69f-cd710123b7e3)

-   리두 로그 시스템

    -   리두 로그는 여러 개의 파일을 원형으로 연결하여 사용한다. 마치 원형 큐처럼 동작한다.
    -   마치 이런 느낌으로 동작:

        ```
        [상황 1: 처음 로그 기록]
        [A][B][C][D][E][F][G][_][_][_]
                              ↑
                            LSN: 7
        Checkpoint LSN: 0

        [상황 2: A, B, C를 디스크에 기록 후]
        [A][B][C][D][E][F][G][_][_][_]
                  ↑           ↑
        Checkpoint LSN: 3   LSN: 7
        (A,B,C는 재사용 가능)

        [상황 3: 공간 재사용]
        [X][B][C][D][E][F][G][H][I][J]
            ↑     ↑
        LSN: 10  Checkpoint LSN: 3
        ```

-   공간 관리:

    -   재사용 가능한 공간: 디스크에 기록 완료된 영역
    -   활성 리두 로그: 아직 디스크에 기록되지 않은 영역

-   LSN(Log Sequence Number)과 체크포인트

    -   LSN: 로그가 기록될 때마다 증가하는 순차적 번호
    -   체크포인트: 주기적으로 발생하여 리두 로그와 더티 페이지를 디스크에 동기화
        -   체크포인트 LSN보다 작은 번호를 가진
            -   더티페이지들을 디스크로 동기화
            -   리두 로그 엔트리들을 디스크로 동기화
    -   체크포인트 에이지: 가장 최근 체크포인트 LSN과 현재 LSN의 차이 (활성 리두 로그 크기)

-   버퍼 풀과 리두 로그의 크기 밸런스 비교해보기
    1.  InnoDB 버퍼풀은 100GB, 리두 로그 파일 전체 크기 100MB
        -   계산
            -   리두 로그의 엔트리 개수 = 100MB / 4KB(평균 엔트리 크기) = 25600
            -   버퍼풀의 최대 더티 페이지 크기 = 25600 \* 16KB(페이지 크기) = 400MB
        -   발생할 수 있는 문제점
            -   버퍼 풀이 100GB인데, 더티 페이지는 400MB밖에 적재할 수 없다.
            -   즉, 쓰기 버퍼링 효과를 누리기 어렵다. 자꾸 디스크에 씀.
    2.  InnoDB 버퍼풀은 100MB, 리두 로그 파일 전체 크기 100GB
        -   계산
            -   리두 로그의 엔트리 개수 = 100GB / 4KB(평균 엔트리 크기) = 25 \* 2^20
            -   버퍼풀의 최대 더티 페이지 크기 = 25 _ 2^20 _ 16KB(페이지 크기) = 400GB
        -   발생할 수 있는 문제점
            -   리두 로그로 계산했을 땐 400GB까지 더티 페이지가 가능하나, 버퍼 풀 자체가 100MB이므로 최대 허용 가능 더티 페이지는 100MB크기가 된다.
            -   버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면 InnoDB는 갑자기 한꺼번에 많은 더티 페이지를 기록해야한다.
    -   결론
        -   버퍼 풀의 크기가 100GB이하의 MySQL 서버라면, 리두 로그 파일의 전체 크기를 5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가며 최적값을 선택하자.

#### 버퍼 풀 플러시(Buffer Pool Flush)

디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같이 두 개의 플러시 기능을 백그라운드로 실행함:

-   플러시 리스트 플러시
    -   목적: 리두 로그 공간 재활용
    -   리두 로그 공간을 재활용하려면 당연히 해당 리두 로그 엔트리랑 연결된 버퍼 풀의 더티 페이지가 디스크에 동기화 되어야 함.
    -   플러시 리스트에서 오래 전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행함.
    -   클리너 스레드: 더티 페이지를 디스크에 동기화 해주는 스레드
-   LRU 리스트 플러시
    -   목적: 버퍼 풀의 새로운 페이지를 위한 공간 확보
    -   사용 빈도가 낮은 데이터 페이지들을 제거
    -   더티 페이지는 디스크에 기록하고, 클린 페이지는 프리 리스트로 이동

#### 버퍼 풀 상태 백업 및 복구

-   워밍 업: 디스크의 데이터가 버퍼 풀에 적재돼있는 상태
    -   MySQL 서버 셧다운 한 뒤 다시 시작하면 쿼리 처리 성능이 평상시보다 1/10도 안 되는 경우가 대부분. 이 때에 워밍업 필요.
-   셧다운 전 버퍼 풀 상태를 백업해두기

    ```sql
    -- // MySQL 서버 셧다운 전에 버퍼 풀의 상태 백업
    SET GLOBAL innodb_buffer_pool_dump_now=ON;

    -- // MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
    SET GLOBAL innodb_buffer_pool_load_now=ON;
    ```

-   백업 자동화: MySQL 서버의 설정 파일에 innodb_buffer_pool_dump_at_shutdown과 innodb_buffer_pool_load_at_startup 설정을 넣어두면 됨.

#### 버퍼 풀의 적재 내용 확인

information_schema 데이터베이스에 innodb_cached_indexes 테이블을 이용하면 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있다.

![[Pasted image 20250103115228.png]]

### 4.2.8 Double Write Buffer

-   왜 쓰는가?
    -   더티 페이지를 디스크에 쓰다가 중간에 잘려버리는 문제를 해결하기 위해서
    -   중간에 쓰다가 실패하면 해당 페이지는 리두 로그로 복구가 불가능하다. 리두 로그에는 페이지의 변경 사항만 저장되어 있기 때문이다.
-   어떻게 쓰이는가?
    1.  A~E번의 페이지를 디스크에 쓴다면, 일단 Double Write 버퍼에 A~E 전체를 기록한다.
    2.  이후에 스토리지 엔진이 각 더티 페이지를 파일의 적당한 위치에 랜덤 쓰기를 해준다.

### 4.2.9 언두 로그

-   언두 로그: DML로 변경되기 이전 버전의 데이터를 백업 (트랜잭션/격리 수준 보장 목적)
    -   참고로, 리두 로그: 변경 사항을 백업 (더티 페이지 지연 쓰기 & 시스템 장애 시 복구 목적)
-   트랜잭션 롤백 시, 격리 수준에 맞는 레코드를 불러올 시에 언두 로그에서 데이터를 꺼내온다.
-   트랜잭션을 시작해놓고 완료를 하지 않는 경우, 방치되는 동안 디스크에 언두 로그 크기가 커질 것이고, 조회 쿼리에서는 이 언두 로그가 커진 만큼 싹 스캔해야하기 때문에 오버헤드가 있다.

#### 언두 테이블스페이스 관리

-   언두 테이블스페이스: 언두 로그가 저장되는 공간
-   (대강 넘김..)

### 4.2.10 체인지 버퍼

-   체인지 버퍼란?
    -   업데이트 된 인덱스 내용을 임시로 메모리에 올려둘 때 사용하는 공간
        -   인덱스 업데이트: 레코드 쓰기 시에는 레코드뿐만 아니라 인덱스를 업데이트 하는 작업도 필요
        -   인덱스를 업데이트할 때, 인덱스가 버퍼 풀에 있으면 바로 업데이트가 가능하나, 그렇지 않다면 디스크에 내려가 랜덤 읽기가 필요하므로 성능 저하. 이를 해결하기 위해 체인지 버퍼를 사용!
-   체인지 버퍼의 인덱스 레코드 조각
    -   백그라운드 스레드 중 버퍼 머지 스레드에 의해 병합됨

### 4.2.11 리두 로그 및 로그 버퍼

-   리두 로그의 목적?

    -   ACID 중에서 D에 해당하는 영속성!
    -   서버가 비정상 종료되었을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치임

    > **트랜잭션 무결성 보장을 위한 ACID**
    > Atomic: 원자성 (all or nothing)
    > Consistent: 일관성 (트랜잭션 전후의 모순이 없어야함. 이를테면 계좌 이체 시 총액이 변하면 안 된다든지)
    > Isolated: 독립성 (트랜잭션 간에는 서로 영향을 주면 안 됨. 각 트랜잭션이 다른 트랜잭션의 중간 상태를 볼 수 없음)
    > Durable: 지속성 (한 번 저장된 데이터는 지속적으로 유지돼야 함. 시스템 장애가 발생해도 커밋된 데이터는 유지돼야 함.)
    > 참고: 일관성과격리성은 쉽게 정의하기는 힘들지만, 이 두 가지 속성은 서로 다른 두 개의 트랜잭션에서 동일 데이터를 조회하고 변경하는 경우에도 상호 간섭이 없어야 한다는 것을 의미함

-   WAL(Write Ahead Log)

    -   MySQL 서버를 포함한 대부분의 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다.

-   일관되지 않은 데이터인 경우 어떻게 복원?

    1.  커밋됐지만 데이터 파일에 기록되지 않은 데이터
        -   리두 로그 내용을 가져다가 데이터 파일에 기록하면 됨
    2.  롤백됐지만 데이터 파일에 이미 기록된 데이터
        -   언두 로그 내용을 가져다가 데이터 파일에 복원하면 됨
        -   롤백된건지 여부를 따지는 과정에선 리두 로그가 필요함

-   리두 로그는 트랜잭션 커밋 단위로 즉시 디스크에 기록되어야 안전함.
    -   하지만 트랜잭션이 커밋될 때마다 부하 우려가 있음.
    -   InnoDB에선 리두 로그를 주기적으로 디스크에 동기화하는 방법을 제공함

#### 리두 로그 아카이빙

-   리두 로그를 아카이빙하는 기능이 왜 필요한데?
    -   문제 상황:
        1. 데이터베이스 백업을 시작합니다 (예: 오후 2시)
            - 데이터 파일 크기가 100GB라 백업하는데 1시간이 걸린다고 가정
        2. 백업하는 1시간 동안:
            - 사용자들의 데이터 변경이 계속 발생 (insert/update/delete)
            - 이 변경사항들은 리두 로그에 기록됨
            - 백업 도구는 이 리두 로그도 같이 복사해야 함
        3. 그런데 리두 로그 공간이 제한적이라서:
            - 리두 로그 파일 크기가 1GB라고 가정
            - 변경사항이 많으면 1GB가 빠르게 채워짐
            - 공간이 부족하면 처음부터 다시 덮어쓰기 시작
        4. 문제 발생:
            - 오후 2:30분에 백업 도구가 "2:00~2:15 동안의 리두 로그"를 복사하려는데
            - 이미 새로운 변경사항들이 그 부분을 덮어써버림
            - 결과: 백업 실패
-   리두 로그 아카이빙을 통해 위와 같은 문제 상황을 해결할 수 있다
    -   데이터 변경이 많아서 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해줌
    -   백업 도구가 "이 로그는 백업에 필요하니 덮어쓰지 마세요"라고 표시
    -   MySQL은 해당 로그를 별도 공간에 보관(아카이빙)
    -   백업이 완료될 때까지 로그가 안전하게 보존됨
    -   결과: 안정적인 백업 가능

(구체적인 백업 방식은 p133~p134 참조)

#### 리두 로그 활성화 및 비활성화

-   리두 로그는 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록 못한 트랜잭션 복구를 위해 항상 활성화되어 있다.
-   MySQL 서버에서 트랜잭션이 커밋되면, 파일 자체는 즉시 디스크로 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록된다.
-   수동으로 리두 로그를 활성화/비활성화 할 수 있는 방법이 있다.
-   만약 MySQL 서버가 비정상적으로 종료되어 데이터가 일부 손실돼도 괜찮다면 리두 로그 비활성화보단, innodb_flush_log_at_trx_commit 시스템 변수를 1이 아닌 0 또는 2로 설정해서 사용할 것을 권장한다.
    -   `innodb_flush_log_at_trx_commit = 1` (기본값)
        -   트랜잭션이 커밋될 때마다 리두 로그를 즉시 디스크에 기록
        -   가장 안전하지만 성능은 가장 낮음
    -   `innodb_flush_log_at_trx_commit = 0` or `2`
        -   리두 로그는 계속 생성됨 (복구 가능성 유지)
            -   다만, 리두 로그를 디스크에 기록하는 시점을 지연
            -   디스크 기록 빈도만 줄여서 성능은 좋아지지만 서버 비정상 종료 시 일부 데이터 손실 가능
            -   그래도 최악의 경우이더라도 1초 정도의 데이터만 손실

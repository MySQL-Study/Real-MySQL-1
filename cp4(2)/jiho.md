# Chapter4 - 아키텍처 (4.2.7~끝)

### 4.2.7 InnoDB 버퍼 풀

-   디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
-   쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 수행
    -   왜 쓰기 작업을 지연시켜야 하는가?
        -   변경된 데이터를 모아서 처리하면 랜덤한 디스크의 작업 횟수를 줄일 수 있기 때문

#### 크기 설정

-   InnoDB 버퍼 풀 크기 설정 시 고려할 사항
    -   운영체제
    -   클라이언트 스레드
    -   MySQL 서버 내에서는 특별한 경우 레코드 버퍼가 커지는 경우를 고려해야 함
-   버퍼 풀 크기 동적으로 설정하기
    -   가능하면 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 증가시키는 게 최적
    -   버퍼 풀의 크기를 증가시킬 땐 MySQL 서버가 여유로울 때 진행하기
    -   버퍼 풀의 크기를 줄이는 건 서비스 영향도가 매우 크므로 웬만해서는 X
-   버퍼 풀 인스턴스
    -   버퍼 풀을 여러 개로 쪼개서 관리 (각 버퍼 풀을 `버퍼 풀 인스턴스`라고 함)
    -   왜 쪼개서 관리하나?
        -   기존에는 버퍼 풀이 하나였는데, 이를 관리하는 잠금(세마포어) 때문에 경합(여러 스레드가 같은 자원을 사용하기 위해 대기하는 상황 -> 성능 저하)이 발생함
        -   버퍼 풀을 쪼개서 관리하면 개별 버퍼 풀 마다 잠금(세마포어)이 걸리고, 덕분에 경합을 분산시킬 수 있음

#### 버퍼 풀의 구조

-   버퍼 풀의 공간 단위

    -   버퍼 풀 메모리를 **페이지 크기**(innodb_page_size 시스템 변수에 설정된)의 조각으로 쪼개어 관리
        -   디스크에서의 페이지 (데이터베이스 문맥): 데이터베이스가 디스크에 데이터를 저장하는 기본 단위
        -   테이블의 데이터, 인덱스 등이 이 페이지 단위로 저장됨
    -   디스크에서 메모리(버퍼 풀)로 데이터를 읽어올 때 페이지 단위로 읽어옴

-   버퍼 풀의 페이지 크기의 조각들을 관리하기 위해 다음과 같은 자료구조를 사용:

    -   LRU(Least Recently Used) 리스트
        -   LRU와 MRU(Most Recently Used)가 결합된 리스트
        -   한번 읽어온 페이지를 최대한 오랫동안 InnoDB의 버퍼 풀의 메모리에 유지해 디스크 읽기를 최소화하기 위함이다.
    -   플러시(Flush) 리스트
        -   더티 페이지(디스크로 동기화되지 않은 페이지)들의 변경 시점을 관리하는 자료구조
        -   이 리스트를 바탕으로 디스크와 동기화(플러시)가 필요한 페이지들을 결정
    -   프리(Free) 리스트
        -   버퍼 풀에서 사용되지 않고 있는 조각 명단을 기록

-   [버퍼 풀/리두 로그/디스크]에 쓰기가 발생 상황
    -   데이터 변경 시점
        -   버퍼 풀: 변경된 데이터가 페이지에 즉시 반영 (더티 페이지가 됨)
        -   리두 로그: 변경 내용이 로그에 기록되고 디스크에 기록됨 (WAL)
            -   WAL: Write Ahead Logging
        -   데이터 파일(디스크): 아직 변경되지 않은 상태 유지
    -   체크포인트 발생 시점
        -   버퍼 풀의 더티 페이지들이 디스크의 데이터 파일과 동기화됨
        -   이 시점을 리두 로그에 기록 (복구 시작점 표시)

#### 버퍼 풀과 리두 로그

-   버퍼 풀과 리두 로그의 저장 형식의 차이점
    -   버퍼 풀: 실제 데이터 페이지의 현재 상태를 그대로 담고 있음. (변경되면 변경된 최종 상태만을 저장)
        -   예: users 테이블의 id=1인 row의 현재 상태는 {name:"Kim", age:30}
    -   리두 로그: 변경 이력을 순차적으로 기록
        -   예: users 테이블의 id=1인 row의 name을 'Lee'에서 'Kim'으로 변경
    -   이렇게 다르게 저장하는 이유는, 버퍼 풀은 빠른 데이터 읽기와 변경을 위해 현재 상태를 바로 사용하는 데에 목적이 있고, 리두 로그는 장애 시 변경 과정을 순차적으로 재실행하여 복구하는 데에 목적이 있기 때문이다.

![Pasted image 20250102112336](https://github.com/user-attachments/assets/4f056754-55bd-47a2-b69f-cd710123b7e3)

-   리두 로그 시스템

    -   리두 로그는 여러 개의 파일을 원형으로 연결하여 사용한다. 마치 원형 큐처럼 동작한다.
    -   마치 이런 느낌으로 동작:

        ```
        [상황 1: 처음 로그 기록]
        [A][B][C][D][E][F][G][_][_][_]
                              ↑
                            LSN: 7
        Checkpoint LSN: 0

        [상황 2: A, B, C를 디스크에 기록 후]
        [A][B][C][D][E][F][G][_][_][_]
                  ↑           ↑
        Checkpoint LSN: 3   LSN: 7
        (A,B,C는 재사용 가능)

        [상황 3: 공간 재사용]
        [X][B][C][D][E][F][G][H][I][J]
            ↑     ↑
        LSN: 10  Checkpoint LSN: 3
        ```

-   공간 관리:

    -   재사용 가능한 공간: 디스크에 기록 완료된 영역
    -   활성 리두 로그: 아직 디스크에 기록되지 않은 영역

-   LSN(Log Sequence Number)과 체크포인트

    -   LSN: 로그가 기록될 때마다 증가하는 순차적 번호
    -   체크포인트: 주기적으로 발생하여 리두 로그와 더티 페이지를 디스크에 동기화
        -   체크포인트 LSN보다 작은 번호를 가진
            -   더티페이지들을 디스크로 동기화
            -   리두 로그 엔트리들을 디스크로 동기화
    -   체크포인트 에이지: 가장 최근 체크포인트 LSN과 현재 LSN의 차이 (활성 리두 로그 크기)

-   버퍼 풀과 리두 로그의 크기 밸런스 비교해보기
    1.  InnoDB 버퍼풀은 100GB, 리두 로그 파일 전체 크기 100MB
        -   계산
            -   리두 로그의 엔트리 개수 = 100MB / 4KB(평균 엔트리 크기) = 25600
            -   버퍼풀의 최대 더티 페이지 크기 = 25600 \* 16KB(페이지 크기) = 400MB
        -   발생할 수 있는 문제점
            -   버퍼 풀이 100GB인데, 더티 페이지는 400MB밖에 적재할 수 없다.
            -   즉, 쓰기 버퍼링 효과를 누리기 어렵다. 자꾸 디스크에 씀.
    2.  InnoDB 버퍼풀은 100MB, 리두 로그 파일 전체 크기 100GB
        -   계산
            -   리두 로그의 엔트리 개수 = 100GB / 4KB(평균 엔트리 크기) = 25 \* 2^20
            -   버퍼풀의 최대 더티 페이지 크기 = 25 _ 2^20 _ 16KB(페이지 크기) = 400GB
        -   발생할 수 있는 문제점
            -   리두 로그로 계산했을 땐 400GB까지 더티 페이지가 가능하나, 버퍼 풀 자체가 100MB이므로 최대 허용 가능 더티 페이지는 100MB크기가 된다.
            -   버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면 InnoDB는 갑자기 한꺼번에 많은 더티 페이지를 기록해야한다.
    -   결론
        -   버퍼 풀의 크기가 100GB이하의 MySQL 서버라면, 리두 로그 파일의 전체 크기를 5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가며 최적값을 선택하자.

#### 버퍼 풀 플러시(Buffer Pool Flush)

디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같이 두 개의 플러시 기능을 백그라운드로 실행함:

-   플러시 리스트 플러시
    -   목적: 리두 로그 공간 재활용
    -   리두 로그 공간을 재활용하려면 당연히 해당 리두 로그 엔트리랑 연결된 버퍼 풀의 더티 페이지가 디스크에 동기화 되어야 함.
    -   플러시 리스트에서 오래 전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행함.
    -   클리너 스레드: 더티 페이지를 디스크에 동기화 해주는 스레드
-   LRU 리스트 플러시
    -   목적: 버퍼 풀의 새로운 페이지를 위한 공간 확보
    -   사용 빈도가 낮은 데이터 페이지들을 제거
    -   더티 페이지는 디스크에 기록하고, 클린 페이지는 프리 리스트로 이동

#### 버퍼 풀 상태 백업 및 복구

-   워밍 업: 디스크의 데이터가 버퍼 풀에 적재돼있는 상태
    -   MySQL 서버 셧다운 한 뒤 다시 시작하면 쿼리 처리 성능이 평상시보다 1/10도 안 되는 경우가 대부분. 이 때에 워밍업 필요.
-   셧다운 전 버퍼 풀 상태를 백업해두기

    ```sql
    -- // MySQL 서버 셧다운 전에 버퍼 풀의 상태 백업
    SET GLOBAL innodb_buffer_pool_dump_now=ON;

    -- // MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
    SET GLOBAL innodb_buffer_pool_load_now=ON;
    ```

-   백업 자동화: MySQL 서버의 설정 파일에 innodb_buffer_pool_dump_at_shutdown과 innodb_buffer_pool_load_at_startup 설정을 넣어두면 됨.

#### 버퍼 풀의 적재 내용 확인

information_schema 데이터베이스에 innodb_cached_indexes 테이블을 이용하면 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있다.

![Pasted image 20250103115228](https://github.com/user-attachments/assets/366c5536-e628-49fb-a800-fd4caf4233e1)

### 4.2.8 Double Write Buffer

-   왜 쓰는가?
    -   더티 페이지를 디스크에 쓰다가 중간에 잘려버리는 문제를 해결하기 위해서
    -   중간에 쓰다가 실패하면 해당 페이지는 리두 로그로 복구가 불가능하다. 리두 로그에는 페이지의 변경 사항만 저장되어 있기 때문이다.
-   어떻게 쓰이는가?
    1.  A~E번의 페이지를 디스크에 쓴다면, 일단 Double Write 버퍼에 A~E 전체를 기록한다.
    2.  이후에 스토리지 엔진이 각 더티 페이지를 파일의 적당한 위치에 랜덤 쓰기를 해준다.

### 4.2.9 언두 로그

-   언두 로그: DML로 변경되기 이전 버전의 데이터를 백업 (트랜잭션/격리 수준 보장 목적)
    -   참고로, 리두 로그: 변경 사항을 백업 (더티 페이지 지연 쓰기 & 시스템 장애 시 복구 목적)
-   트랜잭션 롤백 시, 격리 수준에 맞는 레코드를 불러올 시에 언두 로그에서 데이터를 꺼내온다.
-   트랜잭션을 시작해놓고 완료를 하지 않는 경우, 방치되는 동안 디스크에 언두 로그 크기가 커질 것이고, 조회 쿼리에서는 이 언두 로그가 커진 만큼 싹 스캔해야하기 때문에 오버헤드가 있다.

#### 언두 테이블스페이스 관리

-   언두 테이블스페이스: 언두 로그가 저장되는 공간
-   (대강 넘김..)

### 4.2.10 체인지 버퍼

-   체인지 버퍼란?
    -   업데이트 된 인덱스 내용을 임시로 메모리에 올려둘 때 사용하는 공간
        -   인덱스 업데이트: 레코드 쓰기 시에는 레코드뿐만 아니라 인덱스를 업데이트 하는 작업도 필요
        -   인덱스를 업데이트할 때, 인덱스가 버퍼 풀에 있으면 바로 업데이트가 가능하나, 그렇지 않다면 디스크에 내려가 랜덤 읽기가 필요하므로 성능 저하. 이를 해결하기 위해 체인지 버퍼를 사용!
-   체인지 버퍼의 인덱스 레코드 조각
    -   백그라운드 스레드 중 버퍼 머지 스레드에 의해 병합됨

### 4.2.11 리두 로그 및 로그 버퍼

-   리두 로그의 목적?

    -   ACID 중에서 D에 해당하는 영속성!
    -   서버가 비정상 종료되었을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치임

    > **트랜잭션 무결성 보장을 위한 ACID**
    > Atomic: 원자성 (all or nothing)
    > Consistent: 일관성 (트랜잭션 전후의 모순이 없어야함. 이를테면 계좌 이체 시 총액이 변하면 안 된다든지)
    > Isolated: 독립성 (트랜잭션 간에는 서로 영향을 주면 안 됨. 각 트랜잭션이 다른 트랜잭션의 중간 상태를 볼 수 없음)
    > Durable: 지속성 (한 번 저장된 데이터는 지속적으로 유지돼야 함. 시스템 장애가 발생해도 커밋된 데이터는 유지돼야 함.)
    > 참고: 일관성과격리성은 쉽게 정의하기는 힘들지만, 이 두 가지 속성은 서로 다른 두 개의 트랜잭션에서 동일 데이터를 조회하고 변경하는 경우에도 상호 간섭이 없어야 한다는 것을 의미함

-   WAL(Write Ahead Log)

    -   MySQL 서버를 포함한 대부분의 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다.

-   일관되지 않은 데이터인 경우 어떻게 복원?

    1.  커밋됐지만 데이터 파일에 기록되지 않은 데이터
        -   리두 로그 내용을 가져다가 데이터 파일에 기록하면 됨
    2.  롤백됐지만 데이터 파일에 이미 기록된 데이터
        -   언두 로그 내용을 가져다가 데이터 파일에 복원하면 됨
        -   롤백된건지 여부를 따지는 과정에선 리두 로그가 필요함

-   리두 로그는 트랜잭션 커밋 단위로 즉시 디스크에 기록되어야 안전함.
    -   하지만 트랜잭션이 커밋될 때마다 부하 우려가 있음.
    -   InnoDB에선 리두 로그를 주기적으로 디스크에 동기화하는 방법을 제공함

#### 리두 로그 아카이빙

-   리두 로그를 아카이빙하는 기능이 왜 필요한데?
    -   문제 상황:
        1. 데이터베이스 백업을 시작합니다 (예: 오후 2시)
            - 데이터 파일 크기가 100GB라 백업하는데 1시간이 걸린다고 가정
        2. 백업하는 1시간 동안:
            - 사용자들의 데이터 변경이 계속 발생 (insert/update/delete)
            - 이 변경사항들은 리두 로그에 기록됨
            - 백업 도구는 이 리두 로그도 같이 복사해야 함
        3. 그런데 리두 로그 공간이 제한적이라서:
            - 리두 로그 파일 크기가 1GB라고 가정
            - 변경사항이 많으면 1GB가 빠르게 채워짐
            - 공간이 부족하면 처음부터 다시 덮어쓰기 시작
        4. 문제 발생:
            - 오후 2:30분에 백업 도구가 "2:00~2:15 동안의 리두 로그"를 복사하려는데
            - 이미 새로운 변경사항들이 그 부분을 덮어써버림
            - 결과: 백업 실패
-   리두 로그 아카이빙을 통해 위와 같은 문제 상황을 해결할 수 있다
    -   데이터 변경이 많아서 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해줌
    -   백업 도구가 "이 로그는 백업에 필요하니 덮어쓰지 마세요"라고 표시
    -   MySQL은 해당 로그를 별도 공간에 보관(아카이빙)
    -   백업이 완료될 때까지 로그가 안전하게 보존됨
    -   결과: 안정적인 백업 가능

(구체적인 백업 방식은 p133~p134 참조)

#### 리두 로그 활성화 및 비활성화

-   리두 로그는 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록 못한 트랜잭션 복구를 위해 항상 활성화되어 있다.
-   MySQL 서버에서 트랜잭션이 커밋되면, 파일 자체는 즉시 디스크로 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록된다.
-   수동으로 리두 로그를 활성화/비활성화 할 수 있는 방법이 있다.
-   만약 MySQL 서버가 비정상적으로 종료되어 데이터가 일부 손실돼도 괜찮다면 리두 로그 비활성화보단, innodb_flush_log_at_trx_commit 시스템 변수를 1이 아닌 0 또는 2로 설정해서 사용할 것을 권장한다.
    -   `innodb_flush_log_at_trx_commit = 1` (기본값)
        -   트랜잭션이 커밋될 때마다 리두 로그를 즉시 디스크에 기록
        -   가장 안전하지만 성능은 가장 낮음
    -   `innodb_flush_log_at_trx_commit = 0` or `2`
        -   리두 로그는 계속 생성됨 (복구 가능성 유지)
            -   다만, 리두 로그를 디스크에 기록하는 시점을 지연
            -   디스크 기록 빈도만 줄여서 성능은 좋아지지만 서버 비정상 종료 시 일부 데이터 손실 가능
            -   그래도 최악의 경우이더라도 1초 정도의 데이터만 손실

### 4.2.12 어댑티브 해시 인덱스

-   사용자가 수동으로 만든 인덱스가 아니라, InnoDB 스토리지 엔진에서 자동으로 생성하는 인덱스
-   사용자가 자주 요청하는 데이터를 인덱스로 만들어줌.

-   왜 B-Tree가 아니라 '해시'인가?

    -   B-Tree는 루트부터 브랜치, 리프노드까지 쭉 내려가며 탐색한다. O(logN)
    -   해시는 키 값을 해시 함수에 넣으면 O(1)에 위치를 찾아 접근 가능하다.
    -   어댑티브 해시 인덱스는 B-Tree 인덱스의 검색 시간을 줄여주기 위해 도입된 기능이다.

-   어댑티브 해시 인덱스 구성

    -   key: `B-Tree 인덱스의 고유번호(Id)`와 `B-Tree 인덱스의 실제 키 값`의 조합
    -   value: `데이터 페이지의 메모리 주소`(InnoDB 버퍼 풀에 로딩된 페이지의 주소)
        (B-Tree 인덱스 Id가 필요한 이유는, InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스가 하나만 존재하기 때문. 즉, 모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장되어야 함)

-   어댑티브 해시 인덱스 성능

    -   CPU 사용률은 줄고
    -   초당 쿼리 처리 수는 늘어난다!

-   어댑티브 해시 인덱스의 경합 줄이기: 파티션

    -   어댑티브 해시는 하나의 메모리 객체이기 때문에 잠금(세마포어)에 의한 경합(Contention)이 심했다.
    -   이를 해결하기 위해서 파티션 기능을 활용할 수 있다.
        -   파티션 기능이란?

-   어댑티브 해시 인덱스의 단점

    -   디스크에서 읽어오는 경우가 빈번한 데이터베이스에선 도움이 안 된다.
        -   어댑티브 해시는 기본적으로 메모리에서 빨리 찾아오기 위해 사용하는 놈이므로, 디스크 읽기에는 아무런 도움을 주지 못한다.
    -   테이블 수정/삭제 시 오버헤드가 발생한다.
        -   해당 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야하기 때문

-   어댑티브 해시 인덱스가 도움이 되는지 불필요한 오버헤드를 만드는 상태인지 알아보는 법?
    -   해시 히트율, 메모리, CPU 사용량을 종합적으로 봐야 함.

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

InnoDB만이 짱이다. MyISAM, MEMORY 스토리지 엔진은 모두 답이 없으며, 금세 사라질 것으로 예상된다.

## 4.3 MyISAM 스토리지 엔진 아키텍처

### 4.3.1 키 캐시

-   MyISAM의 키 캐시(Key cache)는 InnoDB 버퍼 풀과 유사한 역할
-   인덱스만을 대상으로 작동하며 디스크 쓰기 작업에 대해 부분적으로 버퍼링
-   히트율 = 100 - (Key_reads / Key_read_requests \* 100)
-   일반적으로 99% 이상 히트율 권장

### 4.3.2 운영체제의 캐시 및 버퍼

-   MyISAM은 데이터에 대한 캐시/버퍼링 기능이 없어 OS의 캐시에 의존
-   MyISAM 사용 시 키 캐시는 물리 메모리의 40% 이하로 설정 권장

### 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

-   MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 힙 공간처럼 저장
    -   레코드는 PK값과 무관하게 INSERT되는 순서대로 데이터 파일에 저장됨
-   모든 레코드는 ROWID라는 물리적 주소값을 가짐
    -   PK나 세컨더리 인덱스 등에서 이 ROWID 값을 포인터로 가짐
-   ROWID는 고정길이와 가변길이 두 가지 방식으로 저장 가능

## 4.4 MySQL 로그 파일

-   MySQL 서버에 문제가 생겼을 때는 로그 파일들을 자세히 확인하는 습관~!
-   MySQL 서버의 깊은 내부 지식이 없어도 로그를 보면 MySQL 상태나 부하를 일으키는 원인을 찾아서 해결 가능

### 4.4.1 에러 로그 파일

1. 기본 특징

    - MySQL 실행 중 발생하는 에러/경고 메시지 기록
    - 로그 파일 위치: MySQL 설정 파일(my.cnf)의 log_error 파라미터에 정의
    - 미정의시 데이터 디렉터리에 .err 확장자로 생성

2. 주요 기록 내용
    - 시작 과정 메시지
        - 설정 파일 변경사항
        - 파라미터 적용 상태
        - 정상 기동 여부('mysqld: ready for connections' 확인)
    - InnoDB 트랜잭션 복구 메시지
        - 비정상 종료 후 재시작 시 트랜잭션 정리
        - 미완료 데이터 재기록
        - 복구 실패 시 innodb_force_recovery 파라미터 조정 필요
    - 쿼리 관련 에러
        - 실행 중 발생하는 문제
        - 복제 관련 경고 메시지
    - 비정상 커넥션 종료(Aborted connection)
        - 비정상적인 접속 종료 기록
        - 네트워크 문제로 인한 접속 종료
    - InnoDB 모니터링 결과
        - 테이블/락 모니터링 정보
        - 엔진 상태 조회 결과
    - 종료 메시지
        - 정상/비정상 종료 여부 확인 가능
        - 세그먼테이션 폴트 발생 시 스택 트레이스 정보

### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일)

1. 기본 특징

    - 모든 쿼리 요청을 시간 순서로 기록
    - 쿼리 실행 전에 즉시 기록 (에러 발생해도 기록됨)
    - 파일 위치: general_log_file 파라미터에 정의

2. 저장 방식

    - 파일 저장 또는 테이블 저장 선택 가능
    - log_output 파라미터로 저장 방식 결정
        - FILE: 디스크 파일로 저장
        - TABLE: mysql DB의 general_log 테이블에 저장

3. 로그 내용
    - 접속 정보 (사용자, 호스트)
    - 쿼리 실행 시간
    - 실제 실행된 쿼리 내용

### 4.4.3 슬로우 쿼리 로그

-   서비스에서 사용되는 쿼리 중에서 어떤 쿼리가 문제인지를 판단하는 데에 슬로우 쿼리 로그가 도움이 됨.
-   `long_query_time` 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리들이 슬로우 쿼리 로그 파일에 기록됨

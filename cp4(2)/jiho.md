# Chapter4 - 아키텍처 (4.2.7~끝)

### 4.2.7 InnoDB 버퍼 풀

-   디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
-   쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 수행
    -   왜 쓰기 작업을 지연시켜야 하는가?
        -   변경된 데이터를 모아서 처리하면 랜덤한 디스크의 작업 횟수를 줄일 수 있기 때문

#### 크기 설정

-   InnoDB 버퍼 풀 크기 설정 시 고려할 사항
    -   운영체제
    -   클라이언트 스레드
    -   MySQL 서버 내에서는 특별한 경우 레코드 버퍼가 커지는 경우를 고려해야 함
-   버퍼 풀 크기 동적으로 설정하기
    -   가능하면 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 증가시키는 게 최적
    -   버퍼 풀의 크기를 증가시킬 땐 MySQL 서버가 여유로울 때 진행하기
    -   버퍼 풀의 크기를 줄이는 건 서비스 영향도가 매우 크므로 웬만해서는 X
-   버퍼 풀 인스턴스
    -   버퍼 풀을 여러 개로 쪼개서 관리 (각 버퍼 풀을 `버퍼 풀 인스턴스`라고 함)
    -   왜 쪼개서 관리하나?
        -   기존에는 버퍼 풀이 하나였는데, 이를 관리하는 잠금(세마포어) 때문에 경합(여러 스레드가 같은 자원을 사용하기 위해 대기하는 상황 -> 성능 저하)이 발생함
        -   버퍼 풀을 쪼개서 관리하면 개별 버퍼 풀 마다 잠금(세마포어)이 걸리고, 덕분에 경합을 분산시킬 수 있음

#### 버퍼 풀의 구조

-   버퍼 풀의 공간 단위

    -   버퍼 풀 메모리를 **페이지 크기**(innodb_page_size 시스템 변수에 설정된)의 조각으로 쪼개어 관리
        -   디스크에서의 페이지 (데이터베이스 문맥): 데이터베이스가 디스크에 데이터를 저장하는 기본 단위
        -   테이블의 데이터, 인덱스 등이 이 페이지 단위로 저장됨
    -   디스크에서 메모리(버퍼 풀)로 데이터를 읽어올 때 페이지 단위로 읽어옴

-   버퍼 풀의 페이지 크기의 조각들을 관리하기 위해 다음과 같은 자료구조를 사용:

    -   LRU(Least Recently Used) 리스트
        -   LRU와 MRU(Most Recently Used)가 결합된 리스트
        -   한번 읽어온 페이지를 최대한 오랫동안 InnoDB의 버퍼 풀의 메모리에 유지해 디스크 읽기를 최소화하기 위함이다.
    -   플러시(Flush) 리스트
        -   더티 페이지(디스크로 동기화되지 않은 페이지)들의 변경 시점을 관리하는 자료구조
        -   이 리스트를 바탕으로 디스크와 동기화(플러시)가 필요한 페이지들을 결정
    -   프리(Free) 리스트
        -   버퍼 풀에서 사용되지 않고 있는 조각 명단을 기록

-   [버퍼 풀/리두 로그/디스크]에 쓰기가 발생 상황
    -   데이터 변경 시점
        -   버퍼 풀: 변경된 데이터가 페이지에 즉시 반영 (더티 페이지가 됨)
        -   리두 로그: 변경 내용이 로그에 기록되고 디스크에 기록됨 (WAL)
            -   WAL: Write Ahead Logging
        -   데이터 파일(디스크): 아직 변경되지 않은 상태 유지
    -   체크포인트 발생 시점
        -   버퍼 풀의 더티 페이지들이 디스크의 데이터 파일과 동기화됨
        -   이 시점을 리두 로그에 기록 (복구 시작점 표시)

#### 버퍼 풀과 리두 로그

-   버퍼 풀과 리두 로그의 저장 형식의 차이점
    -   버퍼 풀: 실제 데이터 페이지의 현재 상태를 그대로 담고 있음. (변경되면 변경된 최종 상태만을 저장)
        -   예: users 테이블의 id=1인 row의 현재 상태는 {name:"Kim", age:30}
    -   리두 로그: 변경 이력을 순차적으로 기록
        -   예: users 테이블의 id=1인 row의 name을 'Lee'에서 'Kim'으로 변경
    -   이렇게 다르게 저장하는 이유는, 버퍼 풀은 빠른 데이터 읽기와 변경을 위해 현재 상태를 바로 사용하는 데에 목적이 있고, 리두 로그는 장애 시 변경 과정을 순차적으로 재실행하여 복구하는 데에 목적이 있기 때문이다.

![Pasted image 20250102112336](https://github.com/user-attachments/assets/4f056754-55bd-47a2-b69f-cd710123b7e3)


-   리두 로그 시스템

    -   리두 로그는 여러 개의 파일을 원형으로 연결하여 사용한다. 마치 원형 큐처럼 동작한다.
    -   마치 이런 느낌으로 동작:

        ```
        [상황 1: 처음 로그 기록]
        [A][B][C][D][E][F][G][_][_][_]
                              ↑
                            LSN: 7
        Checkpoint LSN: 0

        [상황 2: A, B, C를 디스크에 기록 후]
        [A][B][C][D][E][F][G][_][_][_]
                  ↑           ↑
        Checkpoint LSN: 3   LSN: 7
        (A,B는 재사용 가능)

        [상황 3: 공간 재사용]
        [X][B][C][D][E][F][G][H][I][J]
            ↑     ↑
        LSN: 10  Checkpoint LSN: 3
        ```

-   공간 관리:

    -   재사용 가능한 공간: 디스크에 기록 완료된 영역
    -   활성 리두 로그: 아직 디스크에 기록되지 않은 영역

-   LSN(Log Sequence Number)과 체크포인트

    -   LSN: 로그가 기록될 때마다 증가하는 순차적 번호
    -   체크포인트: 주기적으로 발생하여 리두 로그와 더티 페이지를 디스크에 동기화
        -   체크포인트 LSN보다 작은 번호를 가진
            -   더티페이지들을 디스크로 동기화
            -   리두 로그 엔트리들을 디스크로 동기화
    -   체크포인트 에이지: 가장 최근 체크포인트 LSN과 현재 LSN의 차이 (활성 리두 로그 크기)

-   버퍼 풀과 리두 로그의 크기 밸런스 비교해보기
    1.  InnoDB 버퍼풀은 100GB, 리두 로그 파일 전체 크기 100MB
        -   계산
            -   리두 로그의 엔트리 개수 = 100MB / 4KB(평균 엔트리 크기) = 25600
            -   버퍼풀의 최대 더티 페이지 크기 = 25600 \* 16KB(페이지 크기) = 400MB
        -   발생할 수 있는 문제점
            -   버퍼 풀이 100GB인데, 더티 페이지는 400MB밖에 적재할 수 없다.
            -   즉, 쓰기 버퍼링 효과를 누리기 어렵다. 자꾸 디스크에 씀.
    2.  InnoDB 버퍼풀은 100MB, 리두 로그 파일 전체 크기 100GB
        -   계산
            -   리두 로그의 엔트리 개수 = 100GB / 4KB(평균 엔트리 크기) = 25 \* 2^20
            -   버퍼풀의 최대 더티 페이지 크기 = 25 _ 2^20 _ 16KB(페이지 크기) = 400GB
        -   발생할 수 있는 문제점
            -   리두 로그로 계산했을 땐 400GB까지 더티 페이지가 가능하나, 버퍼 풀 자체가 100MB이므로 최대 허용 가능 더티 페이지는 100MB크기가 된다.
            -   버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면 InnoDB는 갑자기 한꺼번에 많은 더티 페이지를 기록해야한다.
    -   결론
        -   버퍼 풀의 크기가 100GB이하의 MySQL 서버라면, 리두 로그 파일의 전체 크기를 5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가며 최적값을 선택하자.

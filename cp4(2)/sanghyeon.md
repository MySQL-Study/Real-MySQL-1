### **InnoDB 버퍼 풀**

- 스토리지 엔진에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업 지연 및 일괄 처리를 위한 버퍼 역할 겸임
- 변경된 데이터를 모아서 처리하며 랜덤한 디스크 작업의 횟수를 줄일 수 있음

**버퍼 풀의 크기 설정** 

레코드 버퍼

- 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간
- 커넥션이 많고 사용하는 테이블이 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 많이 필요해지는 경우도 있음
    
    ⇒ 이러한 경우 InnoDB 버퍼 풀의 크기를 동적으로 조절
    
    - 크리티컬 하므로 서버가 한가할 때 할 것

**버퍼 풀의 구조**

InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개 데이터가 필요할 때 해당 데이터 페이지를 읽어 각 조각에 저장

아래 3개의 자료구조를 관리하여 버퍼 풀의 페이지 크기 조각 관리

- LRU(Least Recently Used) 리스트
    
    ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcmLkEB%2FbtrXPrSXodV%2FAnCdFuvmz6dNi5UmH5mSz0%2Fimg.png)
    
    - LRU(Old 서브리스트 영역) + MRU(Most Recently Used, New 서브리스트 영역) 구조
    - 디스크로부터 읽어온 페이지를 최대한 오랫동안 버퍼 풀의 메모리에 유지하는 목적
    
    InnoDB 스토리지 엔진에서 데이터를 찾는 과정
    
    1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
        - InnoDB 어댑티스 해시 인덱스 → 테이블 인덱스(B-Tree) → 버퍼 풀에 이미 있다면 해당 페이지의 포인터를 MRU방향으로 승급
    2. 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
    3. LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더부분으로 이동
    4. 버퍼 풀에 상주하는 데이터 페이지는 나이를 먹어가고, 쿼리에 의해 사용되면 나이가 초기화되며 MRU 헤더 부분으로 이동
    5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
- 플러시(Flush) 리스트
    - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록 관리
    - 데이터 페이지에 변경 발생 → 플러시 리스트 + 리두 로그 → 디스크
- 프리(Free) 리스트
    - 비어 있는 페이지들의 목록
    - 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용

**버퍼 풀과 리두 로그**

![image](https://velog.velcdn.com/images/jinan159/post/bb46a1ee-8bca-47f4-89bc-9b9670db9ccd/image.png)

더티 페이지 → 버퍼 풀에 저장 → 디스크로 언젠가는 기록

리두 로그 → 1개 이상의 고정 크기 파일을 연결해 순환 고리처럼 사용

만약 데이터 변경이 계속되면 리두 로그 파일에 기록됐던 로그 엔트리는 새로운 엔트리로 덮어 씌어짐

⇒ InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간 /  재사용 불가능한 공간(활성 리두 로그, 그림에서 화살표 가진 엔트리)을 구분해서 관리

리두 로그 파일 공간은 재사용 되지만 매번 기록될 때마다 로그 포지션은 증가(Log Sequence Number)

InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화하고, 발생한 체크 포인트 중 가장 최근 체크 포인트 지점의 LSM이 활성 리두 로그 공간의 시작점

가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSM의 차이를 CheckPoint Age(활성 리두 로그 공간의 크기)

**플러시 리스트 플러시**

오래된 리두 로그 공간이 지워지기 위해 InnoDB의 버퍼 풀의 더티 페이지가 디스크로 동기화 되어야함 → 주기적으로 플러시 리스트 함수를 호출해 데이터를 디스크에 동기화

클리너 스레드 : InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 스레드(하나의 클리너 스레드가 하나의 버퍼 풀 인스턴스 처리)

어댑티브 플러시를 통해 더티 페이지를 어느정도 디스크로 기록할지를 버퍼 풀의 더티 페이지 비율이나 설정값에 의존하지 않고 새로운 알고리즘을 사용하여 결정

⇒ 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기 실행

**LRU 리스트 플러시**

LRU 리스트 플러시 함수를 통해 LRU 리스트에서 사용 빈도가 낮은 페이지들을 제거

LRU 리스트 끝부분부터 innodb_lru_scan_depth 시스템 변수에 설정된 개수만큼의 페이지들을 스캔 → 더티 페이지는 디스크에 동기화, 클린 페이지는 프리 리스트로 페이지를 옮김

**버퍼 풀 상태 백업 및 복구**

워밍업 : 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태

→ MySQL 서버를 셧다운하기 전에 innodb_buffer_pool_dump_now 시스템 변수를 이용해 InnoDB 버퍼 풀의 상태를 백업 & 다시 복구

**버퍼 풀의 적재 내용 확인**

버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적대돼 있는지 확인할 수 있지만 성능에 이슈가 있어 거의 확인 불가능

⇒ innodb_cached_indexes 테이블을 통해 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인 가능

**Double Write Buffer**

리두 로그는 페이지의 변경된 내용만 기록

더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구 불가(파셜 페이지, 톤 페이지 현상 → 비정상 종료 등으로 발생) ⇒ Double Write 기법 도입

![image](https://hoing.io/storage/2021/11/double_write_buffer_1.png)

더티 페이지 A~E를 묶고, 시스템 테이블 스페이스의 Double Write 버퍼에 기록

랜덤으로 더티 페이지를 파일의 적당한 위치에 저장하고,  비정상 종료 후 스토리지 엔진이 재시작될 때 Double Write 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교 후 다른 내용을 담고 있는 페이지가 있다면 DoubwlWrite 버퍼의 내용을 데이터 파일의 페이지로 복사

HDD : 플래터가 회전하는 저장 시스템은 한 번의 순차 디스크 쓰기를 하기 때문에 DoubleWrite가 부담없음

SDD : 핸덤 IO나 순차 IO의 비용이 비슷한 저장 시스템에서는 부담되지만 활성화를 하는 것이 중요

**언두 로그**

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준 보장을 위해 DML로 변경되기 이전의 데이터를 별도로 백업

백업된 데이터 = 언두로그

- 트랜잭션 보장 : 트랜잭션 롤백 시 언두 로그에 백업해 둔 이전 버전의 데이터 이용
- 격리 수준 보장 : 특정 커넥션에서 데이터 변경 중 다른 커넥션에서 데이터를 조회하면 변경 중인 레코드 대신 언두 로그 데이터 활용

**언두 로그 모니터링**

```sql
mysql> UPDATE member SET name='홍길동' WHERE member_id=1;
```

변경 전 데이터 : 언두 영역 → 롤백 시 사용해 복구

변경 후 데이터 : 홍길동 → 커밋 시 상태 유지

![image](https://velog.velcdn.com/images/jeongbeom4693/post/e02c4ea8-e48f-4d6b-b07b-3a5035c2478d/image.JPG)

트랜잭션 A가 끝나기 전까지 B와 C의 언두 로그 영역은 삭제될 수 없음

언두 로그의 문제점

- 한번 늘어난 언두 로그 데이터는 줄이기 쉽지 않음
    - 풀 쿼리 스캔을 통해 데이터 조회해야할 경우
    - 백업해야할 경우
    
    성능 문제 발생
    

따라서 다음의 명령어를 통해 언두 로그 증가량 확인 필요

```sql
mysql> SHOW ENGINE INNODB STATUS \G
```

**언두 테이블스페이스 관리**

언두 테이블스페이스 : 언두 로그가 저장되는 공간

MySQL 5.6이전 버전에서는 언두 로그가 모두 시스템 테이블 스페이스에 저장됐지만 서버가 초기화될 때 생성되기 때문에 확장의 한계가 존재 → innodb_undo_tablespaces 시스템 변수 도입하여 별도의 언두 로그 파일 사용 → 이후 항상 외부의 별도 로그 파일에 기록

![image](https://blog.kakaocdn.net/dn/bnFqMF/btrDpP0ZAB5/AkLn3Wno4LEHlk1WMT139k/img.png)

[언두 테이블스페이스 구조]

1개 이상 128개 이하의 롤백 세그먼트를 가지며 롤백 세그먼트는 1개 이상의 언두 슬록을 가짐

하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나누 값의 개수만큼의 언두 슬롯을 가짐

하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 DML문장의 특성에 따라 최대 4개까지 언두 슬롯을 사용

일반적으로 트랜잭션이 임시 테이블을 사용하지 않으므로 하나의 트랜잭션은 대략 2개의 언두 슬롯을 필요

⇒ 최대 동시 트랜잭션 수 = InnoDB 페이지 크기 / 16 * 롤백 세그먼트 개수 * 언두 테이블스페이스 개수

- 16 : 한 트랜잭션 슬롯의 크기 (16바이트), 트랜잭션을 관리하기 위해 페이지에 할당되는 고정 크기

8.0이후 부터는 CREATE UNDO TABLESPACE나 DROP TABLESPACE 같은 명령으로 새로운 언두 테이블스페이스를 동적으로 추가하고 삭제

Undo tablespace truncate : 과도하게 할당된 공간을 운영체제로 반납

- 자동 반납 : 퍼지 스레드를 통해 트랜잭션이 커밋되어 불필요해진 언두 로그를 삭제
- 수동 반납 : 언두 로그 파일의 잘라내기가 자동으로 수행되지 않거나 예상보다 자동 모드로 언두 테이블스페이스의 공간 반납이 부진한 경우 직접 반납

**체인지 버퍼**

RDBMS에서 레코드가 INSERT, UPDATE될 경우 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트

변경할 인덱스 페이지가

- 버퍼 풀에 있다면 바로 업데이트
- 디스크로부터 읽어와야 한다면 체인지 버퍼에 저장 후 사용자에게 반환

체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합(체인지 버퍼 머지 스레드)

unnodb_change_buffering 시스템 변수를 통해 특정 작업만 버퍼링할 수 있음

**리두 로그 및 로그 버퍼**

리두 로그는 Durable(영속성)과 관련있으며 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해줌

데이터 변경 내용을 로그로 먼저 기록

대부분의 DBMS는 읽기 성능이 뛰어나기 때문에 쓰기 비용이 낮은 리두 로그를 사용해 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구

일관되지 않은 데이터를 가지는 경우

- 커밋됐지만 데이터 파일에 기록되지 않은 데이터
    - 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사
- 롤백됐지만 데이터 파일에 이미 기록된 데이터
    - 변경 전 데이터가 저장된 언두 로그의 내용을 데이터 파일에 복사

리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되는 거시 좋지만 많은 부하가 유발될 수 있음

→ innodb_flush_log_at_trx_commit 시스템 변수를 통해 어느 주기로 동기화할지 결정

전체 리두 로그 파일의 크기

- 리두 로그 파일 크기 innodb_log_file_size
- 리두 로그 파일 개수 innodb_log_files_in_group
    
    두 시스템 변수의 곱
    

데이터 변경이 많아서 리두 로그의 기록 작업이 많은 경우 리두 로그 버퍼링을 통해 한번에 모았다가 디스크에 기록

이 때 사용되는 공간인 로그 버퍼는 적절한 값이 16MB이며 BLOB나 TEXT와 같이 큰 데이터를 자주 변경하는 경우 더 크게 설정

**리두 로그 아카이빙**

아직 복사하지 못한 리두 로그가 덮어쓰이면 백업 툴이 리그 로그 엔트리를 복사할 수 없어서 백업이 실패

→ 리그 로그 아카이빙 기능을 통해 데이터 변경이 많아 리두 로그가 덮어쓰인다고 해도 백업이 실패하지 않게 해줌(innodb_redo_log_archive_dirs 시스템 변수에 아카이빙 된 리두 로그 저장 디렉토리 설정)

디렉토리 준비되면 UDF(User Defined Function)를 실행

UDF 를 실행한 세션이 계속 연결이 끊어지지 않고 유지돼야 리두 로그 아카이빙이 계속 실행

만약 끊어진다면 리두 로그 아카이빙을 멈추고 아카이빙 파일을 자동 삭제

**리두 로그 활성화 및 비활성화**

리두 로그는 서버의 비정상 종료 시 데이터에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화 되어있음

서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록됨

데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화해서 데이터의 적재 시간을 단축할 수 있음

```sql
mysql> ALTER INSTANCE DISABLE INNODB REDO_LOG
```

데이터 적재 완료 후 항상 리두 로그를 다시 활성화 해야함

**어댑티브 해시 인덱스**

InnoDB 스토리지 엔진에서 사용자가 자주 여청하는 데이터에 대해 자동으로 생성하는 인덱스

B-Tree 검색 시간을 줄여주기 위해 도입

자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요시 어댑티브 해시 인덱스를 검색해 레코드가 저장된 데이터 페이지를 즉시 찾아감

해시 인덱스는 인덱스 키 값과 해당 인덱스 키 값이 저장된 데이터 페이지 주소의 쌍으로 관리

인덱스 키 = B-Tree 인덱스의 고유번호 + B-Tree 인덱스의 실제 키 값 조합

데이터 페이지 주소는 실제 키 값이 저장된 데이터 페이지의 메모지 주소를 가지며 이는 InnoDB 버퍼 풀에 로딩된 페이지의 주소를 의미

어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리되고, 버퍼 풀에서 해당 데이터 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라짐

어댑티브 해시 인덱스가 성능 향상에 크게 도움되지 않는 경우

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(조인, Like)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

도움이 되는 경우

- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우
- 동등 조건 검색(IN)이 많은 경우
- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

어댑티브 해시 인덱스는 데이터 페이지를 메모리 내에서 접근하는 것을 더 빠르게 만듦으로 데이터 페이지를 디스크에서 읽어올 경우 도움이 안됨

상당히 큰 메모리 공간을 차지할 수 있음

InnoDB 스토리지 엔진은 그 키 값이 해시 인덱스에 있든 없든 검색해봐야 함

어댑티브 해시 인덱스에 적재된 테이블을 삭제하거나 변경할 경우 관련 데이터를 어댑티브 해시 인덱스에서 제거

→ 상당히 많은 CPU 자원 사용

`SHOW ENGINE INNODB STATUS\G` 를 통해 해시 인덱스 히트율과 어댑티브 해시 인덱스가 사용 중인 메모리 공간, 서버의 CPU 사용량을 종합해서 어댑티브 해시 인덱스 활성화 여부를 판단

**InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교**

서버의 시스템 테이블(사용자 인증 관련된 정보와 복제 관련된 정보가 저장된 mysql DB 테이블)은 여전히 MyISAM 테이블을 사용

→ 8.0 이후 InnoDB만으로 모든 기능 구현 가능

MEMORY 스토리지 엔진

- 가변 길이 타입의 칼럼을 지원하지 않음
- 하나의 스레드에서만 데이터를 읽고 쓰는 것이 아니라면 InnoDB보다 동시 처리가 느림

### MyISAM 스토리지 엔진 아키텍쳐

[MyISAM 스토리지 엔진 구조]

![image](https://velog.velcdn.com/images/ybell1028/post/1359a94f-9d5d-454f-b77c-d724eb9cbe61/image.png)

**키 캐시**

InnoDB의 버퍼 풀과 비슷한 역할

인덱스만을 대상으로 작동하며 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 함

키 캐시 히트율 = 100 - (key_reads/ key read_requests * 100)

- key_reads : 인덱스를 디스크에서 읽어 들인 횟수를 저장하는 상태 변수
- key_read_requests : 키 캐시로부터 인덱스를 읽은 횟수를 저장하는 상태 변수

`SHOW GLOBAL STATUS` 명령어를 통해 상태 값 확인 가능

히트율이 99% 이하라면 키 캐시를 조금 더 크게 설정

**운영체저의 캐시 및 버퍼**

인덱스 블록은 키 캐시를 통해 빠르게 처리 가능하지만 테이블의 데이터를 다룰 때는 불가능

디스크로부터 I/O를 할 경우(MyISAM 테이블의 데이터 읽기나 쓰기 작업) 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청

운영체제의 캐시 기능을 통해 매번 디스크를 읽지 않지만 InnoDB 처럼 데이터의 특성을 알고 전문적으로 캐시나 버퍼링을 하지는 못함

**데이터 파일과 프라이머리 키(인덱스) 구조**

InnoDB 스토리지 엔진을 사용하는 테이블은 프라이머리 키에 의해서 클러스터링되어 저장

MyISAM 테이블은 프라이머리 키에 의해 클러스터링 없이 데이터 파일이 힙 공간처럼 활용 → INSERT 되는 순서대로 데이터 파일에 저장

MyISAM 테이블에 저장되는 레코드는 모두 ROWID라는 물리적인 주솟값을 가짐

프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가짐

ROWID는 두 가지 방법으로 저장됨

- 고정 길이 ROWID
    
    MAX_ROWS 옵션을 명시하여 서버는 최대로 가질 수 있는 레코드가 한정된 테이블을 생성
    
    ROWID 값으로는 4바이트 정수를 사용하고 레코드가 INSERT된 순번이 ROWID로 사용됨
    
- 가변 길이 ROWID
    
    MAX_ROWS 옵션 설정을 안하면 myisam_data_pointer_size 시스템 변수에 설정된 바이트 수만큼의 공간을 사용가능(2~7바이트)
    
    데이터 파일에서 레코드의 위치(OFFSET)가 ROWID로 사용됨
    

### MySQL 로그 파일

**에러 로그 파일**

에러나 경고 메시지가 출력되는 로그 파일

my.cnf에서 log_error라는 이름의 파라미터로 정의된 경로에 생성

**마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB 트랜잭션 복구 메시지**

서버가 비정상적 또는 강제적으로 종료됐다면 다시 시작되면서 완료되지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 함

이 과정에서 문제가 있어 복구되지 못할 경우 해당 에러 메시지를 출력

**쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지**

쿼리 도중 발생 에러 로그를 확인하여 DB의 숨겨진 문제점을 해결

**비정상적으로 종료된 커넥션 메시지(Aborted connection)**

클라이언트 어플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 MySQL 에러 로그 파일에 기록 → 많을 경우 커넥션 종료 로직 검토

**InnoDB 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS같은)의 결과 메시지**

테이블 모니터링이나 락 모니터링 또는 InnoDB의 엔진 상태를 조회하는 명령은 큰 메시지를 에러 로그 파일에 기록하므로 모니터링 이후에는 에러 로그 파일이 커지지 않도록 다시 비활성화

**MySQL의 종료 메시지**

세그먼테이션 폴드로 비정상 종료될 경우 스택 트레이스의 내용을 참고해 조사 후 버전을 업그레이트하거나 회피책을 찾아야함

**제너럴 쿼리 로그 파일(제너럴 로그 파일, General Log)**

쿼리 로그를 활성화해 쿼리를 쿼리 로그 파일로 기록하게 한 다음, 그 파일을 검토

**슬로우 쿼리 로그**

MySQL 쿼리 튜닝

- 서비스가 적용되기 전 전체적으로 하는 튜닝
    - 모두 튜닝
- 서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝
    - 슬로우 쿼리를 통해 어떤 뭐리가 문제인지 판단

슬로우 쿼리 : 정상적으로 실행된 후, 실행하는데 걸린 시간이 long_query_time에 정의된 시간보다 많이 걸린 쿼리

log_output 옵션 : 슬로우 쿼리 로그를 파일로 기록할지 테이블로 기록할지 선택

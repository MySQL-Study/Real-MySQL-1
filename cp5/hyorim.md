# Chapter 5. 트랜잭션과 잠금
- MySQL의 동시성에 영향을 미치는 요소

    - 잠금 (Lock)
    - 트랜잭션
    - 트랜잭션의 격리 수준(Isolation level)

- 트랜잭션 : 작업의 완선성 보장해줌.
    -  논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상 (Partial update) 방지
    - `잠금(Lock)` : 동시성 제어하기 위한 기능
        - 여러 커넥션이 동시에 동일한 자원(레코드나 테이블) 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해줌.
    - `트랜잭션(Transaction)` : 데이터 정합성 보장하기 위한 기능
    - `격리 수준` : 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

## 5.1 트랜잭션
- MyISAM, MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않음
- InnoDB 스토리지 엔진은 트랜잭션 지원


### 5.1.1 MySQL에서의 트랜잭션
- 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을때만 의미 있는 개념은 아님
- 개수와 상관 없이 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT 실행 시), 아무것도 적용되지 않아야(ROLLBACK 또는 트랜잭션을 ROLLBACK시키는 오류 발생 시) 함을 보장해주는 것

- `InnoDB` : 쿼리 중 일부라도 오류 발생하면 전체를 원 상태로 만듦.
- `MEMORY` & `MyISAM ` : Partial Update 발생, 테이블 데이터 정합성 맞추는데 어려운 문제 발생시킴.

### 5.1.2 주의사항
- 트랜잭션 또한 DBMS 커넥션과 동일하게 꼭 필요한 최소 코드에 적용하는 것이 좋음
  -> **코드에서 트랜잭션 범위를 최소화!!**

- 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 함.

    - 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 함.
    -  DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생함.

## 5.2 MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금 레벨

    - `스토리지 엔진 레벨` : 스토리지 엔진 간 상호 영향 미치지 않음.
    - `MySQL 엔진 레벨` : 모든 스토리지 엔진 레벨에 영향 미침.

- MySQL 엔진 제공하는 락

    - `테이블 락` : 테이블 데이터 동기화 위함.
    - `메타데이터 락` : 테이블 구조 잠금
    - `네임드 락` : 사용자 필요에 맞게 사용 가능

### 5.2.1 글로벌 락
- 글로벌 락(GLOBAL LOCK)은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득 가능
    - MySQL에서 제공하는 잠금 가운데 가장 범위가 큼.
    - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDM이나 DML 문장을 실행하는 경우 글로벌 락 해제될 때까지 해당 문장 대기 상태로 남음.
    - 글로벌 락 영향 미치는 범위 : MySQL 서버 전체
    - MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업 받아야할 때글로벌 락 사용

- `FLUSH TABLES WITH READ LOCK` 명령 이용한 글로벌 락은 MySQL 서버의 모든 변경 작업 멈춤.
- InnoDB 스토리지 엔진은 트랜잭션 지원하기 때문에 일관된 데이터 상태를 위해 데이터 변경 작업 멈출 필요 없음.

    - MySQL 8.0부터 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락 필요성 생김
    - 따라서, MySQL 8.0버전부터는 Xtrabackup이나 Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락 도입됨.

- 백업 락
    - 특정 세션에서 백업 락 획득한 경우 모든 세션에서 테이블의 스키마나 사용자 인증 관련 정보 변경 불가
        - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
        - REPAIR TABLE과 OPTIMIZE TABLE 명령
        - 사용자 관리 및 비밀번호 변경
    - 일반적인 테이블의 데이터 변경은 허용됨.
    - 정상적으로 복제는 실행되지만 백업 실패를 막기 위해 DDL 명령이 실행되면 복제 일시 중지하는 역할


- MySQL 서버의 구성
    - `소스 서버(Source Server)`
    - `레플리카 서버(Replica server)` : 백업은 주로 여기서 실행

### 5.2.2 테이블 락
- 테이블 락(Talbe Lock)은 개별 테이블 단위로 설정되는 잠금
- 명시적 또는 묵시적으로 특정 테이블의 락 획득 가능
    - 명시적 : `LOCK TABLES table_name [READ | WRITE]`
        - `UNLOCK TABLES` 명령으로 잠금 반납(해제)
        - 특별한 상황이 아니면 애플리케이션에서 사용할 필요 거의 없음.
        - 명시적으로 테이블 잠그는 작업은 글로벌 락처럼 온라인 작업에 상당한 영향 줌.
    - 묵시적 : MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리 실행하면 발생
        - MySQL 서버가 데이터가 변경되는 테이블에 잠금 설정하고 데이터 변경한 후, 즉시 잠금 해제하는 형태로 사용됨.
        - InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적 테이블 락 설정되지 않음.
        - InnoDB의 경우, 대부분 데이터 변경(DML) 쿼리에서는 무시되고 스키마 변경하는 쿼리(DDL)의 경우에만 영향 미침.

### 5.2.3 네임드 락
- 네임드 락(Named Lock)은 `GET_LOCK()` 함수를 이용해 문자열에 대해 잠금 설정 가능
- 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니라 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금
    - 자주 사용되지 않음.
    - 데이터베이스 서버 1대에 여러개의 웹 서버가 접속해서 서비스 하는 상황에서 여러 클라이언트가 상호 동기화 처리해야 할때 사용하면 좋음.
    - 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유리
        - 배치 프로그램처럼 한꺼번에 많은 레코드 변경 쿼리는 자주 데드락 원인 됨.
        - 이러한 경우에 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락 걸고 쿼리 실행하면 간단히 해결 가능
- MySQL 8.0 버전부터는 네임드 락 중첩 사용 가능 & 현재 세션에서 획득한 네임드 락 한번에 모두 해제 기능 추가됨.

### 5.2.4 메타데이터 락
- 메타데이터 락(Metadata Lock)은 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조 변경하는 경우 획득하는 락
- 명시적으로 획득하거나 해제할 수 있는 것이 아니라, `RENAME TABLE tab_a TO tab_b` 같이 테이블의 이름 변경하는 경우 자동으로 획득하는 잠금

    - `RENAME TABLE`의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금 설정
    - 시간으로 테이블 바꿔야하는 요건이 배치 프로그램에서 자주 발생

(예시 이해 안 감....)

## 5.3 InnoDB 스토리지 엔진 잠금
- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반 잠금 방식 탑재

    - 레코드 기반 잠금 방식 때문에 MyISAM보다 훨씬 뛰어난 동시성 처리 제공
    - 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기 까다로움.
        - 서버에서 InnoDB 잠금 정보 진단할 수 있는 도구는 `lock_monitor(innodb_lock_monitor라는 이름의 InnoDB 테이블 생성해서 InnoDB 잠금 정보 덤프하는 방법)`과 `SHOW ENGINE INNODB STATUS` 명령 뿐이었음.
        - 최근 버전에서는 InnoDB 트랜잭션과 잠금, 잠금 대기 중인 트랜잭션 목록 조회할 수 있는 방법 도입됨.

            -  `information_schema` 데이터베이스에 존재하는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS`라는 테이블 조인해서 조회해서 확인 가능
            - 장시간 잠금을 가지고 있는 클라이언트 찾아서 종료 가능
            - `Performance Schema`를 이용해 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법 추가

### 5.3.1 InnoDB 스토리지 엔진의 잠금

<img src="https://velog.velcdn.com/images/hyolim/post/5fec3d55-1551-4e96-9270-a57941491776/image.png" width="500">


- InnoDB 스토리지 엔진은 레코드 기반 잠금 기능 제공

    - 잠금 정보가 상당히 작은 공간으로 관리되어 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 거의 없음.(락 에스컬레이션 발생 X)
- InnoDB는 갭 락이라는 것도 존재

#### 5.3.1.1 레코드 락
- 레코드 자체만을 잠그는 것을 레코드 락(Record lock, Record only lock)
- 다른 상용 DBMS의 레코드 락과 동일한 역할
- 다른 상용 DBMS와 InnoDB는 차이는 InnoDB는 레코드 자체가 아니라 인덱스 레코드를 잠근다는 점이 다름.
    - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스 이용해 잠금 설정
    - InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락과 갭 락 사용하지만, 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업은 갭에 대해서 잠그지 않고 레코드 자체에 대해서만 락

#### 5.3.1.2 갭 락
- 다른 DBMS와의 차이점
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것 의미함.
- 레코드와 레코드 사이 간격에 새로운 레코드 생성(INSERT) 되는 것을 제어
- 그 자체보다는 넥스트 키 락 일부로 자주 사용됨.

#### 5.3.1.3 넥스트 키 락
- 레코드 락과 갭 락 합쳐 놓은 형태의 잠금
- `STATEMENT` 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 `REPEATABLE READ` 격리 수준을 사용해야 함.
- `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금 걸림
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과의 동일한 결과를 만들어내도록 보장하는 것이 주목적
    - 의외로 넥스트 키 락과 갭 락으로 인한 데드락이 발생하거나 다른 트랜잭션 기다리게 만드는 일 자주 발생함.
    - 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락 줄이는 것이 좋음

#### 5.3.1.4 자동 증가 락
- 자동 증가하는 숫자 값을 추출하기 위해 `AUTO_INCREMENT`라는 속성 제공

    - `AUTO_INCREMENT` 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값 가져야 함.

- `AUTO_INCREMENT` 락은 INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요, UPDATE, REPLACE 등의 쿼리에서는 걸리지 않음.
- `AUTO_INCREMENT` 락을 명시적으로 획득하고 해제하는 방법은 없음.


### 5.3.2 인덱스와 잠금
- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리됨.
    - 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 거러야 함.

### 5.3.3 레코드 수준의 잠금 확인 및 해제
- InnoDB 스토리지 엔지을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡함.

    - 테이블 잠금에서는 테이블 자체가 잠금 -> 쉽게 문제 원인 발견, 해결 가능
    - 레코드 수준의 잠금은 테이블 레코드 각각에 잠금이 걸리므로, 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 있어도 잘 발견 X

## 5.4 MySQL의 격리 수준
- 트랜잭션의 격리 수준(isolation level)은 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터 볼 수 있게 혀용할 지를 설정
- 격리 수준
    - `READ UNCOMITTED`
        - DIRTY READ라고도 함.
        - 일반적인 데이터베이스에서는 거의 사용하지 않음
    - `READ COMITTED`
    - `REPEATABLE READ`
    - `SERIALIZABLE`
        - 동시성이 중요한 데이터베이스에서는 거의 사용되지 않음.

| Isolation Level   | Dirty Read | Non-Repeatable Read | Phantom Read |
|-------------------|------------|---------------------|--------------|
| READ UNCOMMITTED  | 발생       | 발생                | 발생         |
| READ COMMITTED    | 없음       | 발생                | 발생         |
| REPEATABLE READ   | 없음       | 없음                | 발생         |
| SERIALIZABLE      | 없음       | 없음                | 없음         |


### 5.4.1 READ UNCOMITTED
<img src="https://velog.velcdn.com/images/hyolim/post/b1b354b6-5681-44b4-952e-f2aa0c04a3fb/image.png" width="500">

- READ UNCOMMITTED 격리 수준에서는 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에 보임.
- `더티 리드(Dirty read)` : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- 정합성에 문제가 많은 격리 수준으로, MySQL을 사용한다면 최소 READ COMITTED 이상으로 격리 수준 사용을 권장

### 5.4.2 READ COMITTED

<img src="https://velog.velcdn.com/images/hyolim/post/be122c2e-7e97-437b-8325-582d588815f8/image.png" width="500">

- 오라클 DBMS에서 기본으로 사용되는 격리 수준
- 온라인 서비스에서 가장 많이 선택되는 수준
- 더티리드(Dirty read) 발생하지 않음.
- 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회 가능

<img src="https://velog.velcdn.com/images/hyolim/post/ddd84299-341d-41da-b150-7f4a7175171a/image.png" width="500">

- READ COMMITED 격리 수준에서도 NON-REPEATABLE READ라는 부정합 문제 발생
    - 일반적인 웹 프로그램에서는 크게 문제 없을 수 있지만, 금전적인 처리와 연결되면 문제 발생 가능

### 5.4.3 REPEATABLE READ
<img src="https://velog.velcdn.com/images/hyolim/post/ddd84299-341d-41da-b150-7f4a7175171a/image.png" width="500">

- MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE 격리 수준 이상 사용해야 함.
    - InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값 변경
      => `MVCC(Multi Version Concurrency Control`라고 함.

<img src="https://velog.velcdn.com/images/hyolim/post/bee8f202-1a2d-41c5-a282-8300d2d97037/image.png" width="500">

- 하나의 레코드에 대해 백업이 하나 이상 존재할 수 있음.
- BEGIN으로 트랜잭션 시작하고 장시간 트랜잭션 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질 수 있음. -> MySQL 처리 성능 저하의 원인 되기도!
- REPEATABLE 격리 수준에서도 PHANTOM READ와 같은 부정합 발생 가능
    - `PHANTOM READ` : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상

### 5.4.4 SEREALIZABLE
- 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준
- 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어짐
- InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금 없이 실행됨. -> Non-locking consistent read
  **그러나, SEREIALIZABLE의 경우 읽기 작업도 공유 잠금 획득해야 하며, 한 트랜잭션에서 읽고 스는 레코드를 다른 트랜잭션에서 절대 접근 불가**
- PHANTOM READ 발생하지 않음.
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 PHANTOM READ 발생하지 않기 때문에 굳이 SERIALIZABE 사용할 필요 없음.
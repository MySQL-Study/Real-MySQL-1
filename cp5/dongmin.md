## 트랜잭션

트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것.

⇒ 전부 COMMIT되거나, 전부 ROLLBACK 됨을 보장.

### 트랜잭션 범위

트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
```
1. 처리 시작

   ⇒ 데이터베이스 커넥션 생성

   ⇒ 트랜잭션 시작

2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장

   ⇒ 트랜잭션 종료 (COMMIT)

   ⇒ 데이터베이스 커넥션 반납

10. 처리 완료
```

- 위 과정에서는 2번, 3번, 4번의 절차가 아무리 빨리 처리된다고 하더라도 DBMS의 트랜잭션에 포함시킬 필요는 없습니다.
    - 실제로 DBMS에 데이터를 저장하는 작업은 5번부터 시작되기 때문
- 데이터베이스 커넥션은 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 수 있음.

  ⇒ 어느 순간부터 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있음.

- 8번 작업에서는 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋음.
    - 프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생하면 웹 서버뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생할 수 있음.
- 사용자가 입력한 정보를 저장하는 5번과 6번 작업은 반드시 하나의 트랜잭션으로 묶고, 7번 작업은 저장된 데이터의 단순 확인 및 조회이므로 트랜잭션에 포함할 필요는 없음.
- 9번 작업은 성격이 달라 이전 트랜잭션에 함께 묶지 않아도 무방함.

```
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 발생 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장

   ⇒ 데이터베이스 커넥션 생성 (또는 커넥션 풀에서 가져오기)

   ⇒ 트랜잭션 시작

5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장

   ⇒ 트랜잭션 종료 (COMMIT)

7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송

   ⇒ 트랜잭션 시작

9. 알림 메일 발송 이력을 DBMS에 저장

   ⇒ 트랜잭션 종료 (COMMIT)

   ⇒ 데이터베이스 커넥션 종료 (또는 커넥션 풀에 반남)

10. 처리 완료
```

- 위 과정이 최적은 아닐 수 있고, 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소해야 함.

### 레코드 락

- 레코드 자체만을 잠그는 락
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금

### 갭 락

- 레코드와 바로 인접한 레코드 사이의 간격만은 잠금
- 레코드와 레코드 사이에 새로운 레코드가 INSERT 되는 것을 제어

### 넥스트 키 락

- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- 넥스트 락과 갭 락으로 인해 데드락이 발생하거나 트랜잭션을 기다리게 만드는 일이 자주 발생함

```tsx
테이블 구조:
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

현재 데이터:
id  | name
1   | Kim
4   | Lee
7   | Park

트랜잭션 A:
INSERT INTO users VALUES (2, 'Choi');  -- id 1과 4 사이에 삽입 시도

트랜잭션 B: 
INSERT INTO users VALUES (3, 'Jung');  -- id 1과 4 사이에 삽입 시도

트랜잭션 A가 id 1-4 구간에 갭 락을 설정
트랜잭션 B는 같은 구간에 삽입하려고 하나 A의 갭 락으로 인해 대기
```

- 가능하다면 바이너리 로그 포맷을 ROW형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋음.

### 자동 증가 락

- MySQL에서 Auto Increment를 설정하여 동시에 여러 레코드가 INSERT 되는 경우에는, 중복되는 갑 없이 저장된 순서대로 증가하는 값을 가져야 한다.

### MySQL의 격리 수준

- 트랜잭션의 격리 수준은 동시에 여러 트랜잭션이 실행될 때 한 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않도록 하는 정도를 말함.
- 낮은 격리 수준은 동시 처리 능력을 높이지만, 데이터의 일관성 문제를 발생시킬 수 있습니다. 반면, 높은 격리 수준은 데이터의 일관성을 보장하지만, 동시 처리 능력이 떨어질 수 있음.
    - 즉, 데이터 정합성과 성능은 반비례.
    - 트랜잭션 격리 수준은 개발자가 트랜잭션 격리 수준을 설정할 수 있는 기능을 제공하는 기능.
- SERIALIZABLE이 아니면 서버의 성능 에서의 차이는 거의 없음.

### READ UNCOMMITTED

- READ UNCOMMITTED는 커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용함.
- 해당 격리 수준에서는 Dirty Read, Phantom Read, Non-Repeatable Read 문제가 발생할 수 있음.
- 각 트랜잭션에서의 변경 내용이 COMMIT, ROLLBACK과 상관없이 다른 트랜잭션에 보여짐.

```tsx
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 예시
트랜잭션 A:
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 아직 커밋하지 않음

트랜잭션 B:
SELECT balance FROM accounts WHERE id = 1;
-- A가 수정한 커밋되지 않은 데이터가 조회됨
```

### READ COMMITTED

- READ COMMITTED는 커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용함.
- 특정 트랜잭션이 이루어지는 동안, 다른 트랜잭션은 해당 데이터에 접근할 수 없음.
- Dirty Read는 발생하지 않지만, Phantom Read, Non-Repeatable Read 문제가 발생할 수 있음.

```tsx
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 예시
트랜잭션 A:
SELECT balance FROM accounts WHERE id = 1;  -- 1000원
-- 다른 트랜잭션에서 업데이트 후 커밋
SELECT balance FROM accounts WHERE id = 1;  -- 900원
```

### REPETABLE READ

- REPEATABLE READ는 한 트랜잭션에서 특정 레코드를 조회할 때 항상 같은 데이터를 응답하는 것을 보장.
- 하지만, SERIALIZABLE과 다르게 행이 추가되는 것을 막지는 않는다.
- Non-Repeatable Read 문제가 발생하지 않지만, Phantom Read 문제가 발생할 수 있습니다.

```tsx
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 예시
트랜잭션 A:
SELECT * FROM accounts WHERE balance > 1000;
-- 다른 트랜잭션에서 데이터 변경해도 동일한 결과 보장
SELECT * FROM accounts WHERE balance > 1000;
```

### SERIALIZABLE

- SERIALIZABLE은 특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다.
- 가장 높은 데이터 정합성을 가지지만 성능이 가장 낮다.
- MySQL의 경우 단순한 SELECT 쿼리가 실행되더라도 데이터베이스 잠금이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없음.

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 예시
트랜잭션 A:
START TRANSACTION;
SELECT * FROM accounts WHERE balance > 1000;
-- 이 시점에서 balance > 1000인 모든 행에 잠금이 걸림

트랜잭션 B:
-- A 트랜잭션이 완료될 때까지 아래 쿼리들은 대기 상태
INSERT INTO accounts VALUES (3, 1500);  -- 차단됨
UPDATE accounts SET balance = 2000 WHERE id = 1;  -- 차단됨
SELECT * FROM accounts WHERE balance > 1000;  -- 차단됨

트랜잭션 A:
COMMIT;
-- A가 커밋된 후에야 B의 쿼리들이 실행 가능
```

### Dirty Read

- Dirty Read는 한 트랜잭션이 다른 트랜잭션이 변경 중인 데이터를 읽는 경우 발생.
- 다른 트랜잭션이 아직 커밋되지 않은 (즉, 롤백할 가능성이 있는) 데이터를 읽어서, 그 데이터가 나중에 롤백될 경우 트랜잭션의 결과가 변경될 수 있고, 이는 데이터의 일관성을 깨뜨릴 수 있음.

### Phantom Read

- Phantom Read는 한 트랜잭션이 동일한 쿼리를 두 번 실행했을 때, 두 번의 쿼리 사이에 다른 트랜잭션이 삽입, 갱신, 삭제 등의 작업을 수행하여 결과 집합이 달라지는 경우를 말함.
- 이로 인해 한 트랜잭션 내에서 일관성 없는 결과를 가져올 수 있습니다.

### Non-Repeatable Read

- Non-Repeatable Read는 같은 트랜잭션 안에서 동일한 쿼리를 실행했을 때, 다른 결과를 얻는 경우를 의미함.
    - 예를 들어, 한 트랜잭션이 같은 데이터를 두 번 읽을 때, 첫 번째 읽기와 두 번째 읽기 사이에 다른 트랜잭션이 해당 데이터를 변경했을 경우 발생할 수 있음.
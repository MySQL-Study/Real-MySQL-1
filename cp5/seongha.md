# Chapter 5 트랜잭션과 잠금

트랜잭션은 작업의 완전성을 보장해 주는 것이다. 작업의 일부만 적용되는 현상을 막아주는 기능이다.
 
잠금과 트랜잭션은 다음과 같은 목적을 가지고 있다.
- `잠금`: 동시성을 제어하기 위한 기능
- `트랜잭션`: 데이터의 정합성을 보장하기 위한 기능

# 5.1 트랜잭션 

MyISAM과 Memory 방식은 트랜잭션을 지원하지 않는다. 따라서 동시성과 정합성 등에서 더 많은 고민거리를 만들어 낸다. 

## 5.1.1 MySQL에서의 트랜잭션
트랜잭션은 몇개의 쿼리든 상관없이 논리적인 작업 셋(commit) 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것이다.

트랜잭션이 적용되지 않는다면 실패한 쿼리로 인해 남은 레코드를 삭제하는 재처리 작업이 필요할 수 있다. 실제로 트랜잭션이 적용되지 않는 MyISAM에서는 여러개의 중첩된 If else 문을 통해서 남은 레코드를 재처리하는 코드를 작성해야 한다. 

## 5.1.2 주의사항
트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 
이는 프로그램 코드에서 트랜잭션의 범위를 최소화하라는 의미이다. 

트랜잭션의 범위를 잘 생각해야 한다. 
1. DB와 관련없는 로직을 포함하면 안된다.
2. 네트워크 작업을 포함하면 안된다. 
3. 함께 처리되어야할 작업은 트랜잭션으로 묶는다.
예를들어, A가 B에게 100원을 상대에게 송금하는 과정에서 A통장에서 100원을 빼는 작업과 B통장에 100원을 더하는 작업은 1개의 트랜잭션으로 묶여야 한다. 


# 5.2 MySQL 엔진의 잠금
MySQL에서의 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다. 
MySQL엔진의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 잠금은 스토리지 엔진 잠금끼리 영향을 미치지 않는다. 

MySQL엔진에서는 테이블 데이터 동기화를 위한 `테이블락`, 테이블의 구조를 잠그는 `메타데이터 락`, 사용자의 필요에 맞게 사용하는 `네임드락`이 있다.

## 5.2.1 글로벌 락
글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 중 가장 범위가 크다. 
한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DML, DDL문장이 글로벌락이 해제될 때까지 대기 상태로 남는다. 
글로벌 락의 범위는 MySQL 전체이며 테이블이나 데이터베이스가 다르더라도 영향을 미친다.
여러 데이터베이스에 존재하는 MyISAM이나 Memory 테이블에 대해 mysqldump로 백업을 받을때는 글로벌 락을 사용해야 한다. 

글로벌 락을 걸기 위해서는 이전에 실행중이던 모든 쿼리가 완료되어야 한다. 따라서 모든 쿼리가 완료될 때까지 기다린 후 실행하기에 장시간 대기할 수도 있다. 

InnoDB의 트랜잭션 도입으로 인해 글로벌 락은 거의 사용되지 않는다. 또한, 8.0버전부터는 InnoDB가 기본 엔진으로 채택되면서 좀 더 가벼운 글로벌 락이 필요해졌고 그래서 백업락이 도입되었다. 

특정 세션에서 백업락을 획득하면 모든 세션에서 테이블의 스키마나 사용자 인증 관련 정보를 변경할 수 없게 된다. 그러나, 일반적인 테이블의 데이터 변경은 허용된다. 

일반적으로 소스 서버와 레플리카 서버를 구성하는데, 백업은 주로 레플리카 서버에서 진행한다. 
하지만 백업에서 글로벌 락을 획득하면 복제 작업은 지연될 수 밖에 없다. 따라서 백업동안 서비스를 중단해야할 수도 있다. 
XtraBackup, Enterprise Backup 과 같은 백업 툴들은 모두 복제를 하면서 백업도 가능하다. 
그러나 스키마 변경이 일어나면 백업은 실패하게 되는데 6~7시간 동안 백업한 내용이 DDL명령 하나로 날아가게 된다. MySQL의 백업락은 이런 목적으로 도입되었으며, DDL명령이 실행되면 복제를 일시중지 한다. 


## 5.2.2 테이블락
테이블락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블 락을 획득할 수 있다. 

명시적인 테이블락은 `LOCK TABLES table_name [READ | WRITE]` 명령으로 획득할 수 있고, `UNLOCK TABLES` 명령으로 잠금을 반납할 수 있다. 
명시적 테이블 락도 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문에 서비스에서 거의 사용할 필요가 없다.

묵시적인 테이블 락은 MyISAM과 Memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. 쿼리 시작전에 잠금하고 후에 반납한다. InnoDB에서는 스토리지 엔진 차원에서 레코드 잠금을 제공하기 때문에 단순 데이터 변경으로는 묵시적 테이블락이 설정되지 않는다. 더 정확히는 테이블락이 설정되지만, DML은 무시되고 DDL의 경우에만 영향을 미친다. 

## 5.2.3 네임드 락
네임드 락은 `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 
네임드 락의 대상이 테이블, 레코드 와 같은 객체가 아니라 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다. 
```SQL
// "mylock"이라는 문자열에 대해 잠금을 획득한다. 
//이미 잠금을 사용중이면 2초 동안만 대기한다 (2초 이후 자동 잠금해제)
SELECT GET_LOCK('mylock',2);

// "mylock"이라는 문자열에 잠금이 설정되어 있는지 확인
SELECT IS_FREE_LOCK('mylock');

// "mylock"이라는 문자열에 대한 잠금을 반납
SELECT RELEASE_LOCK('mylock');
```

또한, 네임드 락의 경우 많은 레코드에 대해서 복잡한 조건으로 레코드를 변경하는 트랜잭션에 유용하게 사용될 수 있다. 
배치 프로그램처럼 한번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 된다. 이 경우 동일한 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 간단히 해결할 수 있다.

내가 이해한 바에 따르면 네임드 락은 `flag`라고 볼 수 있다. 
order 테이블에 대한 1번 배치작업이 진행된다면 flag를 1로 만들고, 2번 배치작업은 flag를 확인하여 1이면 대기하고, 0이면 실행하는 방법이다. 
이렇게 같은 테이블의 데이터를 변경하는 것을 막아 데드락을 방지한다.  (순서 보장도 가능)

중첩 네임드락과 전체 해제도 가능하다. 

## 5.2.4 메타데이터 락
데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경할 때 획득하는 잠금이다. 
실시간으로 테이블을 변경해야 하는 경우가 배치 프로그램에서 자주 발생한다. 

#### 테이블 교체 상황
예를 들어 다음과 같이 테이블을 교체해야 하는 상황이 있다. 
1. 임시 테이블 rank_new 생성 
2. rank 테이블을 rank -> rank_backup 백업 테이블로 이름변경
3. rank_new -> rank 임시 랭킹 테이블을 서비스의 랭킹 테이블로 변경

```SQL
// 예외 발생하지 않음
RENAME TABLE rank TO rank_backup , rank_new TO rank; 

// 나누어서 처리했기에 예외 발생
RENAME TABLE rank TO rank_backup;
RENAME TABLE rank_new TO rank; 
```
위 예제에서 첫번째의 경우 모든 대상 테이블(rank, rank_backup, rank_new)에 대해 필요한 메타데이터 락을 한 번에 모두 획득한 뒤 작업을 수행한다.

두번째의 경우에는 2개의 명령이 각각 메타데이터 락을 획득하므로 독립적으로 실행된다. 따라서 중간 상태(table not found rank) 가 발생한다. 

#### 메타데이터 잠금과 InnoDB트랜잭션 동시 사용
insert 만 진행되는 로그파일의 경우를 보자 
로그 파일의 테이블 구조를 변경하기 위해서는 DDL을 사용한다. 온라인 DDL을 이용할 수 있지만, 언두 로그 증가와 DDL은 싱글 스레드로 동작하기에 시간이 오래걸릴 수 있다. 이 경우 너무 오랜 시간동안 로그를 기록하지 못하고 대기해야 한다. 
따라서 먼저 기존의 데이터(1시간 전이나 하루전)를 여러개의 스레드로 복사하고, 남은 데이터만 두개의 테이블에 쓰기락을 걸고 복사한 뒤 잠금을 해제하는 방식을 이용하면 된다. 

# 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 레코드 기반 잠금 방식을 탑재하고 있다. 
뛰어난 동시성 처리를 제공하지만, 이원화된 잠금 처리로 인해 MySQL 명령어로 접근하기가 까다롭다. 

최근 버전에서는 infromation_schema 데이터 베이스에 존재하는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블을 조인하여 조회하면 어떤 트랜잭션이 잠금을 대기하고 가지고 있는지 파악할 수 있고, 종료도 가능하다. 
또한, 스토리지 엔진의 내부잠금(세마포어)에 대한 모니터링 방법도 추가됐다.

## 5.3.1 InnoDB 스토리지 엔진의 잠금

레코드 기반 잠금을 제공하며, 이 레코드 락이 페이지락, 테이블락으로 업그레이드 되는 경우는 없다. 
레코드 사이의 간격을 잠그는 갭(GAP)락이 존재한다. 

![](https://velog.velcdn.com/images/pi1199/post/fc2f64c8-46d0-4604-98db-d0e4ad37fddd/image.png)


### 5.3.1.1 레코드 락
레코드 자체만을 잠그는 것을 레코드 락 이라고 한다. 
중요한 점은 레코드 자체를 잠그는 것이 아니라 인덱스의 레코드를 잠근다. 
인덱스가 하나도 없어도 내부적으로 생성되는 클러스터 인덱스를 이용해 잠금을 설정한다. 

인덱스를 이용한 작업은 넥스트 키 락 또는 갭 락을 사용하지만, 프라이머리 키 또는 유니크 인덱스에 대해서는 갭락을 사용하지 않고, 레코드 자체에만 락을 건다. 

### 5.3.1.2 갭락 
레코드와 레코드 사이 간격을 잠근다. 이 간격에 insert되는 것을 방지하는 것이다. 
다음에 설명할 넥스트 키 락의 일부로 주로 사용된다. 

### 5.3.1.3 넥스트 키 락

`넥스트 키 락 = 레코드 락 + 갭 락`
REPEATABLE READ 격리 수준에서 팬텀 리드(Phantom Read)를 방지하기 위해 사용한다. 

갭 락과 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행 될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어 내도록 보장하는 것이 주 목적이다. 

### 5.3.1.4 자동 증가 락
자동 증가하는 숫자 값을 추출하기 위해 `AUTO_INCREMENT` 라는 옵션을 제공한다. 
이를 위해 내부적으로 `AUTO_INCREMENT` 락이라고 하는 테이블 수준의 잠금을 사용한다. 

insert 나 replace 문에서 숫자를 가져오는 순간만 락이 걸렸다가 해제된다. 

## 5.3.2 인덱스와 잠금
InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉, 변경해야할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다. 

이해를 위한 예제를 보자 
first_name 에 인덱스가 걸려있고 first_name="Georgi" 인 사용자가 253명 있다. 그리고 last_name="Klassen" 인 사람은 1명 있다고 가정해 보자.

이때 `update employees set hire_date=NOW() WHERE first_name="Georgi" AND last_name="Klassen"` 이 쿼리문을 실행한다면 어떻게 될까? 
-> 위에서 말했듯이 검색한 인덱스에 모두 락을 걸어야 하기 때문에 253개의 인덱스에 모두 락이 걸린다. 
-> 만약 인덱스가 없다면 employees 테이블을 full-scan 하면서 업데이트를 진행하는데 그러면 employees에 30만명이 있다면 모든 레코드를 잠그게 된다. 

이것이 인덱스 설계가 중요한 이유이다.

### 5.3.3 레코드 수준의 잠금 확인 및 해제

테이블 락보다 단위가 작기 때문에 자주 사용되지 않는다면 발견하기가 어렵다. 
5.1부터는 레코드 잠금과 대기에 대한 조회가 가능하다.
프로세스를 Kill해서 강제로 잠금을 해제할 수 있다.



# 5.4 MySQL의 격리 수준 

여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것이다.
- 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준 = 트랜잭션 끼리 서로 얼마나 고립되어있는지를 나타내는 수준

데이터 베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다. 그래서 locking이라는 개념이 등장한다. 
→ 트랜잭션이 db를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것

하지만 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식을 사용하면 성능이 떨어진다. 반대로 locking 을 줄인다면 잘못된 값이 처리될 가능성이 있다. 

그렇기에 효율적인 locking 사용을 위해 적절한 격리수준이 반드시 필요하다.

- 데이터 베이스의 일관성을 보장하기 위해 사용한다. 
- 데이터 정합성과 성능간에 균형을 맞추기 위해 레벨을 설정한다.
- 레벨이 높아질 수록 데이터 정합성은 더 잘 보장되고, 성능은 저하된다.

아래 그림과 같이 크게 4가지로 나뉜다.
그림에서 아래로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능이 떨어진다. 

![](https://velog.velcdn.com/images/pi1199/post/836fb47f-0f57-4b7c-89df-7c46b6f3ba0c/image.png)

## 5.4.1 READ UNCOMMITTED

각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보이는 수준이다. 

select 가 수행되는 동안 해당 데이터에 shared lock이 걸리지 않는 레벨
트랜잭션 처리중인 혹은 아직 **`커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.`**

사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.
-> 이 현상을 `Dirty Read` 라고 한다.

따라서 데이터의 일관성을 유지할 수 없다. 

![](https://velog.velcdn.com/images/pi1199/post/d9ad9dc8-5b54-474a-8dd7-70643bf1f683/image.png)


## 5.4.2 READ COMMITTED

오라클 DBMS에서 기본으로 사용되는 격리수준이다. 
어떤 트랜잭션에서 데이터를 변경했더라도 Commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있으며 `Dirty Read`가 발생하지 않는다.

update의 경우에는 커밋되기 이전에는 언두 로그에서 백업된 변경 이전의 데이터를 조회한다. 
커밋 이후에는 변경된 데이터를 조회한다. 

![](https://velog.velcdn.com/images/pi1199/post/5b46c738-e968-419b-b789-73f7be96f969/image.png)


update가 아니라 insert의 경우 커밋 이전에는 언두 로그에 변경 내용이 없기에 데이터가 조회되지 않는다. 

![](https://velog.velcdn.com/images/pi1199/post/25f83cea-c65d-4537-8b7d-160dd8cf96bf/image.png)

여기서는`NON-REPEATABLE READ`라는 데이터 부정합 문제가 발생한다. 
별다른 문제가 없어 보일 수 있지만, select 쿼리 실행시 항상 같은 결과를 가져와야 한다는 `REPEATABLE READ` 정합성에 어긋난다. 
이 부정합은 웹 프로그램에서는 문제되지 않을 수 있지만, 동일 데이터를 여러번 읽고 변경하는 작업이 금전적인 문제와 연결되면 문제가 될 수 있다. 

출금 처리가 진행되는 중에 다른 트랜잭션에서 출금 총액을 조회한다면 조회할 때마다 다른 결과를 반환하는 상황이 발생할 수 있다. 

## 5.4.3 REPEATABLE READ
InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 
바이너리 로그를 가진 MySQL서버에서는 최소 이 수준 이상을 사용해야 `NON-REPEATABLE READ` 부정합이 발생하지 않는다. 

트랜잭션 내부에서 실행되는 SELECT와 외부에서 실행되는 SELECT의 차이가 없는 READ-COMMITTED 격리 수준과는 다르게 REPEATABLE-READ 격리 수준은 기본적으로 SELECT 쿼리 문장도 트랜잭션 범위 내에서만 작동한다.

트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다. 
각 트랜잭션마다 번호를 부여하는데 이전 트랜잭션에서 변경된 내용까지만 조회할 수 있다. 

![](https://velog.velcdn.com/images/pi1199/post/a8873baf-1975-4bfe-8a4a-7e8537a5e21c/image.png)


`트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장`하지만, 새로운 레코드가 추가되는 경우 부정합이 생길 수 있다.
-> 이 현상을 `Phantom Read`(유령 읽기)라고 한다. 


![](https://velog.velcdn.com/images/pi1199/post/82dcaa24-87ee-40fe-9491-a70323ebecac/image.png)


## 5.4.4 SERIALIZABLE 
가장 단순하고 엄격한 격리수준이다. 그만큼 동시성 처리 성능이 떨어진다. 
한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다. 따라서 `Phantom Read`가 발생할 수가 없다.

그러나, InnoDB스토리지 엔진 에서는 갭 락과 넥스트 키 락 덕분에 `REPEATABLE READ` 수준에서도 `Phantom Read`가 발생하지 않기에 굳이 쓸 필요가 없다. 

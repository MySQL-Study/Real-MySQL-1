### 5.1 트랜잭션

**5.1.1 MySQL에서의 트랜잭션**

1, 2, 3저장 중 데이터 3이 프라이머리 키 중복일 경우

- MyISAM : 1, 2까지 저장 후 3에서 오류 발생
- InnoDB : 1, 2 INSERT 문장을 실행하기 전 상태로 복구

트랜잭션 ~= IF,ELSE 로 볼 수도 있음

**5.1.2 주의사항**

프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야함

네트워크 작업이 있는 경우 트랜잭션에서 제거해야함

### 5.2 MySQL 엔진의 잠금

MySQL 엔진 : MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분

- MySQL 엔진 수준의 잠금은 모든 스토리지 엔진에 영향

스토리지 엔진

- 스토리지 엔진 레벨의 잠금은 스토리지 엔진간 상호 영향을 미치지 않음

**5.2.1 글로벌 락**

MySQL에서 제공하는 잠금 가운데 가장 범위가 큼

한 세션에서 글로벌 락 획득 시 SELECT 제외 모근 문장은 대기 상태로 남음

MySQL 서버 전체에 영향을 끼치므로 테이블이나 DB가 다르더라도 영향을 끼침

백업 락 : 조금 더 가벼운 글로벌 락

- 테이블의 스키마나 사용자 인증 관련 정보 변경 불가
- 일반적인 테이블의 데이터 변경 허용 → DDL 명령이 실행되면 복제를 일시 중지

**5.2.2 테이블 락**

개별 테이블 단위로 설정되는 잠금

명시적 테이블락

- 직접 명령어로 실행

묵시적 테이블락

- MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용됨
- 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리 완료된 후 자동 해제
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공 → InnoDB테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경 쿼리에서는 무시되고 스키마를 변경하는 쿼리의 경우에만 영향을 미침

**5.2.3 네임드 락**

GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금 설정

사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금

한꺼번에 많은 레코드를 변경하는 쿼리는 데드락의 원인이 됨

→ 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하여 해결

**5.2.4 메타데이터 락**

데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금

### 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 내부에서 레코드 기반 잠금 방식 탑재 → MyISAM 보다 훨씬 더 뛰어난 동시성 처리 제공, 이원화된 잠금 처리 탓에 잠금에 대한 정보 접근하기 어려움

**5.3.1 InnoDB 스토리지 엔진의 잠금**

InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 떄문에 레코드 락이 페이지 락으로 레벨업되는 경우는 없음

레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재

**5.3.1.1 레코드락**

레코드 자체만을 잠그는 것

InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금

인덱스가 없더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정

**5.3.1.2 갭 락**

레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것

레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어

**5.3.1.3 넥스트 키 락**

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금

바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적

**5.3.1.4 자동 증가 락**

저장된 순서대로 증가하는 일련번호 값을 가지도록 하기 위함

짧은 시간동안 사용되며 자동 증가 값이 한번 증가하면 줄어들지 않는 이유가 자동 증가 락을 최소화하기 위함임

**5.3.2 인덱스와 잠금**

InnoDB의 잠금은 인덱스를 잠그는 것 → 변경할 레코드를 찾기 위해 인덱스으 ㅣ레코드를 모두 락을 걸어야 함

UPDATE 실행 → 인덱스를 이용할 수 있는 조건으로 찾은 레코드가 모두 잠김

인덱스가 없다면 테이블을 풀 스캔하면서 UPDATE → 모든 레코드가 잠김

### 5.3.3 레코드 수준의 잠금 확인 및 해제

레코드 수준 잠금 → 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않음

17번 스레드 : 트랜잭션 시작 후 UPDATE 명령이 실행 완료 BUT COMMIT을 실행하지 않은 상태이므로 업데이트한 레코드의 잠금을 그대로 가지고 있음

18번 스레드 : 17번 스레드 이후 UPDATE 명령 → 17번 스레드를 기다림

19번 스레드 : 18번 스레드 이후 UPDATE 명령 → 17번, 18번 스레드를 기다림

### 5.4 MySQL의 격리 수준

**5.4.1 READ UNCOMMITTED**

A가 데이터 INSERT 후 No  Commit

B가 데이터 조회 → 조회 가능

A가 롤백 → B가 여전히 조회 가능

어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데 다른 트랜잭션에서 볼 수 있는 것이 더티 리드이면 READ UNCOMMITTED라면 더티 리드 가능

**5.4.2 READ COMMITTED**

A가 데이터 변경 → 이전 값이 언두 영역으로

B가 커밋 수행 전 SELECT → 이전 값 조회 됨(언두 영역에서 가져옴)

READ COMMITTED에서는 커밋 전까지 변경한 내용 조회 불가

⇒ 커밋과 조회 시점에 따라 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋남

**5.4.3 REPEATABLE READ**

InnoDB 스토리지 엔진의 기본 격리 수준

모든 트랜잭션은 순차적 증가 번호를 가짐

언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호거 있음

트랜잭션 6에 의해 데이터 INSERT

A가 12, B가 10

A가 데이터 변경 후 커밋 → B가 A 트랜잭션 변경 전 후 각각 SELECT 값이 같음

B가 BEGIN 명령으로 트랜잭션 시작하면서 10번 부여받았지만, 10번 트랜잭션 안에서 실행되는 모든 SELECT 쿼리는 트랜잭션 번호가 10보다 작은 트랜잭션 번호에서 변경한 것만 보게됨

A가 INSERT 실행 도중 B가 SELECT … FOR UPdATE 쿼리로 조회 시

SELECT … FOR UPDATE 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하지만 언두 레코드에는 잠금 불가 ⇒ 언두 영역의 변경 전 데이터가 아닌 현재 레코드의 값을 가져옴

**5.4.4 SERIALIZABLE**

읽기작업도 공유 잠금을 획득해야 함

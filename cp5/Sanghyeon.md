### 5.1 트랜잭션

**5.1.1 MySQL에서의 트랜잭션**

1, 2, 3저장 중 데이터 3이 프라이머리 키 중복일 경우

- MyISAM : 1, 2까지 저장 후 3에서 오류 발생
- InnoDB : 1, 2 INSERT 문장을 실행하기 전 상태로 복구

트랜잭션 ~= IF,ELSE 로 볼 수도 있음

**5.1.2 주의사항**

프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야함

네트워크 작업이 있는 경우 트랜잭션에서 제거해야함

### 5.2 MySQL 엔진의 잠금

MySQL 엔진 : MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분

- MySQL 엔진 수준의 잠금은 모든 스토리지 엔진에 영향

스토리지 엔진

- 스토리지 엔진 레벨의 잠금은 스토리지 엔진간 상호 영향을 미치지 않음

**5.2.1 글로벌 락**

MySQL에서 제공하는 잠금 가운데 가장 범위가 큼

한 세션에서 글로벌 락 획득 시 SELECT 제외 모근 문장은 대기 상태로 남음

MySQL 서버 전체에 영향을 끼치므로 테이블이나 DB가 다르더라도 영향을 끼침

백업 락 : 조금 더 가벼운 글로벌 락

- 테이블의 스키마나 사용자 인증 관련 정보 변경 불가
- 일반적인 테이블의 데이터 변경 허용 → DDL 명령이 실행되면 복제를 일시 중지

**5.2.2 테이블 락**

개별 테이블 단위로 설정되는 잠금

명시적 테이블락

- 직접 명령어로 실행

묵시적 테이블락

- MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용됨
- 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리 완료된 후 자동 해제
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공 → InnoDB테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경 쿼리에서는 무시되고 스키마를 변경하는 쿼리의 경우에만 영향을 미침

**5.2.3 네임드 락**

GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금 설정

사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금

한꺼번에 많은 레코드를 변경하는 쿼리는 데드락의 원인이 됨

→ 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하여 해결

**5.2.4 메타데이터 락**

데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금

### 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 내부에서 레코드 기반 잠금 방식 탑재 → MyISAM 보다 훨씬 더 뛰어난 동시성 처리 제공, 이원화된 잠금 처리 탓에 잠금에 대한 정보 접근하기 어려움

**5.3.1 InnoDB 스토리지 엔진의 잠금**

InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 떄문에 레코드 락이 페이지 락으로 레벨업되는 경우는 없음

레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재

**5.3.1.1 레코드락**

레코드 자체만을 잠그는 것

InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금

인덱스가 없더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정

**5.3.1.2 갭 락**

레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것

레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어

**5.3.1.3 넥스트 키 락**

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금

바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적

**5.3.1.4 자동 증가 락**

저장된 순서대로 증가하는 일련번호 값을 가지도록 하기 위함

짧은 시간동안 사용되며 자동 증가 값이 한번 증가하면 줄어들지 않는 이유가 자동 증가 락을 최소화하기 위함임

**5.3.2 인덱스와 잠금**

InnoDB의 잠금은 인덱스를 잠그는 것 → 변경할 레코드를 찾기 위해 인덱스으 ㅣ레코드를 모두 락을 걸어야 함

UPDATE 실행 → 인덱스를 이용할 수 있는 조건으로 찾은 레코드가 모두 잠김

인덱스가 없다면 테이블을 풀 스캔하면서 UPDATE → 모든 레코드가 잠김

### 5.3.3 레코드 수준의 잠금 확인 및 해제

레코드 수준 잠금 → 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않음

17번 스레드 : 트랜잭션 시작 후 UPDATE 명령이 실행 완료 BUT COMMIT을 실행하지 않은 상태이므로 업데이트한 레코드의 잠금을 그대로 가지고 있음

18번 스레드 : 17번 스레드 이후 UPDATE 명령 → 17번 스레드를 기다림

19번 스레드 : 18번 스레드 이후 UPDATE 명령 → 17번, 18번 스레드를 기다림

### 5.4 MySQL의 격리 수준

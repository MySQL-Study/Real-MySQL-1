### Partitions 칼럼

explain 명령으로 파티션 관련 실행 계획까지 모두 확인 가능

파티션 프루닝 : 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정

파티션을 참조하는 쿼리의 경우 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행계획의 partitions 칼럼에 표시해줌

파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가지기 때문에 풀 테이블 스캔으로도 테이블의 일부만을 읽을 수 있음

### type 칼럼

쿼리 튜닝 시 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행 계획에서 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타내는 type 칼럼은 반드시 읽어야함

type칼럼은 조인 타입이지만 type 칼럼의 값은 조인과 직접 연관지어 생각하지 말고, 각 테이블의 접근 방법으로 해석

**system**

system : 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법

MyISAM이나 MEMORY 테이블에서만 사용되는 접근방법

**const**

const : 반드시 1건을 반환하는 쿼리의 처리 방식(유니크 인덱스 스캔)

**eq_ref**

eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됨

조인에서 처음 읽은 테이블의 칼럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때를 가지켜 eq_ref라고 함

또한 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL이어야 하며, 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용돼야만 eq_ref 접근 방법 사용가능

**ref**

eq_ref와 달리 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건이 없음

인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용됨

ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않지만 동근한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나임

**fulltext**

서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법

**ref_or_null**

ref 접근 방법과 같으며, null 비교가 추가된 형태

**unique_subquery**

where 조건절에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방법

서브쿼리에서 중복되지 않은 유니크한 값만 반환할 때 이 접근 방법을 사용

**index_subquery**

IN 연산자의 특성상 IN 또는 IN 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야함

IN에서 subquery가 중복된 값을 반환할 수 있으며, 이때 서브쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 index_subquery 접근 방법이 사용됨

**range**

인덱스 레인지 스캔 형태의 접근 방법

<, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용됨

**index_merge**

2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식

아래와 같은 특징을 가짐

- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어짐
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_range가 적용되지 않음
- 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요함

**INDEX**

인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미함

range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아님

index 접근 방법은 다음 조건 가운데 1, 2 조건을 충족하거나 1, 3 조건을 충족하는 쿼리에서 사용되는 읽기 방식

- range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
- 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우
- 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우

**ALL**

풀 테이블 스캔으로 index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경에는 적합하지 않음

### possible_keys 칼럼

MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행하는데, possible_keys 칼럼에 있는 내용은 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록

### key 칼럼

key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미함

쿼리를 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요

### key_len 칼럼

실제 업무에서는 단일 칼럼으로만 만들어진 인덱스보다 다중 칼럼으로 만들어진 인덱스가 더 많음

key_len 칼럼의 값은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려줌

### ref 칼럼

접근 방법이 ref면 참조 조건으로 어떤 값이 제공됐는지 보여줌

### rows 칼럼

각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 비교해 최종적으로 하나의 실행 계획을 수립

이때 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해서 비용을 산정하며 대상 테이블에 얼마나 많은 레코드가 포함돼 있는지 또는 각 인덱스 값의 분포도가 어떤지를 통계 정보를 기준으로 조사해서 예측

row 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여줌

### filtered 칼럼

대부분의 쿼리에서 where 절에 사용되는 조건이 모두 인덱스를 사용할 수 있는 것은 아니며 조인이 사용되는 경우에는 where 절에서 인덱스를 사용할 수 있는 조건도 중요하지만 인덱스를 사용하지 못하는 조건에 일치하는 레코드 건수를 파악하는 것도 매우 중요

따라서 filtered 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라짐

### Extra 칼럼

extra 킬럼에는 아래와 같은 문장들이 표시될 수 있음

**const row not found**

const 접근 방법으로 테이블을 읽었지만 해당 테이블에 레코드가 1건도 존재하지 않을 경우

**Deleting all rows**

delete 문장의 실행 계획에서 자주 표시됨

**Distinct**

쿼리의 distinct를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인했으며, dept_emp 테이블에서는 꼭 필요한 레코드만 읽음

**FirstMatch**

FirstMatch 메시지에 함께 표시되는 테이블명은 기준 테이블을 의미

employees 테이블을 기준으로 titles 테이블에서 첫 번째로 일치하는 한 건만 검색

**Impossible Having**

쿼리에 사용된 having 절의 조건을 만족하는 레코드가 없을 때 실행 계획의 extra 칼럼에 Impossible Having 키워드가 표시됨

## 10.3.3 table칼럼 
실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 
테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.

table 칼럼에 `<>`로 둘러싸인 이름이 명시될 때, 그 테이블은 임시 테이블을 의미한다. 
`<>` 안에 표시되는 숫자는 단위 SELECT 쿼리의 id값이다.

## 10.3.4 partitions 칼럼

파티션 생성시 제약 사항이 있다.
`파티션 키로 사용되는 칼럼은 프라이머리 키를 포함한 모든 유니크 인덱스의 일부여야 한다.`
이 제약사항으로 인해 파티션 생성시 프라이머리키에 emp_no 칼럼과 함께 hire_date 칼럼을 추가해서 파티션 테이블이 생성했다. 
``` SQL
EXPLAIN SELECT *
		FROM employee_2
        WHERE hire_date FROM BETWEEN '1999-11-15' AND '2000-01-15';
```
파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝이라고 한다.

파티션을 참조하는 쿼리의 경우 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행 계획의 partitions 칼럼에 표시해준다.

type 칼럼의 값이 ALL인 이유는, 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가지기 때문이다. 해당하는 파티션만 풀 스캔을 실행한다.

## 10.3.5 type 칼럼
type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 type 칼럼은 반드시 체크해야 한다.

ALL을 제외한 나머지 방법은 모두 인덱스를 사용하는 접근 방법이다. ALL은 풀 테이블 스캔이다.
하나의 단위 SELECT 쿼리는 접근법 중 단 하나만 사용할 수 있다.
index_merge를 제외한 방법들은 하나의 인덱스만 사용한다.

type 칼럼에 표시될 수 있는 값 (성능 빠른 순)
- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subquery
- index_subquery
- range
- index_merge
- index
- ALL

### 10.3.5.1 system
레코드가 1건만 존재하거나 아예 없는 테이블을 참조하는 형태의 접근 방법이다.
InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않는다.

### 10.3.5.2 const

레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식이다. 
다중 칼럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 칼럼만 조건으로 사용하면 const 타입의 접근 방식을 사용할 수 없다. -> 레코드가 1건인걸 확인할 수 없기 때문이다. 
옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화하기 때문에 이름이 const다.

### 10.3.5.3 eq_ref

여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
조인에서 처음 읽은 테이블의 칼럼값을 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때, 두 번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시된다.
조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.

### 10.3.5.4 ref

조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다.
인덱스의 종류와 관계없이 동등 조건으로 검색할 때 ref 접근 방법이 사용된다.

`const, eq_ref, ref는 성능이 매우 좋은 방법으로 쿼리 튜닝 시 신경 쓰지 않아도 괜찮다.`

### 10.3.5.5 fulltext
전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법이다. 전문 검색 인덱스가 정의돼 있어야 한다.

쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방법이 const, eq_ref, ref가 아니면 일반적으로 MySQL 옵티마이저는 전문 인덱스를 사용하는 조건을 선택한다.

### 10.3.5.6 ref_or_null

ref 접근 방법과 같은데, NULL 비교가 추가된 형태다.
접근 방법의 이름 그대로 ref 방식 또는 NULL 비교(IS NULL) 접근 방법을 의미한다.

### 10.3.5.7 unique_subquery
WHERE 조건절에서 사용되는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다.
unique_subquery 의미 그대로 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.


### 10.3.5.8 index_subquery
IN(subquery) 또는 IN (상수 나열) 형태의 조건에서 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있을 때 이 접근 방법을 사용한다.


### 10.3.5.9 range
인덱스 레인지 스캔 형태의 접근 방법이다.
range는 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다. 주로 `<, >, IS NULL, BETWEEN, IN, LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.
range 접근 방법도 상당히 빠르고 최적의 성능이 보장된다고 볼 수 있다.


### 10.3.5.10 index_merge

2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.

### 10.3.5.11 index
인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 방식
인덱스만 읽기 때문에 풀 테이블 스캔보다 빠르다.

### 10.3.5.12 ALL
풀 테이블 스캔이다. 

## 10.3.6 possible_keys 칼럼
옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 인덱스의 목록이다.
"사용될법 했던 인덱스의 목록"이다. 이 목록에 나왔다고 인덱스가 사용된 것이 아니다. 

## 10.3.7 key 칼럼

key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스이다.
쿼리를 튜닝할 때는 이 칼럼에 의도했던 인덱스가 나오는지 확인하는 것이 중요하다.
PRIMARY 또는 인덱스 이름으로 표시된다.

## 10.3.8 key_len 칼럼
다중 칼럼으로 만들어진 인덱스에서 쿼리를 처리하기 위해 몇개의 칼럼이 사용됐는지를 판단할 때 사용되는 칼럼이다. 때문에 중요한 칼럼 중 하나이다. 바이트 단위로 표시된다.
```SQL
EXPLAIN SELECT *
		FROM dept_emp WHERE dept_no='d005';
```
위의 쿼리에서 프라이머리 키는 (dept_no, emp_no)로 구성된다.
dept_no 칼럼의 타입이 CHAR(4) 이기 때문에 프라이머리 키에서 앞쪽 16바이트만 유효하게 사용했다는 의미이다.
utf8mb4 문자 집합에서 문자 하나가 차지하는 공간이 1 ~ 4 바이트로 가변적이지만 MySQL 서버에서 메모리 공간을 할당해야 할 때는 고정 4바이트로 계산한다.
따라서 16바이트가 표시되었다.

## 10.3.9 ref 칼럼
접근 방법이 ref, eq_ref일 때 참조 조건(Where 절의 동등 비교)으로 어떤 값이 제공됐는지 보여준다.
ref의 값이 func일때는 연산을 거쳐서 사용되었다는 것을 의미한다. 
명시적으로 값을 변환할 때뿐만 아니라 MySQL 서버가 내부적으로 값을 변환해야 할 때도 ref 칼럼에는 func가 출력된다. 

## 10.3.10 rows 칼럼
MySQL 옵티마이저는 가능한 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해서 비용을 산정한다.
rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.
이 값은 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.
이 값은 반환하는 레코드를 예측한 수가 아니라 쿼리를 처리하기 위해 체크한 레코드 수를 의미한다.
그래서 실행 계획의 rows 칼럼에 출력되는 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많다.

## 10.3.11 filtered 칼럼
각 테이블에서 일치하는 레코드 개수를 가능하면 정확히 파악해야 더 효율적인 실행계획을 수립할 수 있다.

특히나 조인을 사용할 때 일치하는 레코드 수가 적은 테이블이 드라이빙 테이블로 선정되어야 하는데 이 때 `rows 칼럼 * filtered 칼럼` 의 결과로 비교한다.
filtered 칼럼 값은 필터링되고 남은 레코드의 비율을 의미한다.

## 10.3.12 Extra 칼럼
Extra 칼럼에는 성능에 관련된 중요한 내용이 자주 표시된다.
내부적인 처리 알고리즘에 대해 조금 더 깊이있는 내용을 보여주는 경우가 많다.


### 10.3.12.1 const row not found

const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않을 때 표시된다.

### 10.3.12.2 Deleting all rows

Where 조건절이 없는 DELETE 문장의 실행 계획에서 자주 표시된다.

### 10.3.12.3 Distinct

만약 departments 테이블을 조회하는데, 조건에 dept_emp 테이블에 존재하는 dept_no를 가져야 하는 경우 dept_no만 중복없이 유니크하게 가져오기 위한 쿼리이다. 
두 테이블을 조인해서 그 결과에 Distinct를 한 것이다.

### 10.3.12.4 FirstMatch

세미 조인의 FirstMatch 전략을 사용한다면 FirstMatch(table_name) 메시지를 출력한다.
함께 표시되는 테이블명은 기준 테이블을 의미한다.

### 10.3.12.5 Full scan on NULL key


쿼리를 실행하는 중 col1이 Null을 만나면 차선책으로 서브쿼리 테이블에 대해서 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드이다. 
`col1 in (select cole from...)`과 같은 서브쿼리에서 col1이 not null이라면 이 키워드가 나타나지 않을 것이다. 
col1이 null이면 서브쿼리에 사용된 테이블에 대해서 풀 테이블 스캔을 해야만 결과를 알아낼 수 있다. 

### 10.3.12.6 Impossible Having

Having 절의 조건을 만족하는 레코드가 없을 때 발생한다.
예를 들어 NOT NULL 인 칼럼인데 having 조건에 IS NULL 이 있다면 이 조건을 만족할 가능성이 없다. 
쿼리가 잘못 쓰여졌으므로 다시 점검해야한다.

### 10.3.12.7 Impossible Where

where 조건이 항상 FALSE가 될 수밖에 없을 때 발생한다. 
위와 마찬가지로 where 조건을 만족할 가능성이 없을 때 발생한다. 

### 10.3.12.8 LooseScan
세미 조인의 LooseScan 최적화 전략이 사용될 때 발생한다. 9.3.1.12에 설명되어 있다. 

### 10.3.12.9 No matching min/max row
MIN() 이나 MAX() 와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 발생한다. 


### 10.3.12.10 no matching row in const table
조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없다면 발생한다. 
SQL에서 const 방법은 주로 상수 조인을 의미합니다. 
-> 숫자 10 이나 "New York" 등 값을 상수라고 표현합니다.

### 10.3.12.11 No matching rows after partition pruning

해당 파티션에서 UPDATE하거나 DELETE 할 대상 레코드가 없을 때 발생한다. 
단순히 삭제할 레코드가 없음을 의미하는 것이 아니라 대상 파티션이 없다는 것을 의미한다.
예를 들어 2010년 이후 기록을 삭제하고 싶을 때, 파티션된 데이터가 2000년까지만 존재한다면 2010에 대한 파티션이 없을 수 있다. 이때 2010년이후 데이터를 삭제하려고 하면 이 메세지가 나타난다.

### 10.3.12.12 No tables used
FROM 절이 없는 쿼리 문장이나 FROM DUAL 형태의 쿼리를 실행 할 경우 발생한다. 
MySQL은 from절이 없는 쿼리도 허용된다. 이처럼 실제 테이블이 사용되지 않고 상수 테이블(DUAL)이 사용될 때 나타난다. 

### 10.3.12.13 Not exists 
A 테이블에는 존재하지만 B 테이블에는 없는 값을 조회해야 하는 경우 발생한다. 
이럴 때는 주로 NOT IN(subquery) 형태나 NOT EXISTS 연산자를 사용한다. 이를 안티조인이라고 한다. 
안티 조인은 outer join을 이용할 때, 일반 조인에서 나타나지 않는 결과만 가져오는 방법이다. 이 안티조인을 사용할 때 이 메세지가 나타난다. 


### 10.3.12.14 Plan isn’t ready yet
다른 커넥션에서 실행 중인 쿼리의 실행 계획을 살펴볼 때 쿼리의 실행 계획을 수립하지 못한 상태에서 조회 시에 위와 같이 표시된다.

### 10.3.12.15 Range checked for each record(index map: N)
``` SQL
EXPALIN
SELECT *
FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no
```
위의 쿼리와 같이 레코드마다 인덱스 레인지 스캔을 하게 되는 경우
괄호 안의 index map: N 은 인덱스를 사용할지 말지 판단하게 되는 인덱스를 의미한다.

-> 잘 이해가 안됩니다..ㅠㅠ

### 10.3.12.16 Recursive
8.0 부터는 CTE(Common Table Expression)를 이용한 재귀 쿼리를 작성할 수 있다. 이 재귀 쿼리가 사용될 때 나타난다. 
![](https://velog.velcdn.com/images/pi1199/post/7687c763-638f-405c-9270-3cc428ff4a6c/image.png)


### 10.3.12.17 Rematerialize
래터럴 조인으로 조인되는 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시 테이블에 저장한다. 이 과정을 Rematerialing 이라고 한다. 

### 10.3.12.18 Select tables optimized away
MIN() 또는 MAX() 만 SELECT 절에 사용되거나 GROUP BY로 MIN(), MAX()를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 최적화가 적용될 때 나타난다. 

### 10.3.12.19 Start temporary, End Temporary
세미 조인 최적화 중에서 Duplicate Weed-out 최적화 전략이 사용될 때 나타난다. 
불필요한 중복건을 처리하기 위해 임시 테이블을 사용하는데 이를 식별하기 위한 용도이다. 
조인의 첫번째는 "Start Temporary", 마지막은 "End Temporary"로 표시된다. 
최적화는 9.3.1.14를 참고하자

### 10.3.12.20 unique row not found
두 개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 나타난다. 
### 10.3.12.21 Using filesort
Order by 처리를 인덱스로 할 수 없을 때 레코드를 조회하고 메모리 버퍼에 복사해 정렬을 하게된다. 이 정렬용 메모리 버퍼를 사용할 때 나타난다. 

### 10.3.12.22 Using index(커버링 인덱스)
인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 나타난다.


### 10.3.12.23 Using index condition
인덱스 컨디션 푸시 다운 최적화를 사용할 때 나타난다. 
9.3.1.3 절에서 인덱스 컨디션 푸시다운 최적화를 참고하자. 


### 10.3.12.24 Using index for group-by
그룹 바이를 사용할 때 인덱스를 사용하면 레코드 정렬이 필요하지 않고, 인덱스의 필요한 부분만 읽으면 되기 때문에 매우 빠르게 처리된다. 
- 타이트 인덱스 스캔을 통한 GROUP BY 처리 -> Using index for group-by 표시 X
- 루스 인덱스 스캔을 통한 GROUP BY 처리 -> Using index for group-by 표시

### 10.3.12.25 Using index for skip scan
인덱스 스킵 스캔 최적화를 사용할 때 나타난다. 

### 10.3.12.26 Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join buffer(hash join)

MySQL 옵티마이저는 조인되는 두 테이블에 있는 각 칼럼에서 인덱스를 조사하고 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행한다.
드리븐 테이블의 조인 칼럼에 적절한 인덱스가 없다면 서버는 블록네스티드 루프조인이나 해시조인을 사용한다.


### 10.3.12.27 Using MRR
MySQL 엔진은 여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고, 스토리지 엔진은 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화한다.


### 10.3.12.28 Using sort_union(…), Using union(…), Using intersect(…)

index_merge 접근 방법으로 실행되는 경우 두 개의 인덱스를 어떻게 병합했는지를 표시한다.


### 10.3.12.29 Using temporary
MySQL 서버에서 쿼리를 처리할 때 중간 결과를 담아 두기 위해 임시 테이블을 생성하는 경우 표시된다.
메모리 or 디스크에 생성되는데 실행 계획만으로는 알 수 없다.

### 10.3.12.30 Using Where
MySQL 스토리지 엔진에서 얻어온 레코드를 MySQL 엔진에서 별도로 가공하는 경우에만 Using where 코멘트가 표시된다.

### 10.3.12.31 Zero Limit

MySQL 서버에서 데이터 값이 아닌 쿼리 결괏값의 메타데이터만 필요한 경우 쿼리 마지막에 LIMIT 0를 사용하면 된다.
옵티마이저도 이러한 사용자의 의도를 알아채고 레코드를 읽지 않고 메타데이터만 반환한다.


### 10.3.3 table 칼럼
- MySQL 서버의 실행 계획은 단위 SEELCT 쿼리 기준이 아니라 테이블 기준으로 표시됨
- 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시됨
- 오라클 RDBMS에서는 FROM 절이 없으면 오류가 발생하지만 MySQL은 그렇지 않음
- <derived N> 또는 <union M, N>과 같이 `<>`로 둘러싸인 이름이 명시되는 경우 임시 테이블을 의미. `<>`안의 숫자는 단위 SELECT 쿼리의 id 값을 지칭
- select_type이 MATERIALIZED인 실행 계획에서는 `<subquery N>`과 같은 값이 table 칼럼에 표시됨. 이는 서브쿼리의 결과를 구체화해서 임시 테이블로 만들었다는 의미이며, 실제로는 <derived N>과 같은 방법으로 해석하면 됨

### 10.3.4 partitions 칼럼
- MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록은 EXPLAIN PARTITION 명령을 이용해 확인 가능했지만 MySQL 8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 모두 확인 가능하도록 변경
- 파티션 프루닝(partition pruning): 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정
- MySQL을 포함한 대부분의 RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가지기 때문에 풀 테이블 스캔으로 테이블의 일부만 읽을 수 있음
  - type이 ALL이지만 쿼리의 실행 계획의 partitions에 작성된 파티션들만 풀 스캔 실행

### 10.3.5 type 칼럼
- 쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타냄
- MySQL의 매뉴얼에서는 type 칼럼을 `조인 타입`으로 소개함
- 12개의 접근 방법이 있고 아래에 성능이 빠른 순서대로 설명
- index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용

#### 10.3.5.1 system
- 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법

#### 10.3.5.2 const
- 테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식
- 다른 DBMS에서는 이를 유니크 인덱스 스캔이라고도 표현
- 다중 칼럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 칼럼만 조건으로 사용할 때는 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확신할 수 없기 때문에 const 타입의 접근 방법을 사용 불가

#### 10.3.5.3 eq_ref
- 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됨
- 조인에서 처음 읽은 테이블의 칼럼 값을, 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때를 가리킴(동등 조건 검색). 이 때 두 번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시됨
- 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법

#### 10.3.5.4 ref
- 인덱스의 종류와 관계없이 동등 조건으로 검색할 때 사용됨
- `const`, `eq_ref`, `ref` 모두 WHERE 조건절에 사용하는 비교 연산자는 동등 바교 연산자`<=>`여야 한다는 공통점이 있음. 인덱스의 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는 접근 방법

#### 10.3.5.5 fulltext
- MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법 의미
- 전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 함
- MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높음
- 전문 검색은 `MATCH (...) AGAINST (...)` 구문을 사용해서 실행하는데, 이때 반드시 해당 테이블에 전문 검색용 인덱스가 준비돼 있어야 함
- 전문 검색 인덱스를 이용하는 fulltext보다 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 더 많았음. 따라서 전문 검색 쿼리를 사용할 때는 조건별로 성능을 확인해 보는 편이 좋음

#### 10.3.5.6 ref_or_null
- ref 방식 또는 NULL 비교(IS NULL) 접근 방법 의미

#### 10.3.5.7 unique_subquery
- WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법
- 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 사용
- MySQL 8.0 버전에서는 이렇게 WHERE 조건절에 사용된 IN(subquery) 형태의 세미 조인을 최적화하기 위한 많은 기능이 도입됨 -> 실제로 더 최적화된 다른 실행 계획이 보일 것임
<details>
<summary>더 최적화된 다른 실행 계획(gpt)</summary>

1. unique_subquery 대신 exists_subquery
MySQL 8.0에서는 unique_subquery가 exists_subquery로 대체될 수 있습니다.
이는 MySQL이 IN (subquery)를 EXISTS (subquery)로 변환하여 최적화하는 경우입니다.

```sql
SELECT * 
FROM orders
WHERE customer_id IN (SELECT customer_id FROM customers WHERE country = 'USA');
```
✅ 실행 계획:

```
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
| id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra          |
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
|  1 | SIMPLE      | customers  | ref  | country_idx   | ...  | ...     | ...  | ...      | Using index    |
|  2 | SIMPLE      | orders     | ref  | customer_idx  | ...  | ...     | ...  | ...      | Using index    |
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
```
➡ MySQL 8.0에서는 IN (subquery)가 EXISTS (subquery)로 변환되어 최적화될 수 있습니다.
➡ 이를 통해 서브쿼리 실행 횟수를 줄이고, 반복적으로 수행되는 조인을 줄일 수 있습니다.

2. semi-join 변환 (materialization 최적화)
MySQL 8.0에서는 semi-join 최적화를 적용하여, 서브쿼리를 한 번만 실행하고, 결과를 캐싱하여 사용합니다.

```sql
SELECT * 
FROM orders 
WHERE customer_id IN (SELECT DISTINCT customer_id FROM customers WHERE country = 'USA');
```
✅ 실행 계획:

```
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
| id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra          |
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
|  1 | SIMPLE      | customers  | ref  | country_idx   | ...  | ...     | ...  | ...      | Using index    |
|  2 | SIMPLE      | orders     | ref  | customer_idx  | ...  | ...     | ...  | ...      | Using semi-join|
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
```
➡ Using semi-join이 실행 계획에 나타나면, MySQL이 semi-join 최적화를 적용한 것입니다.
➡ customers 서브쿼리를 한 번만 실행하고, 이를 메모리에 저장하여 재사용할 수 있습니다.

3. IN (subquery) → INNER JOIN 최적화 (subquery_to_join 변환)
MySQL 8.0에서는 서브쿼리를 내부 조인(INNER JOIN)으로 변환하여 최적화할 수 있습니다.

```sql
SELECT * 
FROM orders
WHERE customer_id IN (SELECT customer_id FROM customers WHERE country = 'USA');
```
✅ MySQL 8.0에서는 아래와 같이 변환될 수 있습니다.

```sql
SELECT o.* 
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
WHERE c.country = 'USA';
```
✅ 실행 계획:
```
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
| id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra          |
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
|  1 | SIMPLE      | customers  | ref  | country_idx   | ...  | ...     | ...  | ...      | Using index    |
|  2 | SIMPLE      | orders     | ref  | customer_idx  | ...  | ...     | ...  | ...      | Using join buffer (Block Nested Loop) |
+----+-------------+------------+------+---------------+------+---------+------+----------+----------------+
```
➡ MySQL이 IN (subquery)를 내부 조인(INNER JOIN)으로 변환하면 더 빠르게 실행될 수 있습니다.
➡ JOIN을 사용할 때 인덱스가 최적화된 경우, IN보다 훨씬 빠를 수 있습니다.

✅ 결론
MySQL 8.0에서는 unique_subquery가 다음과 같은 실행 계획으로 최적화될 수 있습니다.

exists_subquery 변환: IN (subquery)가 EXISTS (subquery)로 변환됨.
semi-join 최적화: 서브쿼리를 한 번만 실행하고 메모리에 저장하여 사용.
subquery_to_join 변환: IN (subquery)를 내부 조인(INNER JOIN)으로 변환하여 최적화.
➡ MySQL 8.0에서는 실행 계획이 더 최적화되어 unique_subquery가 더 이상 사용되지 않는 경우가 많습니다.
</details>

#### 10.3.5.8 index_subquery
- IN (subquery) 형태의 조건에서 subquery의 반환 값에는 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음

#### 10.3.5.9 range
- 인덱스 레인지 스캔 형태의 접근 방법
- 하나의 값이 아니라 범위로 검색하는 경우를 의미, 주로 `<, >, IS NULL, BETWEEN, IN, LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용됨
- 우선순위가 상당히 낮지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있음

#### 10.3.5.10 index_merge
- 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식
- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어짐
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않음
- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요

#### 10.3.5.11 index
- 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미
- 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔 시 풀 테이블 스캔보다 빠르게 처리됨

#### 10.3.5.12 ALL
- 풀 테이블 스캔을 의미하는 접근 방법
- 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환
- 다른 DBMS와 같이 InnoDB도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 I/O를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어 들이는 기능을 제공
- InnoDB에서는 이 기능을 리드 어헤드(Read Ahead)라고 하며 한 번에 여러 페이지를 읽어서 처리 가능
- 일반적으로 index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경에는 적합하지 않음

### 10.3.6 possible_keys 칼럼
- 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록 -> 사용될법했던 인덱스의 목록
- 특별한 경우를 제외하곤느 그냥 무시 가능

### 10.3.7 key 칼럼
- 최종 선택된 실행 계획에서 사용하는 인덱스
- key 칼럼에 표시되는 값이 PRIMARY인 경우에는 프라이머리 키를 사용한다는 의미이며, 그 이외의 값은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름

### 10.3.8 key_len 칼럼
- 실제 업무에서 사용하는 테이블은 단일 칼럼으로만 만들어진 인덱스보다 다중 칼럼으로 만들어진 인덱스가 더 많음
- 실행 계획의 key_len 칼럼의 값은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려줌 -> 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값
- MySQL에서는 NOT NULL이 아닌 칼럼에서는 칼럼의 값이 NULL인지 아닌지를 저장하기 위해 1바이트를 추가로 더 사용

### 10.3.9 ref 칼럼
- 접근 방법이 ref면 참조 조건으로 어떤 값이 제공됐는지 보여줌
- 상숫값을 지정했다면 ref 칼럼의 값은 const로 표시되고, 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시됨
- 가끔 쿼리의 실행 계획에서 ref 칼럼의 값이 func라고 표시될 때
  - 사용자가 명시적으로 값을 변환할 때뿐만 아니라 MySQL 서버가 내부적으로 값을 변환해야 할 때
  - 문자 집합이 일치하지 않는 두 문자열 칼럼을 조인한다거나 숫자 타입의 칼럼과 문자열 타입의 칼럼으로 조인할 때
  - 가능하다면 MySQL 서버가 이런 변환을 하지 않아도 되게 조인 칼럼의 타입은 일치시키는 편이 좋음

### 10.3.10 rows 칼럼
- 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여줌 -> 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미
- 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않음

### 10.3.11 filtered 칼럼
- 필터링되고 남은 레코드의 비율 의미
- MySQL 서버 옵티마이저는 조인의 횟수를 줄이고 그 과정에서 읽어온 데이터를 저장해둘 메모리 사용량을 낮추기 위해 대상 건수가 적은 테이블을 선행 테이블로 선택할 가능성이 높음 -> filtered 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라짐

### 10.3.12 Extra 칼럼
- 주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여주는 경우가 많음

#### 10.3.12.1 const row not found
- 쿼리의 실행 계획에서 const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않을 경우

#### 10.3.12.2 Deleting all rows
- MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진 테이블인 경우
- WHERE 조건절이 없는 DELETE 문장의 실행계획에서 자주 표시됨
- 테이블의 모든 레코드를 삭제하는 핸들러 기능(API)을 한번 호출함으로써 처리됨을 의미
- MySQL 8.0 버전에서는 InnoDB 스토리지 엔진과 MyISAM 엔진 모두 더 이상 실행 계획에 표시되지 않음 -> TRUNCATE TABLE 명령 사용 권장

#### 10.3.12.3 Distinct
- 불필요한 행 처리를 건너뛰고, 중복을 제거하는 최적화가 적용되었음을 의미

#### 10.3.12.4 FirstMatch
- 세미 조인의 여러 최적화 중에서 FirstMatch 전략이 사용되면 MySQL 옵티마이저는 실행 계획의 Extra 칼럼에 `FirstMatch(table_name)` 메세지를 출력

#### 10.3.12.5 Full scan on NULL key
- 쿼리를 실행하는 중 col1이 NULL을 만나면 차선책으로 서브쿼리 테이블에 대해서 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드
- `col1 IN (SELECT col2 FROM ...)`과 같은 조건을 가진 쿼리에서 자주 발생할 수 있는데, col1의 값이 NULL이 된다면 결과적으로 조건은 NULL IN (SELECT col2 FROM ...)과 같이 바뀜
- Full scan on NULL key 코멘트가 실행 계획의 Extra 칼럼에 표시됐다고 하더라도 IN이나 NOT IN 연산자의 왼쪽에 있는 값이 실제로 NULL이 없다면 tb_test2 테이블에 대한 풀 테이블 스캔은 발생하지 않으므로 걱정하지 않아도 됨

#### 10.3.12.6 Impossible HAVING
- 쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 실행 계획의 Extra 칼럼에 표시됨

#### 10.3.12.7 Impossible WHERE
- WHERE 조건이 항상 FALSE가 될 수밖에 없는 경우 표시됨

#### 10.3.12.8 LooseScan
- 세미 조인 최적화 중에서 LooseScan 최적화 전략이 사용되면 실행 계획의 Extra 칼럼에 표시됨

#### 10.3.12.9 No matching min/max row
- MIN()이나 MAX()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 Extra 칼럼에 출력됨
- MIN()이나 MAX()의 결과로 NULL이 반환됨

#### 10.3.12.10 no matching row in const table
- const 방법으로 접근할 때 일치하는 레코드가 없을 때 표시됨

#### 10.3.12.11 No matching rows after partition pruning
- 파티션된 테이블에 대한 UPDATE 또는 DELETE 명령의 실행 계획에서 표시될 수 있는데, 해당 파티션에서 UPDATE하거나 DELETE할 대상 레코드가 없을 때 표시됨

#### 10.3.12.12 No tables used
- FROM 절이 없는 쿼리 문장이나 FROM DUAL 형태의 쿼리 실행 계획에서는 Extra 칼럼에 출력됨

#### 10.3.12.13 Not exists
- A 테이블에 존재하지만 B 테이블에 없는 값을 조회해야 하는 쿼리의 경우 일반적으로 NOT IN(subquery)이나 NOT EXISTS 등의 연산자를 사용하는 안티-조인으로 처리해야 하지만 레코드의 건수가 많을 떄는 아우터 조인을 이용하면 빠른 성능을 낼 수 있음
- 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서는 실행 계획의 Extra 칼럼에 표시됨
```sql
EXPLAIN
SELECT * FROM dept_emp de
LEFT JOIN departments d ON de.dept_no = d.dept_no
WHERE d.dept_no IS NULL;
```

#### 10.3.12.14 Plan isn't ready yet
- MySQL 8.0 버전에서는 다른 커넥션에서 실행 중인 쿼리의 실행 계획을 살펴볼 수 있음
- EXPLAIN FOR CONNECTION 명령은 MySQL 옵티마이저가 의도된 인덱스를 사용하지 못해서 풀 스캔을 한다거나 잘못된 실행 계획을 선택한 것이 아닌지 확인할 떄 유용하게 사용할 수 있는 명령
- EXPLAIN FOR CONNECTION 명령을 실행했을 때 Extra 칼럼에 Plan isn't ready yet이 표시되면 해당 커넥션에서 아직 쿼리의 실행 계획을 수립하지 못한 상태에서 EXPLAIN FOR CONNECTION 명령이 실행된 것을 의미 -> 대상 커넥션의 쿼리가 실행 계획을 수립할 여유 시간을 좀 더 주고 다시 실행

#### 10.3.12.15 Range checked for each record(index map: N)
- 레코드마다 인덱스 레인지 스캔을 체크함
- index map에 표시된 후보 인덱스를 사용할지 여부를 검토해서 이 후보 인덱스가 별로 도움이 되지 않는다면 최종적으로 풀 테이블 스캔을 사용하기 때문에 type 칼럼의 값이 ALL로 표시됨
- index map은 16진수로 표시되는데 이를 이진수로 바꾸어 각 비트맵의 자릿수가 1인 순번의 인덱스가 대상

#### 10.3.12.16 Recursive
- MySQL 8.0 버전부터는 CTE(Common Table Expression)를 이용해 재귀 쿼리를 작성할 수 있게 됨
- CTE를 이용한 재귀 쿼리의 실행 계획은 Extra 칼럼에 Recursive 구문 표시됨

#### 10.3.12.17 Rematerialize
- MySQL 8.0 버전부터는 래터럴 조인 기능이 추가됐는데, 이 경우 래터럴로 조인되는 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시 테이블에 저장함
- 이 과정을 Rematerializing이라고 함

#### 10.3.12.18 Select tables optimized away
- MIN() 또는 MAX()만 SELECT 절에 사옹되거나 GROUP BY로 MIN(), MAX()를 조회하는 쿼리가 `인덱스`를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용된다면, Extra 칼럼에 표시됨

#### 10.3.12.19 Start temporary, End temporary
- 세미 조인 최적화 중에서 Duplicate Weed-out 최적화 전략이 사용되면 표시
- Duplicate Weed-out 최적화 전략은 불필요한 중복 건을 제거하기 위해서 내부 임시 테이블을 사용하는데, 이 때 조인되어 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게 조인의 첫 번째 테이블에 Start temporary 문구를 보여주고 조인이 끝나는 부분에 End temporary 문구 표시

#### 10.3.12.20 unique row not found
- 두 개의 테이블이 각각 유니크(프라이머리 키 포함) 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 표시

#### 10.3.12.21 Using filesort
- ORDER BY 처리가 인덱스를 사용하지 못할 때만 표시
- 조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행하게 된다는 의미
- Using filesort가 출력되는 쿼리는 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋음

#### 10.3.12.22 Using index(커버링 인덱스)
- 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 표시
- 인덱스 레인지 스캔을 사용하지만 쿼리의 성능이 만족스럽지 못한 경우라면 인덱스에 있는 칼럼만 사용하도록 쿼리를 변경해 큰 성능 향상을 볼 수 있음
- InnoDB의 모든 테이블은 클러스터링 인덱스로 구성돼 있어서 모든 세컨더리 인덱스는 데이터 레코드의 주솟값으로 프라이머리 키 값을 가짐
- InnoDB 테이블에서는 다른 칼럼만으로 인덱스를 만들어도 결국 그 인덱스에 프라이머리 인덱스 칼럼도 같이 저장되는 효과를 냄 -> 클러스터링 인덱스 특성 때문에 쿼리가 커버링 인덱스로 처리될 가능성이 상당히 높음
- 접근 방법이 eq_ref, ref, range, index_merge, index 등과 같이 인덱스를 사용하는 실행 계획에서는 모두 Extra 칼럼에 Using index가 표시될 수 있음

#### 10.3.12.23 Using index condition
- 인덱스 컨디션 푸시 다운 최적화를 사용하면 표시

#### 10.3.12.24 Using index for group-by
- GROUP BY 처리에 인덱스를 이용하면 레코드의 정렬이 필요하지 않고 인덱스의 필요한 부분만 읽으면 되기 때문에 상당히 효율적이고 빠르게 처리됨
- GROUP BY 처리가 인덱스를 이용할 때 쿼리의 실행 계획에서 표시됨

##### 10.3.12.24.1 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리
- 인덱스를 이용해 GROUP BY 절을 처리할 수 있더라도 AVG(), SUM(), COUNT() 처럼 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬성듬성 읽을 수 있음
- 이러한 쿼리는 GROUP BY를 위해 인덱스를 사용하기는 하지만 루스 인덱스 스캔이라고 하지 않음
- Using index for group-by 메세지가 출력되지 않음

##### 10.3.12.24.2 루스 인덱스 스캔을 통한 GROUP BY 처리
- WHERE 조건절이 없는 경우
  - GROUP BY 절의 칼럼과 SELECT로 가져오는 칼럼이 루스 인덱스 스캔을 사용할 수 있는 조건 갖추면 됨
  - 그렇지 못하면 타이트 인덱스 스캔이나 별도의 정렬 과정을 통해 처리
- WHERE 조건절이 있지만 검색을 위해 인덱스를 사용하지 못하는 경우
  - GROUP BY 절은 인덱스를 사용할 수 있지만 WHERE 조건절이 인덱스를 사용하지 못할 때는 먼저 GROUP BY를 위해 인덱스를 읽은 후, WHERE 조건의 비교를 위해 데이터 레코드 읽어야함
  - 타이트 인덱스 스캔 과정을 통해 GROUP BY 처리됨
- WHERE 조건절의 조건이 있고 검색을 위해 인덱스를 사용하는 경우
  - WHERE 절의 조건과 GROUP BY 처리가 똑같은 인덱스를 공통으로 사용할 수 있을 때만 루스 인덱스 스캔 사용 가능

#### 10.3.12.25 Using index for skip scan
- 인덱스 스킵 스캔 최적화를 사용하면 표시됨
- MySQL 8.0 버전부터는 루스 인덱스 스캔 최적화를 확장한 인덱스 스킵 스캔 최적화가 도입

#### 10.3.12.26 Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join buffer(hash join)
- 실제로 조인에 필요한 인덱스는 조인되는 양쪽 테이블 칼럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 칼럼에만 필요
- 드리븐 테이블에 검색을 위한 적절한 인덱스가 없다면 MySQL 서버는 블록 네스티드 루프 조인이나 해시 조인을 사용
- 블록 네스티드 루프 조인이나 해시 조인을 사용하면 MySQL 서버는 조인 버퍼 사용
- 조인 버퍼가 사용되는 실행 계획의 Extra 칼럼에는 Using join buffer 메세지 표시
- MySQL 5.6 버전부터는 Using join buffer 문구에 조인 알고리즘이 추가 표시됨

#### 10.3.12.27 Using MRR(Multi Range Read)
- MySQL 엔진은 여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고 스토리지 엔진은 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화
- MRR이 도입되면서 각 스토리지 엔진은 디스크 접근을 최소화할 수 있게 됨

#### 10.3.12.28 Using sort_union(...), Using union(...), Using intersect(...)
- 쿼리가 index_merge 접근 방법으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용 가능. 이 때 Extra 칼럼에는 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 조금 더 상세하게 설명하기 위해 3개 중 하나의 메시지 선택적 출력
- Using intersect(...)
  - 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업 수행했다는 의미
- Using union(...)
  - 각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미
- Using sort_union(...)
  - Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우(OR로 연결된 상대적으로 대량의 range 조건들) 이 방식으로 처리됨
  - 프라이머리 키만 먼저 읽어서 정렬하고 병합한 이후 비로소 레코드를 읽어서 반환 가능

#### 10.3.12.29 Using temporary
- MySQL 서버에서 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용
- 임시 테이블은 메모리상에 생성될 수 있고 디스크상에 생성될 수도 있음
- Using temporary 키워드가 표시되면 임시 테이블을 사용한 것임
- Using temporary 키워드가 없어도 내부적으로 사용할 경우도 많음
  - FROM 절에 사용된 서브쿼리
  - COUNT(DISTINCT column1)를 포함하는 쿼리가 인덱스를 사용할 수 없는 경우

#### 10.3.12.30 Using where
- 각 스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할
- MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행
- MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에만 Extra 칼럼에 Using where 코멘트 표시됨

#### 10.3.12.31 Zero limit
- 쿼리의 결과가 몇 개의 칼럼을 가지고, 각 칼럼의 타입은 무엇인지 등의 정보만 필요한 경우가 있음 -> 쿼리 마지막에 `LIMIT 0` 사용
- 이 때 MySQL 옵티마이저는 사용자의 의도를 알아채고 실제 테이블의 레코드는 전혀 읽지 않고 결괏값의 메타 정보만 반환

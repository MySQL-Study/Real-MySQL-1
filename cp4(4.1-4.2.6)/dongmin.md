## 4.1 MySQL 엔진 아키텍처

![ㅂㅂㅂ](https://github.com/user-attachments/assets/a16a913b-8fd8-41a8-bfad-d74ee920d042)

MySQL은 크게 MySQL 엔진과 스토리지 엔진으로 구분함.

- 이 둘을 합쳐 그냥 MySQL 또는 MySQL 서버라고함.

### MySQL 엔진

클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룸.

### 스토리지 엔진

실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어옴.

MySQL엔진은 하나이지만 스토리지 엔진은 여러개가 될 수 있음.

```sql
CREATE TABLE test_table (fd1 INT, fd2, INT) ENGINE=INNODB;
```

- test_table에 INSERT, UPDATE, DELETE, SELECT, … 등의 작업 발생 시 InnoDB 스토리지 엔진이 담당

### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이 요청을 핸들러 요청이라 하고, 여기에 사용되는 API를 핸들러 API라고 함.

<img width="306" alt="ㅈㅈㅈ" src="https://github.com/user-attachments/assets/4f53cca2-e8ad-498f-ac9e-e832e252823d" />

- MySQL은 프로세스 기반이 아니라 스레드 기반으로 동작
- 포그라운드(Foreground) 스레드, 백그라운드(Background) 스레드로 구분

![ㄷㄷㄷ](https://github.com/user-attachments/assets/c076b300-7c82-425d-9d9b-e777d3245cf0)

<img width="791" alt="ㄱㄱㄱ" src="https://github.com/user-attachments/assets/d704e2d1-df45-46a9-9ad3-a4a9131c613d" />


- 포그라운드 스레드
    - MySQL 서버에 접속된 클라이언트의 수가 최소한의 개수
    - 주로 쿼리 문장을 처리
    - 커넥션을 종료하면 해당 스레드는 스레드 캐시로 되돌아감.
    - 데이터를 데이터 버퍼나 캐시로부터 가져옴.
        - 없는 경우, 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
    - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드에 위임.
- 백그라운드 스레드
    - InnoDB의 경우 아래 작업들이 백그라운드로 처리
        - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
        - 로그를 디스크로 기록하는 스레드
        - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
        - 데이터를 버퍼로 읽어 오는 스레드
        - 잠금이나 데드락을 모니터링하는 스레드
    - 로그 스레드(Log thread)와 쓰기 스레드(Write thread)가 가장 중요
    - 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만, 읽기 작업은 절대 지연될 수 없음.
    - 일반적으로 쓰기 작업은 버퍼링해서 일괄 처리하는 기능 탑재(InnoDB도 그러함)
    - MyISAM은 포그라운드 스레드가 쓰기 작업까지 함께 처리.

### 메모리 할당 및 사용 구조

![ㅅㅅㅅ](https://github.com/user-attachments/assets/0adc82b4-4378-4349-8058-0f6411033dd2)


- 글로벌 메모리 영역과 로컬 메모리 영역으로 구분 가능
- 글로벌 메모리 영역
    - MySQL 서버가 시작되면서 모든 메모리 공간 운영체제로부터 할당.
    - 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당.
    - 대표적으로 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼
- 로컬 메모리 영역(세션 메모리 영역)
    - 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용
    - 클라이언트가 MySQL 서버에 접속시 MySQL 서버에서는 클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드 할당.
    - 스레드별로 독리적으로 할당, 공유되어 사용되지 않음.
    - 메모리 공간을 신경 쓰지 않고 설정되므로, 적절한 메모리 공간을 설정하는 것이 중요.
    - 대표적으로 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼


### 플러그인 스토리지 엔진 모델
![ㅛㅛㅛ](https://github.com/user-attachments/assets/597e5bd1-f789-4594-ad8a-1f3dc95ea5e7)


- 검색어 파서, 사용자 인증을 위한 Native Authentication, Cache SHA-2 Authentication 등도 모두 플러그인으로 구현되어 제공
- 쿼리는 대부분의 작업이 MySQL 엔진에서 처리되고, 마지막 데이터 읽기/쓰기 작업만 스토리지 엔진에서 처리
- 복잡한 연산인 GROUP BY나 ORDER BY 등의 처리는 MySQL 엔진의 처리 영역이 쿼리 실행기에서 처리.
- 중요한것은 MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다는 것임.

### 컴포넌트

플러그인의 단점

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음.
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움.

MySQL 8.0 버전부터는 비밀번호 검증 기능이 컴포넌트로 변경되었음.

### 쿼리 실행 구조

![ㅕㅕㅕ](https://github.com/user-attachments/assets/54197665-d706-4e95-be04-0dd5f1bab56b)


- 쿼리 파서
    - 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어냄.
    - 기본 문법 오류는 이 과정에서 발견 → 사용자에게 오류 메시지 전달
- 전처리기
    - 파서 과정에서 만들어진 파서 트리를 기반으로 구조적인 문제가 있는지 확인.
    - 각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 객체의 존재 여부와 객체의 접근 권한 등을 확인 하는 과정 수행
- 옵티마이저
    - 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할.
    - DBMS의 두뇌로, 해당 책의 내용은 대부분 옵치마이저가 선택하는 내용을 설명할정도로 중요하고 영향범위가 넓음.
- 실행 엔진
    - 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발
    - 예를 들어, 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 한다면,
        - 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
        - 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
        - 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
        - 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
    - 즉, 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행
- 핸들러
    - MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할 ⇒ 결국 스토리지 엔진을 의미

### 쿼리 캐시

- 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할
- SQL 실행 결과를 메모리에 캐시 ⇒ 동일 SQL 실행 시 테이블을 읽지 않고 즉시 결과를 반환.
- 테이블의 데이터가 변경 시 캐시에 저장된 결과 중 관련 데이터는 모두 삭제 ⇒ 동시 처리 성능 저하.
- MySQL 8.0 에서는 완전히 제거. 관련 시스템 변수도 모두 제거.

### 스레드 풀

- 엔터프라이즈 에디션은 스레드 풀 기능을 제공하지만, 커뮤니티 에디션은 지원하지 않음.
- Percona Server에서 제공하는 스레드 풀 기능을 기준으로 설명
- 커뮤니티 에디션에서 스레드 풀 기능을 사용하고자 한다면, 동일 버전의 Percona Server에서 스레드 풀 플러그인 라이브러리를 MySQL 에디션 서버에 설치해서 사용.
- 스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여, 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적.
- 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드물다.
- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단.
- 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공.

### 트랜잭션 지원 메타데이터

- 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 `데이터 딕셔너리` 또는 `메타데이터`라고 함.
- MySQL 5.7 까지는 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리

  ⇒ 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 있었음.

- MySQL 8.0 버전부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선.
- 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장하고 있음.
- mysql DB는 통쨰로 mysql.ibd라는 이름의 테이블스페이스에 저정됨
    - *.ibd 파일과 함께 특별히 주의해야함.

## 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용 가능한 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공함.

⇒ 높은 동시성 처리 가능, 안정적, 성능 뛰어남.

![ㅑㅑㅑ](https://github.com/user-attachments/assets/c74fa9d1-323a-4417-9ef2-33e53dad7da8)


### 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 있음.
    - 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻.
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용.
    - 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있음.
- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않음.
    - 프라이머리 키와 세컨더리 인덱스는 구조적으로 별 차이 없음.
    - 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐임.
    - 모든 인덱스는 물리적인 레코드의 주소값을 가짐.

### 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원 ⇒ MyISAM이나 MEMORY 테이블에서는 사용 할 수 없음!
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요
- 변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업 필요. ⇒ 잠금이 여러 테이블로 전파되고, 그로 인해 데드락 발생할 때가 많음.

### MVCC

- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있음.
- InnoDB는 언두 로그를 이용해 이 기능을 구현함.
- READ COMMITED 상태인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터를 어떻게 변경하는지를 보자.
- UPDATE문이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값인 ‘경기’로 업데이트된다.

![ㅐㅐㅐ](https://github.com/user-attachments/assets/e5c70b01-530d-4238-9cca-d24cf62af39b)


- InnoDB는 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방함.
- 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 없데이트돼 있을 수도 있고 아닐 수도 있다
- MySQL 서버의 시스템 변수에 설정된 격리 수준에 따라 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 쿼리롤 작업 중인 레코드를 조회했을 때 어디 데이터를 조회할지가 달라진다.
- READ_UNCOMMITTED인 경우에는 InnoDB의 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환.
- READ_COMMITTED나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우에는 아직 커밋되지 않았기 떄문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환함.

⇒ 이러한 과정을 MVCC라고 표현함.

- 즉, 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조임.

### 잠금 없는 일관된 읽기

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행함.
- 잠금을 걸지 않아 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업ㅇ 가능.
- 격리 수준이 SERIALIZABLE이 아니면 INSERT와 연결되지 않은 순수한 SELECT 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

  ⇒ 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- 오랜 시간 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있음.
- 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기때문에 발생 ⇒ 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋음.

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태(Wait-for List)로 관리함.
    - 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료.
    - 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상이 됨.
- 일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사개헛 데드락을 찾아내는 작업은 크게 부담되지 않음.
- 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐.
    - 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못해 대기하면서 서비스에 악영향.
    - innodb_deadlock_detect 시스템 변수의 값을 OFF로 설정해 해당 스레드를 꺼버리면됨.

      ⇒ 데드락이 발생하면 무한 대기에 놓임

        - innodb_lock_wait_timeout 시스템 변수의 값을 수정해 잠금을 획득하지 못한 트랜잭션을 일정 시간 후에 종료시키는 방법 사용

### 자동화된 장애 복구

- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재되어 있음.
    - MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행됨.
- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않음.
- MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 자동으로 복구를 못 하는 경우가 발생할 수 있음.
    - 한번 문제가 생기면 복구하기가 쉽지 않음.
    - InnoDB 데이터 파일은 MySQL 서버가 시작될 때 항상 자동 복구를 수행하지만, 자동으로 복구될 수 없는 손상이 있다면 MySQL 서버는 종료되 버림.
    - innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 해야함.

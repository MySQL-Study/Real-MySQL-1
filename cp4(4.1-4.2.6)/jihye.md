# CHAPTER4. 아키텍처

## 4.1 MySQL 엔진 아키텍처
- MySQL 서버는 사람의 머리 역할을 담당하는 MySQL 엔진과 손발 역할을 담당하는 스토리지 엔진으로 구분
<img src=https://github.com/user-attachments/assets/344453da-78f1-4062-a977-49e5b2c88632 width=600>

출처: https://amenable.tistory.com/145

### MySQL 엔진
  - 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룸
  - 요청된 SQL 문장을 분석하거나 최적화
### 스토리지 엔진
  - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분 담당
  - 여러 개를 동시에 사용 가능(테이블마다 설정 가능)
    - `CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;`
  - 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장
### 핸들러 API
  - MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데 이러한 요청을 핸들러 요청
  - 여기서 사용되는 API를 핸들러 API
  - `SHOW GLOBAL STATUS LIKE 'Handler%';`
### MySQL 스레딩 구조

  <img src=https://github.com/user-attachments/assets/1e2863c9-58ff-4d3b-8112-8ed5f270a90a width=600>

출처: https://infoqoch.github.io/mysql/mysql-engine-architecture.html
  - MySQL 서버는 스레드 기반으로 작동
#### 포그라운드 스레드(클라이언트 스레드)
- 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재
- 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 커넥션 종료 후 최대 스레드 개수 이상의 대기 중인 스레드가 있다면 스레드 캐시에 넣지 않고 스레드를 종료
- 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오거나 없다면 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어옴
- MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리
#### 백그라운드 스레드
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드
- 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다
  - MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용 불가
### 메모리 할당 및 사용 구조
#### 글로벌 메모리 영역
- 하나의 메모리 공간만 할당(2개 이상도 가능)
- 모든 스레드에 의해 공유
- 예) 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑터블 해시 인덱스, InnoDB 리두 로그 버퍼
#### 로컬 메모리 영역
- 세션 메모리 영역
- MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
- 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않음
- 예) 조인 버퍼, 정렬 버퍼, 네트워크 버퍼, 리드 버퍼
### 플러그인 스토리지 엔진 모델
- MySQL에서 쿼리가 실행되는 과정을 크게 나눈다면 대부분의 작업이 MySQL 엔진에서 처리되고 마지막 데이터 읽기/쓰기 작업만 스토리지 엔진에 의해 처리
- 실질적인 GROUP BY나 ORDER BY 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 '쿼리 실행기'에서 처리
#### 컴포넌트
- MySQL 8.0부터 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원
  - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고 플러그인끼리는 통신 불가
  - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 불안전(캡슐화 X)
- MySQL 8.0부터 비밀번호 검증 기능은 컴포넌트로 개선
- 설치된 컴포넌트 확인
  - `SELECT * FROM mysql.component;`
### 쿼리 실행 구조
#### 쿼리 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
- 기본 문법 오류 판별
#### 전처리기
- 쿼리 문장에 구조적인 문제점 있는지 확인
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토믄 판별
#### 옵티마이저
- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정
#### 실행 엔진
- 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
#### 핸들러(스토리지 엔진)
- MySQL 서버의 가장 및단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할
#### 쿼리 캐시
- MySQL 8.0부터 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거되고 관련된 시스템 변수도 모두 제거
  - 계속된 동시 처리 성능 저하와 많은 버그의 원인
#### 스레드 풀
- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
- MySQL 커뮤니티 에디션은 스레드 풀 기능을 지원 X
- Percona Server 스레드 풀
  - 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성
  - 선수위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능 제공
#### 트랜잭션 지원 메타데이터
- MySQL 서버는 5.7버전까지 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리
  - 이러한 파일 기반의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 비정상적으로 서버가 종료되면 일관되지 않은 상태로 남는 문제 발생
- MySQL 8.0 버전
  - 데이터 딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선
  - mysql.ibd라는 이름의 테이블스페이스에 저장
  - InnoDB 테이블 이외의 테이블들에 대해서는 SDI 포맷의 *.sdi 파일 존재
 
## 4.2 InnoDB 스토리지 엔진 아키텍처
- 레코드 기반의 잠금을 제공
  - 높은 동시성 처리 가능
  - 안정적
#### 프라이머리 키에 의한 클러스터링
- 프라이머리 키 = 클러스터링 인덱스
- 프라이머리 키 값의 순서대로 디스크에 저장
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용
#### 외래 키 지원
- InnoDB 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서 사용 불가
- `SET SESSION foreign_key_checks=OFF;` -> SESSION은 생략 가능
#### MVCC(Multi Version Concurrency Control)
- 잠금을 사용하지 않는 일관된 읽기를 제공
- 언두 로그를 이용해 이 기능 구현
- UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼 풀은 새로운 값으로 변경
- 이 때 변경된 레코드를 조회하면 격리 수준에 따라 데이터 조회 위치가 달라짐
  - READ UNCOMMITTED
    - InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환
  - READ_COMMITTED 또는 그 이상의 격리 수준
    - 언두 영역의 데이터 반환
- COMMIT
  - 지금의 상태를 영구적인 데이터로 만듦
- ROLLBACK
  - 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고 언두 영역의 내용을 삭제 
#### 잠금 없는 일관된 읽기
- MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업 수행
#### 자동 데드락 감지
- 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 언두 로그 레코드를 더 적게 가진 하나를 강제 종료
- innodb_table_locks 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지 가능
- 동시 처리 스레드가 매우 많거나 각 트랜잭션이 가진 잠금의 개수가 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원 소모 가능
  - innodb_deadlock_detect를 OFF로 설정 후 innodb_lock_wait_timeout 시스템 변수를 50초보다 훨씬 낮은 시간으로 변경하여 활성화하면 자동 데드락 감지 비활성화를 해도 에러를 반환하여 데드락 방지
  - **PK 또는 세컨더리 인덱스를 기반으로 매우 높은 동시성 처리를 요구하는 서비스가 있다면 innodb_dead_lock_detect를 비활성화해서 성능 비교해보기!**
#### 자동화된 장애 복구
- 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘 탑재
- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 떄 항상 자동 복구 수행
- 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버 종료
- 이 때는 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버 시작
  - 1(SRV_FORCE_IGNORE_CORRUPT)
    - InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 서버 시작
  - 2(SRV_FORCE_NO_BACKGROUND)
    - 백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 서버 시작
  - 3(SRV_FORCE_NO_TRX_UNDO)
    - 커밋되지 않은 트랜잭션의 작업을 롤백하지 않고 그대로 놔둔 채 서버 시작
  - 4(SRV_FORCE_IBUF_MERGE)
    - 엔진이 인서트 버퍼의 내용을 무시하고 강제로 서버 시작
  - 5(SRV_FORCE_NO_UNDO_LOG_SCAN)
    - 언두 로그 모두 무시하고 서버 시작
  - 6(SRV_FORCE_NO_LOG_REDO)
    - 리두 로그를 모두 무시한 채로 서버 시작

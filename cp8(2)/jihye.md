## 8.4 R-Tree 인덱스
- 공간 인덱스: R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
- B-Tree와 내부 메커니즘은 흡사하지만 B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라 값인 반면 R-Tree 인덱스는 2차원의 공간 개념 값
#### 구조 및 특성
- MBR(Mininum Bounding Rectangle): 해당 도형을 감싸는 최소 크기의 사각형
- R-Tree 인덱스: 이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스

#### R-Tree 인덱스의 용도
- MBR 정보를 이용해 B-Tree 형태로 인덱스를 구축
- WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용됨
- 도형의 포함관계를 이용해 만들어진 인덱스기 떄문에 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스 이용 가능

## 8.5 전문 검색 인덱스
- InnoDB나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없음

#### 인덱스 알고리즘
- 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스 구축

###### 어근 분석 알고리즘
- MySQL 서버의 전문 검색 인덱스는 `불용어 처리`(별 가치 없느 단어를 모두 필터링해서 제거), `어근 분석`(검색어로 선정된 단어의 뿌리인 원형을 찾는 작업)의 과정을 거쳐서 색인 작업이 수행
- MySQL 서버에서는 오픈소스 형태소 분석 라이브러리인 MeCab을 플러그인 형태로 사용할 수 있게 지원
- MeCab을 MySQL 서버에 적용하는 방법은 어렵지 않지만 한글에 맞게 완성도를 갖추는 작업은 많은 시간과 노력이 필요

###### n-gram 알고리즘
- 형태소 분석이 문장을 이해하는 알고리즘이라면, n-gram 알고리즘은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘
- n-gram이란 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법
- 형태소 분석보다는 알고리즘이 단순하고 국가별 언어에 대한 이해와 준비 작업이 필요 없는 반면, 만들어진 인덱스의 크기는 상당히 큰 편
- n으로 생성된 토큰들에 대해 불용어를 걸러내는 작업을 수행 -> 불용어와 동일하거나 불용어를 포함하는 경우 걸러서 버림
- MySQL 서버는 이렇게 구분된 토큰을 단순한 B-Tree 인덱스에 저장

###### 불용어 변경 및 삭제
- "ti"에 "a"와 "i" 철자가 불용어로 등록돼 있어 걸러질 수 있음
- 따라서 불용어 처리 자체를 완전히 무시하거나 MySQL 서버에 내장된 불용어 대신 사용자가 직접 불용어를 등록하는 방법 권장

#### 전문 검색 인덱스의 가용성
- 전문 검색 인덱스를 사용하려면 반드시 다음 두 가지 조건을 갖춰야 함
  - 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST ...)을 사용
  - 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

## 8.6 함수 기반 인덱스
- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때도 있는데, 이러한 경우 함수 기반의 인덱스를 활용하면 됨
  - 가상 칼럼을 이용한 인덱스
  - 함수를 이용한 인덱스
 
#### 가상 칼럼을 이용한 인덱스
```
ALTER TABLE user
ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL
ADD INDEX ix_fullname (full_name);
```

#### 함수를 이용한 인덱스
```
CREATE TABLE user (
user_id BIGINT,
first_name VARCHAR(10),
last_name VARCHAR(10),
PRIMARY KEY (user_id),
INDEX ix_fullname ((CONCAT(first_name, ' ', last_name)))
);
```
- 함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결곽값의 검색을 빠르게 만들어줌

## 8.7 멀티 밸류 인덱스
- 전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가짐
- 멀티 밸류 인덱스: 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스
- MySQL 8.0 버전으로 업그레이드되면서 MySQL 서버의 JSON 관리 기능을 이제 태생적으로 JSON을 사용했던 MongoDB에 비해서도 부족함이 없는 상태
```
CREATE TABLE user (
user_id BIGINT AUTO_INCREMENT PRIMARY_KEY,
credit_info JSON,
INDEX mx_creditscores ( (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)) )
);
```
- `MEMBER OF()`, `JSON_CONTAINS()`, `JSON_OVERLAPS()` 이 함수들을 이용해서 검색해야 인덱스를 활용한 실행 계획 수립

## 8.8 클러스터링 인덱스
- 여러 개를 하나로 묶는다는 의미로 주요 사용
- InnoDB 스토리지 엔진에서만 지원

#### 클러스터링 인덱스
- 테이블의 프라이머리 키에 대해서만 적용되는 내용
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 함
- InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느림
- 프라이머리 키가 없는 InnoDB 테이블의 경우
  - 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
  - NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
  - 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 클러스터링 키로 선택
 
#### 세컨더리 인덱스에 미치는 영향


## 8.9 유니크 인덱스
- 제약 조건에 가까움
- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미

#### 유니크 인덱스와 일반 세컨더리 인덱스의 비교
- 인덱스의 구조상 아무런 차이점이 없음
- CPU에서 칼럼값을 비교하는 작업을 세컨더리 인덱스에서 한 번 더함으로 성능상 영향이 거의 없음
- 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미
- 유니크 인덱스는 키 값을 쓸 때 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요해서 세컨더리 인덱스의 쓰기보다 느림

#### 유니크 인덱스 사용 시 주의사항
- 꼭 필요한 경우라면 유니크 인덱스를 생성해야 하지만 더 성능이 좋아질 것으로 생각하고 불필요하게 생성하지는 않는 것이 좋음
- 유니크 인덱스는 일반 세컨더리 인덱스와 같은 역할을 동일하게 수행할 수 있으므로 중복으로 만들 필요 없음 

## 8.10 외래키
- InnoDB 스토리지 엔진에서만 생성 가능
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성됨
- 테이블의 변경이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음

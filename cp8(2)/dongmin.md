## 8.4 R-Tree 인덱스

R-Tree 인덱스는 **2차원 공간 개념의 값**을 인덱싱하는 방식으로, 공간 데이터를 보다 효율적으로 저장하고 검색할 수 있도록 도와줍니다. 특히 MySQL의 공간 확장 기능과 관련하여 중요한 역할을 하며, 다음과 같은 세 가지 주요 기능이 포함되어 있습니다.

1. **공간 데이터를 저장할 수 있는 데이터 타입**
2. **공간 데이터의 검색을 위한 공간 인덱스 (R-Tree 알고리즘)**
3. **공간 데이터의 연산 함수 (거리 또는 포함 관계의 처리)**

### 1. 구조 및 특성

R-Tree 인덱스는 공간 데이터(Spatial Data)를 다룰 때 사용되며, 대표적으로 다음과 같은 데이터 타입을 지원합니다.

- **Point**: 단일 좌표 값
- **Line**: 여러 좌표를 연결한 선
- **Polygon**: 다각형을 나타내는 데이터
- **Geometry**: 위의 타입을 포함하는 **슈퍼 타입**으로, 모든 공간 데이터를 저장할 수 있습니다.

이러한 데이터 타입을 활용하여 **위치 기반 검색**이나 **범위 기반 검색**을 수행할 수 있습니다.

### 2. MBR (Minimum Bounding Rectangle) 개념

R-Tree 알고리즘을 이해하기 위해서는 **MBR(Minimum Bounding Rectangle, 최소 경계 사각형)** 개념이 필요합니다.

MBR은 **도형을 감싸는 최소 크기의 사각형**을 의미하며, R-Tree는 이 MBR 정보를 바탕으로 트리를 구성합니다.

예를 들어, `[5-20]` 범위에 해당하는 공간 데이터가 있다고 가정하면, 이 데이터를 R-Tree 인덱스 구조로 나누면, 다음과 같이 **3개의 MBR 레벨**로 구성할 수 있습니다.

1. **최상위 노드(R1, R2)**
2. **중간 레벨 노드**
3. **최하위 노드(R7 ~ R14, 개별 요소 저장)**

이처럼 R-Tree는 **각 객체의 MBR을 저장하는 방식으로 공간 인덱스를 구축**하며, 최하위 객체들은 **리프 노드**에 저장됩니다.

### 3. R-Tree 인덱스의 용도

### ① R-Tree란?

R-Tree 인덱스는 **MBR 정보를 이용하여 B-Tree 형태로 구축**되기 때문에, 공간 인덱스(Spatial Index)라고도 불립니다.

R-Tree는 **각 도형의 포함 관계를 이용하여 만들어진 인덱스**이며, 이러한 포함 관계를 비교하는 함수들을 활용하여 검색할 수 있습니다.

### ② R-Tree의 활용 예시

R-Tree 인덱스는 다음과 같은 경우에 유용하게 활용됩니다.

- 사용자의 현재 위치로부터 **반경 5KM 이내의 음식점 검색**
- 특정 지역 내 **건물, 도로, 공원 등의 공간 데이터 조회**
- GIS(지리정보 시스템)에서 공간 객체 간의 관계 분석

이처럼 R-Tree 인덱스는 **위치 기반 검색(Location-Based Search)** 및 **공간 분석**을 수행하는 데 적합합니다.

# 8.5 전문 검색 인덱스

MySQL의 **B-Tree 인덱스**는 일반적인 데이터 검색에는 유용하지만, 전문 검색(Full-Text Search, FTS)에는 적합하지 않습니다.

그 이유는 다음과 같습니다.

- B-Tree 인덱스는 칼럼 값이 **1MB** 이상이어도 MyISAM(최대 1,000바이트) 또는 InnoDB(최대 3,072바이트)까지만 잘라서 인덱스로 사용합니다.
- **전체 일치(=)** 또는 **좌측 일부 일치(LIKE 'abc%')** 같은 검색만 가능합니다.
- 전문 검색(Full-Text Search)이란, **문서의 내용을 전체적으로 분석하여 특정 키워드가 포함된 문서를 검색하는 방식입니다**. 일반적인 B-Tree 인덱스로는 이러한 작업을 수행하기 어렵기 때문에, **전문 검색을 위한 별도의 인덱싱 기법**이 필요합니다.

---

## 1. 인덱스 알고리즘

전문 검색 인덱스는 문서의 **키워드를 분석**하여 빠른 검색을 수행할 수 있도록 **전용 인덱스**를 구축하는 방식입니다. 이를 위해 다음과 같은 **두 가지 주요 처리 과정**이 존재합니다.

### ① 불용어(Stop Word) 처리

- 불용어(Stop Word)란, 검색에서 큰 의미가 없는 단어를 의미합니다.

예를 들어 **"the", "is", "and"** 같은 단어들은 검색의 핵심이 아니므로 필터링하여 제거합니다.

- 불용어는 미리 정의된 리스트로 관리되거나, 데이터베이스에서 직접 설정할 수도 있습니다.
- 검색 성능을 최적화하기 위해 의미 없는 단어들을 제거하여 **인덱스 크기를 줄이고 검색 속도를 향상**시킵니다.

### ② 어근 분석(Stemming)

- 어근 분석(Stemming)이란, **검색어의 원형(root word)을 찾아내는 과정입니다**.

예를 들어,

- "running" → "run"
- "studies" → "study"
- "better" → "good"

이처럼 단어의 형태가 변하더라도 **원형을 기준으로 검색**할 수 있도록 변환합니다.

MySQL에서는 **MeCab**과 같은 **오픈소스 형태소 분석기**를 플러그인으로 사용할 수 있습니다.

---

## 2. n-gram 알고리즘

### ✅ n-gram이란?

**n-gram** 알고리즘은 **본문을 특정 길이(n)만큼 잘라서 인덱싱**하는 방식입니다.

- 형태소 분석보다 **알고리즘이 단순합니다**.
- **인덱스 크기가 커지는 단점**이 있습니다.
- **n은 최소 글자수**를 의미하며, 일반적으로 **2-gram**이 많이 사용됩니다..

### ✅ 2-gram 예제

다음 문장을 2-gram 알고리즘으로 변환하면

> To be or not to be. That is the question.
>

### ① 띄어쓰기와 마침표를 기준으로 단어 분리

- "To", "be", "or", "not", "to", "be", "That", "is", "the", "question" → 총 10개 단어

### ② 2-gram 적용 (두 글자씩 중첩 분리)

- "To" → "To"
- "be" → "be"
- "or" → "or"
- "not" → "no", "ot"
- "to" → "to"
- "be" → "be"
- "That" → "Th", "ha", "at"
- "is" → "is"
- "the" → "th", "he"
- "question" → "qu", "ue", "es", "st", "ti", "io", "on"

### ③ 최종 토큰 목록

> To, be, or, no, ot, to, be, Th, ha, at, is, th, he, qu, ue, es, st, ti, io, on
>

이렇게 **n-gram 방식으로 분할된 토큰을 인덱스로 저장**하면 검색이 가능해집니다.

---

## 3. 불용어 처리 및 최종 인덱스 생성

MySQL은 **불용어(Stop Word)를 자동으로 걸러내고**, **중복된 토큰을 제거**한 후 최종적으로 인덱스를 생성합니다.

- 기본적으로 **MySQL은 자체적으로 불용어 목록을 관리합니다**.
- 필요하면 **사용자가 직접 불용어를 추가 및 수정할 수 있습니다.**

이 과정을 거쳐 최적화된 전문 검색 인덱스가 만들어집니다.

---

## 4. 전문 검색 인덱스 사용 조건

MySQL에서 **전문 검색 인덱스**를 사용하려면 **다음 두 가지 조건을 충족해야 합니다.**

1. **쿼리가 전문 검색 문법을 사용해야 합니다.**
    - `MATCH (칼럼명) AGAINST ('검색어')`
2. **해당 칼럼이 전문 검색 인덱스를 보유해야 합니다.**
    - `FULLTEXT` 인덱스를 생성해야 합니다.

### ✅ 전문 검색 인덱스 예제

```sql
sql
복사편집
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    FULLTEXT(title, content)  -- 전문 검색 인덱스 생성
);

```

위와 같이 **FULLTEXT 인덱스를 생성**한 후, `MATCH ... AGAINST` 문법을 사용하여 검색할 수 있습니다.

```sql
sql
복사편집
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('MySQL 검색');

```

이렇게 하면 **"MySQL 검색"이 포함된 문서를 빠르게 찾을 수 있습니다.**

# 8.6 함수 기반 인덱스

데이터를 검색할 때, **칼럼의 값을 변형해서 검색해야 하는 경우**가 있습니다. 예를 들어, **이름(first_name)과 성(last_name)을 합쳐서 검색해야 하는 경우**가 대표적입니다.

이런 경우 함수 기반 인덱스(Function-Based Index, FBI)를 활용하면 검색 성능을 향상시킬 수 있습니다.

함수 기반 인덱스를 구현하는 방법은 **두 가지**로 나뉩니다.

1. **가상 칼럼(Virtual Column)을 이용한 인덱스**
2. **함수를 이용한 인덱스**

두 방식 모두 **B-Tree 인덱스의 내부 구조 및 유지 관리 방식과 동일합니다**.

---

### 1. 가상 칼럼을 이용한 인덱스

가상 칼럼은 실제로 테이블에 존재하는 것처럼 보이지만, **실제로는 기존 칼럼을 조합하여 계산된 값**을 저장하는 개념입니다.

예를 들어, `first_name`과 `last_name`을 합쳐서 `full_name`이라는 **가상 칼럼**을 만들고 인덱스를 생성할 수 있습니다.

```sql
sql
복사편집
ALTER TABLE users ADD COLUMN full_name VARCHAR(255)
    AS (CONCAT(first_name, ' ', last_name)) VIRTUAL;

CREATE INDEX idx_full_name ON users(full_name);

```

가상 칼럼을 추가하면 **테이블 구조가 변경되며**, 해당 칼럼에 인덱스를 추가할 수 있습니다.

---

### 2. 함수를 이용한 인덱스

테이블 구조를 변경하지 않고, 특정 함수를 적용한 값을 인덱스로 만들 수도 있습니다.

```sql
sql
복사편집
CREATE INDEX idx_lower_email ON users(LOWER(email));

```

이렇게 하면 `LOWER(email)`을 활용한 검색이 훨씬 빨라집니다.

하지만 **주의할 점**이 있습니다.

> 쿼리에서 인덱스에 사용된 함수 표현식을 정확히 사용해야 합니다.
>

예를 들어, 위와 같이 `LOWER(email)`에 인덱스를 만들었을 경우, 검색 시에도 `LOWER(email)`을 그대로 사용해야 인덱스를 활용할 수 있습니다.

```sql
sql
복사편집
SELECT * FROM users WHERE LOWER(email) = 'example@gmail.com';  -- 인덱스 사용 가능
SELECT * FROM users WHERE email = 'example@gmail.com';  -- 인덱스 사용 불가

```

**표현식이 조금이라도 다르면 MySQL 옵티마이저가 함수 기반 인덱스를 사용할 수 없습니다.**

---

# 8.7 멀티 밸류 인덱스

일반적인 인덱스에서는 **한 레코드(행)가 하나의 인덱스 키 값을 가집니다.** 하지만, 멀티 밸류 인덱스(Multi-Valued Index, MVI)는 **하나의 레코드가 여러 개의 인덱스 키 값을 가질 수 있는 특별한 형태입니다**.

### 1. 멀티 밸류 인덱스란?

- **일반적으로 정규화에 위배되는 형태입니다**.
- 하지만 **JSON 데이터 타입을 지원**하면서, **JSON 필드 내부의 원소들을 인덱싱해야 하는 요구사항**이 생겼습니다.
- 이를 해결하기 위해 **MongoDB**에서 지원하던 형태의 멀티 밸류 인덱스가 MySQL에서도 도입되었습니다.

---

### 2. 멀티 밸류 인덱스 사용 방법

멀티 밸류 인덱스를 활용하기 위해서는 **일반적인 WHERE 조건이 아닌, 특정 함수들을 사용해야 합니다.**

### ✅ 멀티 밸류 인덱스를 활용하는 함수

- **`MEMBER OF()`**
- **`JSON_CONTAINS()`**
- **`JSON_OVERLAPS()`**

### ✅ 예제

```sql
sql
복사편집
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    tags JSON,
    INDEX idx_tags (tags) VISIBLE
);

```

위와 같이 JSON 타입의 `tags` 필드를 인덱스로 설정한 후, 다음과 같이 검색할 수 있습니다.

```sql
sql
복사편집
SELECT * FROM products WHERE 'electronics' MEMBER OF(tags);

```

위처럼 검색해야만 **멀티 밸류 인덱스를 활용한 최적화된 실행 계획이 수립됩니다.**

---

# 8.8 클러스터링 인덱스

### 1. 클러스터링이란?

클러스터링(Clustering)은 **테이블의 레코드를 비슷한 값들끼리 묶어서 저장하는 방식입니다**.

이는 보통 **비슷한 값을 동시에 조회하는 경우가 많기 때문에 성능 최적화의 목적**으로 사용됩니다.

### 2. 클러스터링 인덱스의 특징

- 일반적으로 **프라이머리 키(Primary Key)에 적용됩니다**.
- **프라이머리 키 값이 레코드의 저장 위치를 결정합니다**.
- **프라이머리 키가 변경되면, 레코드의 물리적 저장 위치도 변경**되어야 합니다.
- **테이블 자체가 하나의 인덱스 구조로 관리됩니다**.

---

### 3. 프라이머리 키가 없는 경우 클러스터링 인덱스 구성

프라이머리 키가 없는 경우, MySQL은 자동으로 클러스터링 키(Clustering Key)를 선택합니다.

1. **프라이머리 키가 있으면, 프라이머리 키를 클러스터링 키로 사용**
2. **프라이머리 키가 없고, `NOT NULL` 옵션이 있는 유니크 인덱스가 있으면 해당 인덱스를 사용**
3. **위 조건이 없으면, 내부적으로 자동 증가되는 유니크한 칼럼을 추가하여 사용**

---

### 4. 세컨더리 인덱스와의 관계

- 일반적으로 **세컨더리 인덱스는 레코드의 주소값을 저장합니다**.
- 하지만, **클러스터링 인덱스를 사용하는 경우 세컨더리 인덱스에는 프라이머리 키 값이 저장됩니다**.
- 즉, **프라이머리 키 값이 변경될 경우, 모든 세컨더리 인덱스도 업데이트해야 하는 문제**가 있습니다.

---

### 5. 클러스터링 인덱스의 장점과 단점

### ✅ 장점

✔ **프라이머리 키를 이용한 검색 속도가 매우 빠릅니다.**

✔ **세컨더리 인덱스가 프라이머리 키를 저장하므로, 인덱스만으로 처리할 수 있는 경우가 많습니다.**

### ❌ 단점

✖ **프라이머리 키 크기가 클 경우, 전체적인 인덱스 크기가 증가합니다.**

✖ **세컨더리 인덱스 검색 시, 추가적인 프라이머리 키 조회가 필요합니다.**

✖ **INSERT 시, 프라이머리 키 값에 따라 저장 위치가 결정되므로 속도가 느릴 수 있습니다.**

✖ **프라이머리 키 변경 시, 레코드를 삭제하고 다시 삽입해야 하므로 성능 저하가 발생할 수 있습니다.**

# 8.9 유니크 인덱스

유니크 인덱스(Unique Index)는 **인덱스라기보다 제약 조건(Constraint)에 가까운 기능**입니다.

즉, **테이블이나 인덱스에 동일한 값이 2개 이상 저장되지 않도록 보장**하는 역할을 합니다.

### 1. 유니크 인덱스의 특징

- 데이터를 **읽을 때에는 일반 인덱스와 성능 차이가 거의 없습니다.**→ 이유: 디스크가 아니라 **CPU에서 칼럼 값을 비교**하기 때문입니다.
- 데이터를 **저장하거나 수정할 때에는 중복 여부를 체크하는 과정이 추가됩니다.**→ 이 과정에서 **데드락(Deadlock)이 빈번하게 발생**할 수 있습니다.

### 2. 유니크 인덱스의 장점

✔ **데이터 무결성(Data Integrity)을 보장**할 수 있습니다.

✔ 중복 데이터가 저장되지 않으므로 **데이터 품질이 향상**됩니다.

✔ **검색 성능이 일반적인 B-Tree 인덱스와 동일**합니다.

### 3. 유니크 인덱스의 단점

✖ **INSERT 또는 UPDATE 시 중복 체크를 위한 추가적인 연산이 필요**합니다.

✖ 다중 트랜잭션 환경에서 **데드락 발생 가능성이 증가**합니다.

✖ **유니크 인덱스가 설정된 칼럼은 자주 변경하는 것이 바람직하지 않습니다.**

### 4. 유니크 인덱스 생성 예제

```sql
sql
복사편집
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) NOT NULL,
    UNIQUE (email)  -- 유니크 인덱스 설정
);

```

위와 같이 설정하면 `email` 칼럼에 **중복된 값이 저장될 수 없습니다.**

---

# 8.10 외래키

외래키(Foreign Key)는 **두 테이블 간의 관계를 정의하는 제약 조건**입니다.

외래키는 **오직 InnoDB 스토리지 엔진에서만 생성**할 수 있으며, 자동으로 **연관된 테이블의 칼럼에 인덱스가 생성**됩니다.

### 1. 외래키의 주요 특징

- **부모(Parent) 테이블과 자식(Child) 테이블 간의 관계를 유지**합니다.
- **참조 무결성(Referential Integrity)을 보장**합니다.
- 외래키가 설정된 경우, **부모 테이블의 레코드를 삭제할 때 자식 테이블도 함께 영향을 받습니다.**

### 2. InnoDB의 외래키 관리

InnoDB에서는 **외래키를 사용할 때 중요한 두 가지 특징**이 있습니다.

1. **테이블 변경이 발생하면 잠금 경합(Lock Contention)이 발생**할 수 있습니다.
2. **외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 방지**합니다.

---

### 3. 외래키와 잠금 대기(Lock Wait)

### ✅ 자식 테이블을 변경할 때

- **부모 테이블의 해당 레코드가 쓰기 잠금(Write Lock)이 걸려 있다면, 자식 테이블도 잠금 대기를 해야 합니다.**

### ✅ 부모 테이블에서 레코드를 삭제할 때

- **부모 테이블에서 특정 레코드를 삭제할 경우, 해당 레코드를 참조하는 자식 테이블의 레코드도 삭제해야 합니다.**
- 하지만 **자식 테이블의 레코드가 이미 잠금이 걸려 있다면, 부모 테이블의 삭제 작업도 대기해야 합니다.**

이러한 이유로, **외래키가 설정된 테이블에서는 트랜잭션 처리 순서와 잠금 관리가 매우 중요합니다.**

---

### 4. 외래키 설정 예제

```sql
sql
복사편집
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

```

위와 같이 설정하면 **`users` 테이블에서 특정 사용자가 삭제될 경우, 해당 사용자의 주문 데이터도 자동으로 삭제**됩니다. (`ON DELETE CASCADE`)
# R-Tree 인덱스
공간 인덱스 = R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스  
- 공간 데이터 저장할 수 있는 데이터 타입
- 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
- 공간 데이터의 연산 함수(거리, 포함 관계 처리)


너무 어려워...  


# 전문 검색 인덱스

## 인덱스 알고리즘
키워드 분석, 키워드로 인덱스 구축  
어근 분석, n-gram 분석

### 어근 분석 알고리즘 
mysql의 전문 검색 인덱스는 `불용어처리` `어근분석` 을 거쳐 색인 작업 수행됨.  

`불용어처리`: 가치 없는 단어 필터링해 제거  
`어근분석`: 검색어의 원형을 찾는 작업  

### n-gram 알고리즘
MeCab 쉽지 않음.  
형태소 분석 -> 문장 이해  
n-gram -> 단순 키워드 검색해내기 위한 인덱싱 알고리즘  
`n-gram`  
본문을 무조건 몇 글자씩 잘러서 인덱싱.  
알고리즘 간단.  
인덱스 크기 큼.  
n = 인덱싱할 키워드의 최소 글자 수(주로 2 많이 사용)  
mysql이 생성된 토큰들에 대해 불용어 걸러냄.  
`information_schema.inno_db_ft_default_stopword` 테이블에 불용어 목록 저장.  
토큰을 B-Tree 인덱스에 저장.  

### 불용어 변경 및 삭제
불용어로 인식해 막 잘라내면 혼란 야기할 수 있음.  
직접 불용어 추가 권장  

무시하는 벙법  
1.  모든 전문 검색 인덱스에 대해 불용어 완전히 제거
my.cnf -> `ft_stopword_file=''`

2. innodb 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리 무시.  
SET GLOBAL innodb_ft_enable_stopword=OFF

**사용자 정의 불룡어 사용**
파일 만들어 my.cnf -> `ft_stopword_file=''` 여기에 경로 등록
테이블로 저장

## 전문 검색 인덱스의 가용성
두가지 조건
- 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST ...) 사용
- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

그냥 이렇게 쓰면 풀스캔   
  SELECT * FROM table WHERE column LIKE '%keyword%';  

이렇게 써야함.  
SELECT * FROM table WHERE MATCH(column) AGAINST('keyword');

# 함수 기반 인덱스
칼럼 값을 변형해서 만들어진 값에 대한 인덱스 만들 때  
- 가상 칼럼을 이용한 인덱스 
- 함수를 이용한 인덱스

## 가상 칼럼을 이용한 인덱스
성, 이름 있을 때 이걸 합쳐서 가상 칼럼으로 추가하고 인덱스 만들 수 있음.  
```mysql
ALTER TABLE user ADD COLUMN full_name VARCHAR(100) AS (CONCAT(last_name, first_name)) VIRTUAL;
ADD INDEX ix_full_name (full_name);
```
이것은 실제 칼럼을 추가하는 것과 같은 효과 -> 실제 테이블의 구조 변경되는 단점.  

## 함수를 이용한 인덱스
테이블 구조 변경 않고 함.  
조건절에 함수 기반 인덱스에 명시된 표한이 그대로 사용돼야함.  

INDEX ix_full_name ((CONCAT(last_name, first_name)));  

WHERE CONCAT(last_name, first_name) = 'Junhyun Kang';  

# 멀티 밸류 인덱스 
보통 인덱스 키:레코드 1:1  
멀티 밸류 인덱스: 인덱스 키:레코드 N:1
JSON 타입 지원  
credit_info JSON
INDEX mx_creditscores (( CAST(credit_info->'$.credit_scores' AS UNSIGNED_ARRAY)));  

일반 조건문 사용하면 안 됨. 반드시 `MEMBER OF()` `JSON_CONTAINS()` `JSON_OVERLAPS()` 사용해야함.

# 클러스터링 인덱스
innodb만 지원  

## 클러스터링 인덱스 
프라이머리키에 대해서만 적용  
프라이머리키 값이 비슷한 레코드끼리 묶어서 저장  
프라이머리키에의해 레코드 저장 위치 결정  
키 값 변경되면 레코드의 물리적 위치 바뀜  
사실상 테이블 레코드 저장 방식  
클러스터링 인덱스 = 클러스터링 테이블  
검색 빠르고, 변경 저장이 느림.  

리프 노드에 레코드의 모든 칼럼이 같이 저장됨.  
pk변경 조심.  

pk없을때
1. pk있으면 그거 선택
2. NOT NULL UNIQUE 칼럼 중 첫번째 인덱스
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가 후 선택  

마지막은 아무 혜택 없음.  

## 세컨더리 인덱스에 미치는 영향
걱정 마세요.!  

## 클러스터링 인덱스의 장단점

- 장점
  - pk로 검색할 때 터리 성능 빠름
  - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 갖고 있어 인덱스만 처리될 수 있는 경우가 많음.
- 단점
  - 테이블의 모든 세컨더리 인덱스가 클러스트링 키를 갖어 클러스터링 키 값이 크면 전체적으로 인덱스의 크기가 커짐.
  - 세컨더리 인덱스를 통해 검색할 때 pk로 다시 한번 검색 -> 성능 느림
  - INSERT 할때 pk에 의해 레코드 위치 결정 -> 성능 느림
  - pk 변경할 때 레코드 DELETE -> INSERT -> 성능 느림  
  
## 클러스터링 테이블 사용 시 주의사항
### 클러스터링 인덱스 키의 크기
pk커지면 인덱스 커짐.

### 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성
빈번히 사용되기 때문

### pk는 반드시 명시
없으면 오토인크리먼트와 같은 효과지만 사용불가니까 오토인크리먼트라도 명시.

### AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
pk너무 커지면 오토인크리먼트로 하는 것도 나쁘지 않음. INSERT 위주는 오토인크리먼트 좋음.

# 유니크 인덱스 
## 유니크 인덱스와 일반 세컨더리 인덱스 비교
구조상 차이점 없음. 성능 차이 보자.

### 인덱스 읽기
유니크하지 않은 인덱스는 디스크 읽기가 아니라 CPU에서 칼럼값을 비교하기 때문에 둘의 차이 거의 없음.  
유니크하지 않은 게 중복된 값이 허용되므로 읽을 레코드가 많아 느린 것이지 인덱스 자체의 특성 때문에 느린 건 아님.
### 인덱스 쓰기
유니크 인덱스는 중복된 값이 있는지 체크하는 과정이 필요. 그래서 느림.  
중복체크 -> 읽기 잠금  
쓰기 -> 쓰기 잠금  
데드랑 반번  
중복체크 때문에 체이진드 버퍼의 버퍼링 하지 못함.
## 유니크 인덱스 사용 시 주의사항
꼭 필요하지 않다.

# 외래키

## 자식 테이블의 변경이 대기하는 경우

## 부모 테입르의 변경 작업이 대기하는 경우
# 8.4~8.10

# 8.4 R-Tree 인덱스

- 2차원 데이터 검색 목적의 인덱스

## 8.4.1 구조 및 특성

- 데이터 타입
    - point, line, polygon, geometry
    - geometry는 앞에 3개의 슈퍼타입으로 전부 저장 가능
- MBR = 도형을 감싸는 최소 크기의 사각형
- R-Tree → 이 MBR의 관계를 B-Tree 형태로 구현한 인덱스

## 8.4.2 R-Tree 인덱스의 용도

- 위도, 경도 좌표 저장에 사용
- 좌표시스템이라면 적용가능

# 8.5 전문 검색 인덱스

- 전문 = Full Text
- 칼럼값이 1MB여도 3072B까지만 자르고 좌측 일치만 인덱싱을 했음 → 그래서 글안에 써진 내용 일치에 대한 검색을 하기위해서는 다른 방법이 필요함
- 여기서 전문 검색 인덱스(알고리즘)을 사용

## 8.5.1 인덱스 알고리즘

- 어근 분석 알고리즘
- n-gram 알고리즘

### 8.5.1.1 어근 분석 알고리즘

- 불용어 처리
- 어근 분석
- 불용어를 사용자가 직접 정하는게 유용할 수 있음
- MeCab 플러그인을 활용

### 8.5.1.2 n-gram 알고리즘

- 본문을 잘라서 인덱싱
- 국가별 언어에 대한 이해가 필요없음
- 인덱스 크기가 상당히 큼
- 보통은 2글자씩 분리하는 2-gram을 많이 씀

### 8.5.1.3 불용어 변경 및 삭제

- 내장 불용어는 혼란을 불러올 수 있음
- 직접 등록하는걸 권장

## 8.5.2 전문 검색 인덱스의 가용성

- 전문 인덱스 보유
- MATCH … AGAINST 문법을 사용해서 검색해야함, LIKE같은 문법은 안됨

# 8.6 함수 기반 인덱스

- 칼럼값을 변경해서 인덱싱을 하고싶을때 사용
- 가상 칼럼 인덱스
- 함수 인덱스

## 8.6.1 가상 칼럼을 이용한 인덱스

- VIRTUAL, STORED 옵션이 있음
- 테이블에 새로운 칼럼 추가하는 효과가 있어서 별로일 수 있음

## 8.6.2 함수를 이용한 인덱스

- 원하는 형태로 인덱싱을 해서 저장. ex) CONCAT(first_name, ‘ ‘, last_name)
- 활용하려면 무조건 저장한 함수 형태를 where절에 사용해야함

# 8.7 멀티 밸류 인덱스

- 레코드에 대해 키가 여러개인 인덱스
- 정규화에 위배되지만 최근 JSON같은 데이터타입을 지원하면서 만들어짐
- MEMBER OF(), JSON_CONTAINS(), JSON_OVERLAPS() → 이 함수들로만 검색이 가능함

# 8.8 클러스터링 인덱스

- 여러개를 하나로 묶는다.

## 8.8.1 클러스터링 인덱스

- 프라이머리 키에 대해서만 적용
- 레코드의 저장위치를 결정 - 물리적인 저장위치
- InnoDB의 가장 큰 특징
- 이 인덱스에는 레코드의 모든 값이 저장돼있음

## 8.8.2 세컨더리 인덱스에 미치는 영향

- 세컨더리 인덱스가 실제 레코드 위치를 저장한다면 위치가 바뀔시에 모든 인덱스의 값들을 바꿔줘야하는 오버헤드가 있음, 그래서 InnoDB는 다르게 저장
- 세컨더리 인덱스에서 프라이머리 키를 알아내서 그걸 통해 또 검색
- 세컨더리 인덱스의 값이 바로 프라이머리 키 값이기 때문에 프라이머리 키의 값이 길면 인덱스도 커진다.

## 8.8.3 클러스터링 인덱스의 장점과 단점

- 장점:
    - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름(특히, 범위 검색)
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(이를 커버링 인덱스라고 한다.) → 밸류가 ROWID가 아닌 프라이머리 키라서, 사실상 컬럼이 하나 더 있는셈
- 단점:
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스 크기가 커짐
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 한번 더 검색해야 해서 처리 성능이 느림
    - INSERT시에 프라이머리 키에 의해 레코드 저장위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림
- 대체적으로 빠른 읽기가 장점, 느린 쓰기가 단점 → 보통의 환경은 쓰기와 읽기의 비율이 2:8이라서 적합

## 8.8.4 클러스터링 테이블 사용시 주의 사항

### 8.8.4.1 클러스터링 인덱스 키의 크기

- 값이 클러스터링 키이기 때문에 잘 선택해야함

### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)

- 검색이 매우빠르기때문에 프라이머리 키가 업무에 활용되는 값이라면 매우 좋을 것

### 8.8.4.3 프라이머리 키는 반드시 명시할 것

- 명시안하면 자동으로 일련번호 컬럼을 만드는데, 이건 사용자가 볼 수 없어서 별로임
- AUTO_INCREMENT라도 만들어서 꼭 명시할 것

### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

- 복합 키가 프라이머리 키일 경우 키의 크기가 길어질 때가 있음
- 세컨더리 인덱스가 필요하고, 프라이머리 키도 길다면 AUTO_INCREMENT컬럼을 추가해서 프라이머리 키로 사용하면 좋다. → 세컨더리가 필요없다면 그대로 사용해도됨
- 로그같은 INSERT가 많은건 AUTO_INCREMENT를 활용하는게 좋음

# 8.9 유니크 인덱스

- 인덱스 보다는 제약조건에 가깝
- MyISAM같은 곳에서는 프라이머리 키도 그냥 NULL 허용안되는 유니크인덱스지만 InnoDB에서는 클러스터링 키로도 작동하기때문에 다르다.

## 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

- 구조적으로 차이 없음

### 8.9.1.1 인덱스 읽기

- 레코드 개수만 차이날뿐 근본적으로 다른 인덱스와 속도가 같다. 단지 읽어야 할 레코드가 중복이 없어서 빨라보인다.

### 8.9.1.2 인덱스 쓰기

- 중복 체크를 위해 한번 훑어야 해서 세컨더리보다 쓸 때 느림
- 읽기 잠금도 사용, 쓰기 잠금도 사용
- 세컨더리 인덱스는 체인지 버퍼가 사용될 수 있지만 유니크 인덱스는 중복 체크를 해야해서 작업 자체를버퍼링이 불가
- 결과적으로 쓰기작업이 세컨더리 인덱스보다 느림

## 8.9.2 유니크 인덱스 사용 시 주의 사항

- 굳이 인덱스 추가 안해도됨, 구조적으로 인덱스기때문에
- 프라이머리 키와 유니크 인덱스를 같이 생성할 필요는 없다. 중복이다.

# 8.10 외래키

- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스 생성
- 두 가지 특징
    - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
    - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

## 8.10.1 자식 테이블의 변경이 대기하는 경우

- 부모 테이블의 값을 바꾸고 다른 커넥션에서 자식 테이블의 값을 바꾸면 부모테이블의 값이 롤백되거나 커밋돼야 마무리된다.

## 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

- 자식 테이블 값 변경중에 다른 커넥션에서 부모 레코드 삭제 시(CASCADE가 있다면) 자식 작업이 끝날때까지 기다림

## 8.4 R-Tree 인덱스

B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라 값인 반면, R-Tree 인덱스는 2차원의 공간 개념 값

MySQL의 공간 확장

- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
- 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 8.4.1 구조 및 특성

MySQL 지원 데이터 타입

- POINT, LINE, POLYGON, GEOMETRY

Minimum Bounding Rectangle : 도형을 감싸는 최소 크기의 사각형

최하위 레벨의 MBR = 각 도형 데이터의 MBR - 리프 노드

차상위 레벨의 MBR = 중간 크기의 MBR - 브랜치 노드

최상위 레벨의 MBR = 루트 노드에 저장되는 정보

### 8.4.2 R-Tree 인덱스의 용도

ST_Contains() 또는 ST_Within() 함수를 이용하여 사각 점선의 상자에 포함되는 점들을 검색

## 8.5 전문 검색 인덱스

### 8.5.1 인덱스 알고리즘

**8.5.1.1 어근 분석 알고리즘**

- 불용어 처리
    
    가치가 없는 단어를 모두 필터링해서 제거하는 작업
    
    상수로 정의하여 사용
    
- 어근 분석
    
    선정 단어의 뿌리인 원형을 찾는 작업
    

두 과정을 거쳐 색인 작업이 수행

**8.5.1.2 n-gram 알고리즘**

키워드를 검색하기 위한 인덱싱 알고리즘

본문을 몇 글자씩 잘라서 인덱싱하는 방법

일반적으로 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-gram 방식을 많이 사용

**8.5.1.3 불용어 변경 및 삭제**

전문 검색 인덱스의 불용어 처리 무시 방법 2가지

- 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거
    
    my.cnf의 ft_stopword_file 시스템 변수에 빈 문자열을 설정 (ft_stopword_file = ‘’)
    
- InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리를 무시
    
    InnoDB의 innodb_ft_enable_stopword 시스템 변수를 OFF로 설정(다른 스토리지 엔진을 사용하는 테이블은 여전히 내장 불용어 처리 사용, MySQL 서버가 실행중인 상태에서도 변경가능한 동적 시스템변수)
    
    mysql> SET GLOBAL innodb_ft_enable_stopword=OFF;
    

사용자 정의 불용어 사용 방법 2가지

- 불용어 목록을 파일로 저장하고, MySQL 서버 설정 파일에서 파일의 경로를 다음과 같이 ft_stopword_file 설정에 등록(ft_stopword_file=’/data/my_custom_stopword.txt’)
- 불용어의 목록을 테이블로 저장
    
    불용어 테이블 생성, innodb_ft_server_stopword_table 시스템 변수에 불용어 테이블을 설정
    

### 8.5.2 전문 검색 인덱스의 가용성

두가지 조건을 갖춰야 사용 가능

- 쿼리 문장이 전문 검색을 위한 문법을 사용
- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

전문 검색 인덱스를 사용하려면 반드시 MATCH (…) AGAINST(…) 구문으로 검색 쿼리를 작성해야 하며, 전문 검색 인덱스를 구성하는 칼럼들은 MATCH 절의 괄호 안에 모두 명시돼야 함

## 8.6 함수 기반 인덱스

MySQL 서버에서 함수 기반 인덱스를 구현하는 방법 2가지

- 가상 칼럼을 이용한 인덱스
- 함수를 이용한 인덱스

### 8.6.1 가상 칼럼을 이용한 인덱스

특정 칼럼이 추가될 경우, 모든 레코드에 대해 업데이트하는 작업을 거쳐야 했지만, 가상 칼럼을 추가하고 그 가상 칼럼에 인덱스를 생성할 수 있음

### 8.6.2 함수를 이용한 인덱스

테이블 구조를 변경하지 않고 함수를 직접 사용하는 인덱스를 생성할 수 있음

계산된 결괏값의 검색을 빠르게 만듬

반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 함

## 8.7 멀티 밸류 인덱스

전문 검색 인덱스를 제외한 모든 엔딕스는 레코드 1건이 1개의 인덱스 키 값을 가짐(인덱스 키-데이터 레코드 1:1)

멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스

원래라면 정규화에 위배되는 형태이지만 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생

다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립

- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

## 8.8 클러스터링 인덱스

테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안

### 8.8.1 클러스터링 인덱스

클러스터링 인덱스 : 프라이머리 카 값이 비슷한 레코드끼리 묶어서 저장하는 것

프라이머리 키 값에 의해 레코드의 저장 위치가 결정됨 → 프라이머리 키 값이 변경된다면 레코드의 물리적인 저장 위치가 바뀌어야 함 ⇒ 클러스터링 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크므로 신중히 프라미어리 키 결정

프라이머리 키 기반 검색이 빠르지만 저장이나 프라어머리 키의 변경이 느림

클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장돼 있음 ⇒ 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리됨

프라이머리 키가 없을 때 클러스터링 테이블의 구성방법(InnoDB)

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

적절한 클러스터링 키 후보를 찾지 못할 경우 스토리지 엔진이 내부적으로 레코드의 일련번호 칼럼을 생성

→ 프라이머리 키나 유니크 인덱스가 없는 InnoDB 테이블에서는 아무 의미 없는 숫자 값으로 클러스터링되는 것이며 혜택이 없음

### 8.8.2 세컨더리 인덱스에 미치는 영향

InnoDB에서 세컨더리 인덱스가는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있음

InnoDB에서 검색 시 → 인덱스를 검색해 레코드의 프라이머리 키 값을 확인할 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴

MyISAM → 인덱스를 검색해서 레코드의 주소를 확인한 후, 레코드의 주소를 이용해 최종 레코드를 가져옴

### 8.8.3 클러스터링 인덱스의 장점과 단점

장점 : 검색이 매우 빠르고 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

단점 : 클러스터링 키 값의 크기가 클 경우 인덱스의 크기가 커지고, 세컨더리 인덱스를 통해 검색할 경우 프라이머리 키로 다시 검색해야 하며, insert와 update할 때 처리 성능이 느림

### 8.8.4 클러스터링 테이블 사용 시 주의사항

**8.8.4.1 클러스터링 인덱스 키의 크기**

클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함하며 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커짐

⇒ 프라이머리 키를 신중히 선택해야함

**8.8.4.2 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성**

**8.8.4.3 프라이머리 키는 반드시 명시할 것**

**8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우**

인조 식별자 : 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키 ex) AUTO_INCREMENT

## 8.9 유니크 인덱스

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

**8.9.1.1 인덱스 읽기**

유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼값을 비교하는 작업이기 떄문에 성능상 영향이 거의 없음 

⇒ 유니크 하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이며 인덱스 자체의 특성 때문에 느린 것이 아님

**8.9.1.2 인덱스 쓰기**

유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하므로 더 느림

### 8.9.2 유니크 인덱스 사용 시 주의사항

MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하기 때문에 중복해서 인덱스를 생성할 필요가 없음

## 8.10 외래키

외래키 관리의 중요한 2가지 특징

- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생시키지 않음

**8.10.1 자식 테이블의 변경이 대기하는 경우**

부모 테이블의 해당 레코드가 쓰기 잠금 일 경우 → 자식 테이블도 잠금 대기

**8.10.1 부모 테이블의 변경 작업이 대기하는 경우**

부모 테이블에서 특정 레코드 변경 → 자식 테이블의 레코드도 변경

자식 테이블의 레코드가 잠금 → 부모 테이블도 대기

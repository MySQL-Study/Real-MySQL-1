## 8.4 R-Tree 인덱스
- `공간 인덱스(Spartial Index)`
    - R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스
    - B-Tree와 기본적인 내부 메커니즘과 흡사

- `공간 확장(Spartial Extension)`
    - 공간 데이터를 저장할 수 있는 데이터 타입
    - 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
    - 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 8.4.1 구조 및 특성
- MySQL은 공간 정보의 저장 및 검색을 위해 여러가지 `기하학적 도형(Geometry)` 정보를 관리할 수 있는 데이터 타입 제공
    - `POINT`
    - `LINE`
    - `POLYGON`
    - `GEOMETRY` : 나머지 3개 타입의 슈퍼 타입
      <br>

- `MBR`
    - Minimun Bounding Rectangle
    - 해당 도형을 감싸는 최소 크기의 사각형
    - 이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스

### 8.4.2 R-Tree 인덱스의 용도
- R-Tree는 MBR 정보를 이용해 B-Tree 형태로 인덱스를 구축
  -> Rectangle의 "R" + B-Tree의 "Tree"
- 공간(Spatial) 인덱스라고도 함.
- WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용됨.
- CAD/CAM 소프트웨어 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있음.

## 8.5 전문 검색 인덱스
- MySQL의 B-Tree 인덱스는 전체의 값을 인덱스 키로 사용하는 것이 아니라 잘라서 인덱스 키로 사용
    - 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능
- 문서 내용 전체를 인덱스화해서 특정 키워드가 포함되는 문서를 검색하는 Full Text(전문) 검색에서는 InnoDB나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없음.
- `Full Text Search 인덱스(전문 검색 인덱스)`
    - 문서 전체에 대한 분석과 검색을 위한 이러한 인덱싱 알고리즘
    - 일반화된 기능의 명칭, 전문 검색 알고리즘 이름을 지칭하는 것은 아님.

### 8.5.1 인덱스 알고리즘
- 전문 검색
  : 문서 본문의 내용에서 사용자가 검색하게 될 키워드 분석해 내고, 빠른 검색용으로 사용
  - 키워드 분석 및 인덱스 구축에는 여러가지 방법 있음.
  - 키워드 분석
  - n-gram 알고리즘

#### 8.5.1.1 어근 분석 알고리즘
- MySQL 서버 전문 검색 인덱스는 두 가지 중요한 과정 거쳐서 색인 작업 수행됨
    - 불용어(Stop Word) 처리
        - 검색에서 별 가치 없는 단어를 모두 필터링해서 제거하는 작업 의미
        - 개수가 많지 않기 때문에 알고리즘을 구현한 코드에서 모두 상수로 정의해서 사용하는 경우가 많음
        - 유연성을 위해 불용어 자체를 데이터베이스화해서 사용자가 추가하거나 삭제할 수 있게 구현하는 경우도 있음.
        - MySQL 서버는 불용어 소스코드가 정의돼 있지만, 사용자가 별도로 정의할 수도 있음.
    - 어근 분석(Stemming)
        - 검색어로 선정된 단어의 뿌리인 원형을 찾는 과정
        - MySQL 서버에서는 오픈소스 형태소 분석 라이브러리인 MeCab을 플러그인 형태로 사용할 수 있게 지원 (일본어를 위한 형태소 분석 프로그램)
        - 서구권 언어를 위한 형태소 분석기는 MongoDB에서 사용되는 Snowball
        - 국가의 언어가 서로 문법이 다르고 다른 방식으로 발전해왔기 때문에 형태소 분석이나 어근 분석 또한 언어별로 방식이 모두 다름
        - 한국어는 일본어와 그나마 많이 비슷 -> MeCab을 통해 가능
        - 실제 언어의 샘플을 이용해 언어를 학습하는 과정이 필요 -> 많은 시간, 노력 필요

#### 8.5.1.2 n-gram 알고리즘
- MeCab을 위한 형태소 분석은 매우 전문적인 알고리즘 -> 만족할 만한 결과를 내기 위해서는 많은 노력과 시간을 필요로 함.
    - 전문적인 검색 엔진을 고려하는 것이 아니라면 범용적으로 적용하기는 어려움.
    - 이러한 단점 보완하기 위해 n-gram 알고리즘 도입
- `n-gram 알고리즘 `
    - 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법
    - 형태소 분석보다는 알고즘이 단순하고 국가별 언어에 대한 이해와 준비 작업 필요 없음.
    - 만들어진 인덱스 크기는 상당이 큰 편
    - 'n'은 인덱싱하는 키워드의 최소 글자 수 의미
    - 일반적으로, 2-gram(Bi-gram) 방식을 많이 사용

- ` 2-gram(Bi-gram)`
    - 각 단어는 띄어쓰기(공백)과 마침표(.)를 기준으로 구분
    - 2글자씩 중첩해서 토큰으로 분리 (ex) 10글자 단어라면, (10-1)개의 토큰으로 구분됨)
    - 구분된 토큰을 인덱스에 저장하고, 중복된 토큰은 하나읭 ㅣㄴ덱스 엔트리로 병합
    - 이후 MySQL 서버는 토큰들에 대해 불용어를 걸러내는 작업 수행
    - MySQL 서버에 내장된 불용어는 `information_schema.innodb_ft_default_stopword` 테이블에서 확인 가능
- 구분된 토큰을 단순한 B-tree 인덱스에 저장

#### 8.5.1.3 불용어 변경 및 삭제
- 불용어 처리가 더 사용자를 혼란스럽게 하기도 함 -> 불용어 처리 자체를 완전히 무시하거나 사용자가 직접 불용어를 등록하는 방법 권장

**전문 검색 인덱스의 불용어 처리 무시**
- 스토리지 엔진에 관계없이 MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거
    - MySQL 서버의 설정파일(my.cnf)의 `ft_stopword_file` 시스템 변수에 빈 문자열을 저장
    - 재시작 해야만 변경사항이 반영됨.
    - 내장 불용어 비활성화 하거나 사용자 정의 불용어 적용할 때도 사용가능
- InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리를 무시
    - `innodb_ft_enable_stopword` 시스템 변수를 OFF로 설정
    - 동적인 시스템 변수여서 MySQL 서버가 실행 중인 상태에서도 변경 가능

**사용자 정의 불용어 사용**
- 불용어 목록을 파일로 저장하고 MySQL 서버 설정 파일에서 파일의 경로를 `ft_stopword_file` 설정에 저장

- InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 엔진에서만 사용할 수 있는데, 불용어 목록을 테이블로 저장하는 방식
    - 불용어 테이블을 생성하고, `innodb_ft_server_stopword_table` 시스템 변수에 불용어 테이블을 설정하면 됨
    - 불용어 목록 변경한 이후 전문 검색 인덱스가 생성돼어야 불용어가 적용됨.

- `innodb_ft_user_stopword_table` 시스템 변수를 이용하는 방법
    - `innodb_ft_server_stopword_table`시스템 변수와 사용법 동일
    - 여러 전문 검색 인덱스가 서로 다른 불용어를 사용하는 경우에 사용

### 8.5.2 전문 검색 인덱스의 가용성
- 전문 검색 인덱스 사용할 때 갖춰야하는 조건
    - 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST...)을 사용
    - 테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스 보유

## 8.6 함수 기반 인덱스
- 일반적인 인덱스는 칼럼의 값 일부(칼럼의 값 앞부분) 또는 전체에 대해서만 인덱스 생성이 허용됨.
- 때로는 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때도 있음 -> `함수 기반의 인덱스` 활용

- MySQL 서버에서 함수 기반 인덱스 구현 방법
    - 가상 칼럼을 이용한 인덱스
        - 함수를 이용한 인덱스
        - 인덱싱 할 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스 내부적인 구조나 유지 관리 방법은 B-Tree 인덱스와 동일

### 8.6.1 가상 칼럼을 이용한 인덱스
- 이전버전의 MySQL 서버에서는 칼럼을 추가하고 모든 레코드에 대해 업데이트 작업을 거쳐야 인덱스 추가할 수 있었음.
- MySQL 8.0부터는 가상 컬럼을 추가하고 그 가상 컬럼에 인덱스 생성할 수 있게 되었음.
- 가상 칼럼이 VIRTUAL이나 STORED 옵션 중 어떤 옵션으로 생성됐든 관계 없이 해당 가상 칼럼에 인덱스를 생성할 수 있음.

### 8.6.2 함수를 이용한 인덱스
- MySQL 5.7에서는 함수를 직접 인덱스 생성하는 구문에 사용할 수 없었음.
- MySQL 8.0부터는 테이블 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스 생성 가능하게 됨.
- 함수를 직접 사용하는 인덱스는 테이블의 구조를 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들어 줌.
- 함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 함.
    - 다르다면, MySQL 옵티마이저는 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못함.

## 8.7 멀티 밸류 인덱스
- 전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가짐.
- 인덱스 키와 데이터 레코드는 1:1의 관계를 가짐
- 멀티 밸류(Multi-Value) 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 레코드
- 일반적인 RDBMS를 기준으로 생각하면, 이러한 인덱스는 정규화에 위배되는 형태
    - RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생함.
    - JSON 포맷으로 데이터를 저장하는 MongoDB는 처음부터 지원했으나, MySQL 서버는 멀티 밸류 인덱스에 대한 지원 없이 JSON 타입만 지원했었음.
    - MySQL 8.0 버전으로 업그레이드되면서 MySQL 서버의 JSON 관리 기능은 부족함이 없게 됨.
- 멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 상용하는 것이 아닌, 반드시 다음 함수들을 이용해 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립
    - MEMBER OF()
    - JSON_CONTAINS()
    - JSON_OVERLAPS()

## 8.8 클러스터링 인덱스
- 클러스터링: 여러개를 하나로 묶는다는 의미
- MySQL에서의 클러스터링: 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로) 묶어서 저장하는 형태로 구현
    - 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안
    - MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 제공

### 8.8.1 클러스터링 인덱스
- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용됨.
- 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정됨.
    - 프라이머리 키 값이 변경되면, 그 레코드의 물리적인 저장 위치가 바뀌게 됨.
    - 프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 크기 때문에 프라이머리 키를 신중하게 결정해야 함.
    - `클러스터링 테이블`과 동의어로 사용되기도 함.
- 클러스터링 기준이 되는 프라이머리 키를 클러스터링 키라고 하기도 함.
- 프라이머리 키 기반의 검색이 매우 빠르고, 레코드의 저장이나 프라이머리 키 변경이 상대적으로 느림.
  <br>
- 프라이머리 키가 없는 경우에 InnoDB 테이블이 클러스터링 구성하는 법
    - 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
    - NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택
    - 자동으로 유니크 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

### 8.8.2 세컨더리 인덱스에 미치는 영향
- MyISAM 테이블이나 MEMORY 테이블에서는 프라이머리 키와 세컨더리 키 인덱스는 구조적으로 차이가 없음.
    - InnoDB 테이블에서 세컨더리 인덱스가 실제 저장된 주소를 갖고 있는 경우
    - 클러스터링 키 값이 변경될 때마다 데이터 레코드 주소가 변경되고, 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값 변경해야 함.
    - 이런 오버헤드 제거하기 위해 InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라, 프라이머리 키 값을 저장하도록 구현

- MyISAM
  : 인덱스를 검색해서 레코드의 주소를 확인한 후, 레코드의 주소를 이용해 최종 레코드를 가져옴.
  - 프라이머리 키로 클러스터링 된 InnoDB
  : 인덱스를 검색해 레코드의 프라이머리 키 값을 확인한 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴. (더 복잡하지만, 더 큰 장점 제공)

### 8.8.3 클러스터링 인덱스의 장점과 단점
- 장점 : 빠른 읽기(SELECT)
    - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 갖고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음.


- 단점 : 느린 쓰기(INSERT, UPDATE, DELETE)
    - 테이블이 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한 번 검색해야 하므로 처리 성능이 느림
    - INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

- 온라인 트랜잭션 환경(OLTP)에서는 쓰기와 읽기 비율이 2:8 또는 1:9이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이 중요

### 8.8.4 클러스터링 테이블 사용 시 주의사항
#### 8.8.4.1 클러스터링 인덱스 키의 크기
- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함
    - 프라이머리 키 크기가 커지면 세컨더링 인덱스도 자동으로 크기가 커짐.

#### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)
- 프라이머리 키로 검색하는 경우 클러스터링 되지 않은 테이블에 비해 매우 빠르게 처리될 수 있음.
- 해당 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있는 칼럼을 프라이머리 키로 설정하는 것이 좋음.

#### 8.8.4.3 프라이머리 키는 반드시 명시할 것
- 프라이머리 키를 AUTO_INCREMENT 칼럼을 이용해서라도 프라이머리 키를 생성하는 것을 권장
    - InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 내부적으로 일련번호 칼럼을 추가하는 데, 사용자가 전혀 접근할 수 없으므로, 사용자가 접근할 수 있는 칼럼을 만드는 것과 동일하므로 만드는 것이 나음.
- ROW 기반의 복제나 InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야만 하는 정상적인 복제 성능을 보장하기도 하므로 프라이머리 키를 꼭 생성하는 것이 좋음.

#### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
- 여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어지더라도 세컨더리 인덱스가 필요치 않다면, 그대로 프라이머리 키를 사용하는 것이 좋음.
- 세컨더리 인덱스도 필요하고, 프라이머리 키의 크기도 길면, AUTO_INCREMENT로 칼럼 추가하고, 이를 프라이머리 키로 설정하면 됨.
    - 이렇게 인위적으로 추가된 프라이머리 키를 인조 식별자(Surrogate key)라고 함.

## 8.9 유니크 인덱스
- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미
- MySQL에서는 인덱스 없이 유니크 제약만 설정할 수는 없음.
- NULL도 저장될 수 있는데, NULL은 특정 값이 아니므로, 2개 이상 저장될 수 있음.
- MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여됨.
    - MyISAM이나 MEMORY 테이블에서 프라이머리 키는 NULL이 허용되지 않는 유니크 인덱스와 같음.
    - InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하므로, 유니크 인덱스와는 근본적으로 다름.

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
#### 8.9.1.1 인덱스 읽기
- 유니크 인덱스와 유니크 하지 않은 세컨더리 인덱스는 성능상 영향이 거의 없음.
    - 유니크하지 않은 세컨더리 인덱스에서 하는 작업이 디스크 읽기에서 하는 것이 아니라  CPU에서 칼럼값을 비교하는 작업이기 때문에 성능상 영향 거의 없음.
    - 인덱스 자체의 특성이 아닌, 중복된 값이 허용되므로 읽어야 할 레코드가 많아 느린 것

#### 8.9.1.2 인덱스 쓰기
- 유니크하지 않은 세컨더리 인덱스의 쓰기보다 유니크 인덱스의 키 값을 쓸 때 더 느림
    - 유니크 인덱스의 키 값을 쓸 때 중복된 값이 있는지 없는지 체크하는 과정이 필요

### 8.9.2 인덱스 사용 시 주의사항
- MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요 없음.(유니크 인덱스와 일반 인덱스를 모두 생성할 필요 없다는 의미, 세컨더리 인덱스를 중복으로 만들어줄 필요도 없음.)
- 유일성이 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려 필요

## 8.10 외래키
- MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있음.
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성됨.
- 외래키가 제거되지 않은 상태에서는 자동으로 새엇ㅇ된 인덱스 삭제 불가

- InnoDB 외래키 관리의 특성
    - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생
    - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음.

### 8.10.1 자식 테이블의 변경이 대기하는 경우
- 자식 테이블의 외래 키 칼럼의 변경은 부모 테이블의 확인이 필요한데, 이 때 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면, 해당 쓰기 잠금 해제될 때까지 기다리게 됨.
- 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장은 발생하지 않음.

### 8.10.2 부모 테이블의 변경 작업이 대기하는 경우
- 자식 테이블이 생성될 때 정의된 외래키의 특성 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 동작
- 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 확인 -> 이러한 체크를 위해 연관된 테이블에 읽기 잠금을 걸어야 함.
- 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미침.
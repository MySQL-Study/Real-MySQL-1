# 목차

### [Chapter 4 - 아키텍처 (처음~4.2.6)](#chapter4---아키텍처-처음426)

#### [1. MySQL 엔진 아키텍처](#41-mysql-엔진-아키텍처)

-   [1.1 MySQL엔진, 스토리지 엔진, 핸들러](#411-mysql엔진-스토리지-엔진-핸들러)
-   [1.2 MySQL 스레딩 구조](#412-mysql-스레딩-구조)
-   [1.3 메모리 할당 및 사용 구조](#413-메모리-할당-및-사용-구조)
-   [1.4-1.5 플러그인과 컴포넌트](#414-415-플러그인과-컴포넌트)
-   [1.6 쿼리 실행 구조](#416-쿼리-실행-구조)
-   [1.8 쿼리 캐시](#418-쿼리-캐시)
-   [1.9 스레드 풀](#419-스레드-풀)
-   [1.10 트랜잭션 지원 메타데이터](#4110-트랜잭션-지원-메타데이터)

#### [2. InnoDB 스토리지 엔진 아키텍처](#42-innodb-스토리지-엔진-아키텍처)

-   [2.1 프라이머리 키에 의한 클러스터링](#421-프라이머리-키에-의한-클러스터링)
-   [2.2 외래 키 지원](#422-외래-키-지원)
-   [2.3 MVCC](#423-mvcc-multi-version-concurrency-control)
-   [2.4 잠금 없는 일관된 읽기](#424-잠금-없는-일관된-읽기non-locking-consistent-read)
-   [2.5 자동 데드락 감지](#425-자동-데드락-감지)
-   [2.6 자동화된 장애 복구](#426-자동화된-장애-복구)

---

# Chapter4 - 아키텍처 (처음~4.2.6)

MySQL 서버

-   MySQL 엔진 : 사람의 머리 역할을 담당
-   스토리지 엔진 : 사람의 손발 역할을 담당
    -   핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해 사용할 수 있다.
    -   MySQL에서 기본으로 제공되는 스토리지 엔진 : InnoDB, MyISAM

## 4.1 MySQL 엔진 아키텍처

![[images/KakaoTalk_20241226_094036580.jpg]]

### 4.1.1 MySQL엔진, 스토리지 엔진, 핸들러

#### MySQL 엔진

-   커넥션 핸들러: 클라이언트로부터의 접속 및 요청을 처리
-   SQL 파서 및 전처리기
-   옵티마이저: 쿼리의 최적화된 실행

#### 스토리지 엔진

-   스토리지 엔진은 여러 개를 동시에 사용할 수 있다
-   테이블에서 사용할 스토리지 엔진을 지정할 수 있다 : `CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;`
-   각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 InnoDB 버퍼풀(InnoDB)을 가지고 있다
    > **키 캐시와 버퍼풀**
    >
    > 키 캐시(MyISAM): 디스크에 있는 인덱스 데이터를 메모리에 캐시해두는 공간으로, 인덱스 검색 속도를 높여줍니다.
    > InnoDB 버퍼풀: 데이터와 인덱스 페이지를 모두 캐시하는 메모리 공간으로, 데이터 읽기/쓰기 성능을 향상시킵니다.

#### 핸들러 API

Handler 요청 : MySQL 엔진의 쿼리 실행기에서 스토리지 엔진에 보낸 읽기/쓰기 요청
Handler API : Handler 요청을 보낼 때 사용되는 API

### 4.1.2 MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아니라 스레드 기반이다. 스레드는 FOREGROUND와 BACKGROUND으로 나뉜다:

-   포그라운드 스레드: 클라이언트의 요청을 직접 처리하는 스레드
-   백그라운드 스레드: 내부 작업(정리, 최적화 등)을 처리하는 스레드

#### 포그라운드, 백그라운드 스레드 그림으로 이해하기

![[Pasted image 20241226104913.png]]

1. 포그라운드 스레드의 커넥션 연결
    - 사용자는 `포그라운드 스레드(커넥션 연결)`과 1:1로 매핑된다.
    - 따라서 포그라운드 스레드는 **최소한** MySQL 서버에 접속된 클라이언트의 수만큼 존재한다.
    - 포그라운드 스레드는 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
    - 참고로, 1:1 매핑은 커뮤니케이션 에디션 기준이다. 엔터프라이즈 에디션에서는 스레드 풀 모델을 사용할 수도 있다.
2. 포그라운드 스레드의 스레드 캐시
    - 클라이언트 사용자가 커넥션을 종료하면 해당 커넥션 담당 스레드는 다시 스레드 캐시로 되돌아간다.
    - 만약 스레드 캐시에 일정 개수 이상 대기중인 스레드가 있다면 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.
    - 왜 스레드 캐시를 사용하는가? → 새로운 연결마다 스레드를 생성하고 제거하는 비용을 줄이기 위해서
        - 엥 그럼 스레드 캐시와 스레드 풀은 뭐가 다른건데?
            - 스레드 캐시: 단순히 종료된 스레드를 보관했다가 재사용하는 개념
            - 스레드 풀: 미리 지정된 수의 스레드를 생성해두고 여러 커넥션이 이 스레드들을 공유하는 방식
3. 포그라운드 스레드의 데이터 가져오는 방식
    - 캐시&버퍼로부터 가져옴.
    - 만약 없다면 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어옴.
    - 디스크 쓰기작업도 포그라운드가 하는가?
        - MyISAM은 포그라운드 스레드가 처리
        - InnoDB는 백그라운드 스레드가 처리
4. 백그라운드 스레드
    - 로그 스레드: 로그를 디스크로 기록
    - 쓰기 스레드: InnoDB 버퍼 풀의 데이터를 디스크에 기록
        - DBMS에서 읽기 작업은 지연될 수 없으나, 쓰기 작업은 버퍼링을 통해 일괄 처리한다.
    - 데이터를 버퍼로 읽어 오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
    - Insert Buffer를 병합하는 스레드

#### 스레드 직접 살펴보기

![[Pasted image 20241226104238.png]]

### 4.1.3 메모리 할당 및 사용 구조

#### 기본 메모리 구조

-   MySQL의 메모리는 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분됨
    -   글로벌 메모리 영역: 모든 스레드가 공유하는 공통 영역
    -   로컬 메모리 영역: 각 클라이언트 스레드가 독립적으로 사용하는 영역
-   MySQL 서버 시작 시 운영체제로부터 **글로벌 메모리 영역**을 할당 받음
-   MySQL 서버는 클라이언트 연결이나 소트 등의 작업을 할 적에 추가 메모리가 필요한 경우 OS에 **로컬 메모리 영역**을 할당 받아 사용하고, 반환함

#### 글로벌 메모리 영역

-   클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당됨
-   필요한 경우 2개 이상의 메모리 공간을 할당받을 수 있으나, 이 역시 모든 스레드가 공유
-   주요 영역
    -   테이블 캐시: 테이블 정보를 캐싱
    -   InnoDB 버퍼풀: 테이블과 인덱스 데이터를 캐싱
    -   InnoDB 어댑티브 해시 인덱스: 자주 사용되는 데이터에 대한 해시 인덱스
    -   InnoDB 리두 로그 버퍼: 트랜잭션 로그를 버퍼링

#### 로컬 메모리 영역

-   클라이언트 스레드별로 독립적으로 할당되는 메모리 영역
-   필요한 경우에만 할당되고 해제되는 **임시 메모리 공간**
-   세션 메모리 영역 또는 클라이언트 메모리 영역이라고도 함
-   메모리 할당 방식
    -   커넥션이 열려있는 동안 계속 할당된 상태: 커넥션 버퍼, 결과 버퍼
    -   쿼리 실행 시에만 임시 할당: 정렬 버퍼, 조인 버퍼
-   주요 영역
    -   정렬 버퍼: ORDER BY 등 정렬 작업 시 사용
    -   조인 버퍼: 테이블 조인 작업 시 사용
    -   바이너리 로그 캐시: 바이너리 로그 생성 시 사용
    -   네트워크 버퍼: 클라이언트와의 통신 시 사용

### 4.1.4-4.1.5 플러그인과 컴포넌트

#### MySQL의 처리 영역 구분

-   MySQL 엔진 영역:
    -   대부분의 작업 처리
    -   SQL 파싱
    -   GROUP BY, ORDER BY 등 복잡한 처리
    -   스토리지 엔진으로의 명령 전달 (핸들러 사용)
-   스토리지 엔진 영역:
    -   실제 데이터 읽기/쓰기만 담당
    -   InnoDB, MyISAM 등의 엔진이 각자의 방식으로 처리

#### 플러그인 구조

-   주요 플러그인:
    -   스토리지 엔진
    -   인증
    -   전문 검색
    -   쿼리 재작성
-   한계:
    -   플러그인 간 통신 불가
    -   MySQL 서버에 직접 접근 (안전하지 않음)
    -   의존관계 설정 불가

#### 컴포넌트 구조 (MySQL 8.0+)

-   장점:
    -   컴포넌트 간 직접 통신
    -   안전한 캡슐화
    -   의존관계 설정
-   예: 비밀번호 검증 컴포넌트

### 4.1.6 쿼리 실행 구조

1. 쿼리 파서 : 쿼리문을 토큰으로 분리해 트리로 만들어냄
2. 전처리기 : 쿼리 파서가 만든 파서 트리를 기반으로 문장의 구조적 문제, 테이블 또는 컬럼 이름, 내장함수, 객체 존재 여부, 접근 권한 등을 확인함
3. 옵티마이저 : DBMS의 두뇌. 쿼리문을 저렴한 비용으로 가장 빠르게 처리할 방법을 결정함
4. 실행 엔진 : 옵티마이저가 만든 실행 계획대로 핸들러에게 요청하는 중간 관리자. 요청하고, 결과를 받아 또 요청하고 함.
5. 핸들러 (스토리지 엔진) : MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고, 디스크로부터 읽어오는 역할을 담당

### 4.1.8 쿼리 캐시

-   쿼리 캐시는 말 그대로 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL이 날아오면 그대로 응답하는 것.
-   결론부터 말하면 이제는 완전히 제거된 기능이다.
-   쿼리 캐시는 테이블의 데이터가 변경되는 경우, 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두 삭제해야 함. 심각한 동시 처리 성능 저하를 유발.

### 4.1.9 스레드 풀

#### 지원

스레드 풀 기능은 커뮤니티 에디션에선 지원하지 않는다. 엔터프라이즈 에디션에서 제공되는 기능이다. 만약 커뮤니티 에디션에서 스레드 풀 기능을 사용하고 싶다면 Percona Server에서 스레드 풀 플러그인 라이브러리를 커뮤니티 에디션에 설치하여 사용할 수 있다.

#### 스레드풀은 왜 쓰는가?

고정 개수의 스레드를 만들어놓고 그걸로 사용자 요청을 처리하면, CPU가 제한된 개수의 스레드 처리에만 집중할 수 있어 자원 소모를 줄일 수 있다. 만약 스레드풀이 없었다면 매번 연결마다 스레드를 만들고 없애야하기 때문이다.

#### 스레드풀 성능은?

스레드풀을 사용한다고 해서 성능이 눈에 띄게 올라가는 건 아니다. 스케줄링에 따라 CPU 시간 확보가 안 되면 오히려 쿼리 성능이 느려질 수도 있다.
물론 잘 유도해주면 CPU processor affinity도 높이고, conext switch도 줄일 수 있어 유용하다.

#### 스레드 개수는 몇 개가 적합한가?

Percona Server에서 제공하는 스레드 풀에서는 CPU 코어의 개수만큼 스레드 그룹을 생성한다. CPU 코어의 개수와 맞추는 것이 CPU processor affinity를 높일 수 있어 좋다. 스레드가 특정 CPU 코어에서 지속적으로 실행될 가능성이 높아져 CPU 캐시 히트 비율 (효율성)이 증가하기 때문이다.

#### 스레드 풀 플러그인에서 제공하는 선순위, 후순위 큐

Percona Server의 스레드 풀 플러그인은 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선선적으로 처리하는 기능도 제공한다.

다음과 같은 예시처럼 선순위 후순위 큐로 작업을 재배치할 경우 lock을 빨리 풀 수 있어 성능을 향상시킬 수 있다. (A,B,C는 사람을 의미함)

-   사용자로부터 요청이 유입된 순서
    -   `(A) BEGIN` - `(B) BEGIN` - `(C) BEGIN` - `(A) QUERY` - `(B) QUERY` - `(C) QUERY` - `(A) COMMIT` - `(B) COMMIT` - `(C) COMMIT`
-   Percona Server의 선순위 후순위 큐로 재배치된 순서
    -   `(A) BEGIN` - `(B) BEGIN` - `(C) BEGIN`- `(A) QUERY` - `(A) COMMIT` - `(B) QUERY` - `(B) COMMIT` - `(C) QUERY` - `(C) COMMIT`

### 4.1.10 트랜잭션 지원 메타데이터

#### 메타데이터란?

-   테이블의 구조 정보 (테이블 컬럼명, 각 컬럼의 데이터 타입, PK, FK, 인덱스 정보 등)
-   스토어드 프로그램 (데이터베이스 서버에 저장되어 실행되는 프로그램 코드들)
    -   종류 : 스토어드 프로시저, 스토어드 함수, 트리거, 이벤트 등

참고로 메타데이터를 '데이터 딕셔너리'라고도 부른다.

#### 파일 기반 메타데이터의 문제점

-   기존에는 메타데이터를 파일에다가 저장했음.
-   트랜잭션을 지원하지 않다보니, 테이블의 생성 또는 변경 도중 MySQL 서버가 비정상적으로 종료되는 경우 일관되지 않은 상태로 남는 문제가 발생했다. (all or nothing의 atomic함이 보장되지 않음)

#### 메타데이터를 InnoDB 테이블에 저장하는 방식

-   MySQL 8.0부터는 위와 같은 문제를 해결하기 위해 메타데이터를 InnoDB의 테이블에 저장하도록 개선되었다.
-   MySQL 8.0부터는 시스템 테이블과 메타데이터를 MySQL DB에 저장하고 있다. 모두 `mysql.ibd`라는 이름의 테이블스페이스에 저장된다.

    -   시스템 테이블 : MySQL 서버가 작동하는 데 기본적으로 필요한 테이블 ex. 사용자 인증 및 권한
    -   실제로 다음과 같이 `mysql.tables`를 조회해보면 '테이블 없음'이 아니라, '접근이 거절됨' 표시가 뜬다.

    ```shell
    mysql> SELECT * FROM mysql.tables LIMIT 1;
    ERROR 3554 (HY000): Access to data dictionary table 'mysql.tables' is rejected.
    ```

## 4.2 InnoDB 스토리지 엔진 아키텍처

-   InnoDB는 MySQL 스토리지 엔진 중 가장 많이 사용되는 엔진임
-   MySQL 스토리지 엔진 중 거의 유일하게 **레코드 기반의 잠금**을 제공함.
    -   이 덕분에 동시성 처리 및 안정성이 굿

![[Pasted image 20241228223343.png]]

### 4.2.1 프라이머리 키에 의한 클러스터링

#### InnoDB

-   InnoDB는 PK 값의 순서대로 클러스터링(군집화)되어 저장된다.
-   이 클러스터링의 크기는 페이지 단위이다.
-   덕분에 PK 기준으로 레인지 스캔하면 아주 빠르다.
-   세컨더리 인덱스보다 PK의 비중이 무조건 높을 수 밖에 없다. (세컨더리 인덱스로 조회를 하더라도, 결국 PK로 찾아가야 하기 때문에 '타고 들어가는' 형식이 된다.)
    -   '타고 들어가는' : 세컨더리 인덱스 → PK → 실제 데이터로 단계적으로 접근하는 방식
    -   세컨더리 인덱스에서 PK를 거쳐 실제 데이터를 찾아가는 방식을 '루스 인덱스 스캔'이라고 함

#### MyISAM

-   이와 달리 MyISAM 엔진에서는 클러스터링 키를 지원하지 않는다.
-   MyISAM에선 PK와 세컨더리 인덱스가 구조적으로 동등하다.
    -   PK는 단순히 UNIQUE 제약 조건을 가진 세컨더리 인덱스에 불과하다.
    -   모든 인덱스가 물리적인 레코드의 주소를 가진다.

#### 비교 이미지 (위: MyISAM / 아래: InnoDB)

![[Pasted image 20241229021044.png]]

### 4.2.2 외래 키 지원

#### 개념

-   부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스를 생성해주고, 무결성 체크(부모 테이블이나 자식 테이블에 데이터가 있는지 검증)해주는 기능이다.
    -   무결성 체크 과정에서 잠금이 여러 테이블로 전파되고, 이로 인해 데드락이 발생할 때가 많다.
-   실제 서비스에서는 이 검사 때문에 쓰기가 느려진다는 이유로, 외래 키 설정을 하지 않는 대신 직접 인덱스를 설정하고 무결성 자체는 애플리케이션 단에서 잡아주는 경우가 있다.
-   외래 키 생성 시 자동으로 인덱스까지 생성해주는 것은 InnoDB 스토리지 엔진의 고유한 기능이다. MyISAM 엔진은 외래 키를 지원하지 않는다.
    -   참고로 PostgreSQL은 외래 키와 무결성 검사는 지원하지만 자동 인덱스 생성은 지원하지 않는다.

#### 외래 키 체크 작업 잠시 멈춤

-   비상 상황에서 외래 키 관계에 대한 체크 작업을 일시적으로 멈추려면 `foreign_key_checks` 시스템 변수를 OFF하면 된다. 그러면 외래 키 무결성 검사가 멈추고 빨라진다.
    -   ON DELETE CASCASE와 ON UPDATE CASCADE 옵션도 무시된다.
-   다만 외래 키 체크 기능을 ON하기 전에 꼭 일관성을 맞춰 주어야 한다.

```shell
mysql> SET foreign_key_checks=OFF;
-- //작업 실행
mysql> SET foreign_key_checks=ON;
```

### 4.2.3 MVCC (Multi Version Concurrency Control)

-   **레코드 레벨**의 트랜잭션을 지원하는 DBMS가 제공하는 기능
-   MVCC의 목표는 **잠금을 사용하지 않는 일관된 읽기**를 제공하는 것
-   `Multi Version`: 하나의 레코드에 대해 여러 버전이 관리됨

#### 사례로 이해하기

```sql
CREATE TABLE member (
	m_id INT NOT NULL,
	m_name VARCHAR(20) NOT NULL,
	m_area VARCHAR(100) NOT NULL,
	PRIMARY KEY (m_id),
	INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
COMMIT;
```

![[Pasted image 20241229024925.png]]

이제 UPDATE로 홍길동 씨의 지역을 바꿔보자.

```SQL
UPDATE member SET m_area='경기' WHERE m_id=12;
```

![[Pasted image 20241229025407.png]]

이 상황에서 `SELECT * FROM member WHERE id=12`를 하면 서울이 나올까, 경기가 나올까?

격리 수준에 따라 다르다!

-   READ UNCOMMITTED (Level0)
    -   다른 트랜잭션에서 처리중인 커밋되지 않은 데이터를 읽을 수 있음
    -   위 예제가 READ UNCOMMITTED였다면, **버퍼 풀의 '경기'**가 나왔을 것이다.
-   READ COMMITTED (Level1)
    -   커밋한 데이터만 읽을 수 있다.
        -   REPEATABLE READ와 다른 점은, 한 트랜잭션 내에서도 매번 새로운 SNAPSHOT을 읽는다는 점이다. 이로 인해 Non-Repeatable Read가 발생할 우려가 있다.
    -   위 예제가 READ COMMITTED였다면, **언두 영역의 '서울'**이 나올 것이다.
-   REPEATABLE READ (Level2)
    -   트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 읽을 수 있다.
        -   READ COMMITTED와 다른 점은, 트랜잭션 시작 지점의 스냅샷을 일관되게 보여준다는 점이다.
    -   MySQL의 InnoDB의 기본 격리 수준임
    -   위 예제가 REPEATABLE READ였다면, **언두 영역의 '서울'**이 나올 것이다.
-   SERIALIZABLE (Level3)
    -   가장 높은 격리 수준으로, 완벽한 읽기 일관성을 제공하지만 동시성이 크게 떨어져 성능이 저하된다.
    -   당연히 '서울'

이후 COMMIT/ROLLBACK을 하게 되면 어떻게 될까?

-   COMMIT: 변경 작업 없이, 지금의상태를 영구적인 데이터로 만든다.
    -   다만, 커밋되자마자 언두 영역의 백업 데이터가 삭제되는 건 아니다. 이 언두 영역을 필요로하는 트랜잭션이 더이상 없을 경우 비로소 삭제된다.
-   ROLLBACK: 언두 영역의 데이터를 다시 InnoDB 버퍼 풀로 복구하고, 언두 영역의 내용을 삭제

#### 개인 궁금증: MySQL InnoDB의 MVCC와 PostgreSQL의 MVCC 차이

**postgreSQL의 레코드 저장 방식**

-   pg는 MySQL과 달리 물리 저장 구조가 PK 순서가 아니다. HEAP 구조로 저장된다.
-   pg에서는 Record 대신에 Tuple이라는 용어를 사용한다.

**MySQL과 동일한 예제로 비교해보기**

```SQL
CREATE TABLE member (
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(100) NOT NULL,
    PRIMARY KEY (m_id)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
COMMIT;
```

이 시점에서 Tuple의 형태는 다음과 같다:

```
xmin  | xmax | m_id | m_name  | m_area
------+------+------+---------+--------
1000  |    0 |   12 | 홍길동  | 서울
```

-   xmin이 1000인 이유: 트랜잭션 1000에서 해당 튜플이 생성됨 (임시로 1000번 트랜잭션이라고 가정)
-   xmax가 0인 이유: 아직 해당 튜플이 삭제되거나 업데이트되지 않음

이제 UPDATE해보기:

```SQL
UPDATE member SET m_area='경기' WHERE m_id=12;
```

이 시점에서 PostgreSQL은 MySQL InnoDB와 달리 다음과 같이 저장한다. MySQL은 언두 로그에 이전 데이터를 보관하는 반면, PostgreSQL은 같은 테이블 내에 새로운 버전의 튜플을 추가한다:

```
xmin  | xmax  | m_id | m_name  | m_area
------+-------+------+---------+--------
1000  | 1001  |   12 | 홍길동  | 서울    -- 이전 버전
1001  |     0 |   12 | 홍길동  | 경기    -- 새로운 버전
```

-   원본 튜플: xmax가 1001로 변경됨 (이 튜플이 트랜잭션 1001에서 수정됨을 의미)
-   새로운 튜플: xmin이 1001 (트랜잭션 1001에서 생성됨) / max가 0(아직 수정/삭제되지 않음)

```sql
BEGIN; -- 트랜잭션 ID: 1002로 가정
SELECT * FROM member WHERE m_id=12;
```

결과는 격리 수준에 따라 다음과 같이 결정된다:

-   READ UNCOMMITTED (Level0)
    -   PostgreSQL은 이 격리 수준을 제공하지 않는다. 최소 READ COMMITTED를 사용한다.
-   READ COMMITTED (Level1)
    -   트랜잭션 1001이 커밋되지 않았으므로. → "서울"
-   REPEATABLE READ (Level2)
    -   1002 트랜잭션 이전에 커밋된 사항을 응답 → "서울"

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

-   InnoDB의 MVCC 덕분에 잠금을 걸지 않고 읽기 작업을 수행할 수 있다.
-   특정 트랜잭션이 INSERT 중이더라도, 다른 읽기(SELECT) 작업을 진행하는 트랜잭션에서는 대기(잠금) 없이 바로 읽을 수 있다. 앞서 설명했듯 격리 수준에 따라 다르지만, InnoDB 버퍼 풀에서 읽든 언두 로그에서 읽든 바로 읽어서 응답해낼 수 있다.
-   이를 '잠금 없는 일관된 읽기'라고 한다.
-   단, 오랜 시간 동안 특정 트랜잭션이 활성상태라면 언두 로그를 삭제 못하고 유지해야 하다보니 MySQL 서버가 느려질 수 있다. 그러므로 트랜잭션이 시작됐다면 가능한 빨리 롤백/커밋을 해야한다.

### 4.2.5 자동 데드락 감지

-   InnoDB 스토리지 엔진이 내부적으로 데드락 detection을 진행한다.
-   데드락 감지 스레드를 통해 주기적으로 Wait-for list를 검사한다.
    -   데드락이 감지되면, 데드락에 얽힌 트랜잭션 중 하나를 찾아 강제 종료한다.
    -   트랜잭션들 중에서 언두 로그를 가장 적게 가진 트랜잭션이 롤백의 대상이 된다.
    -   롤백을 해도 언두 처리를 해야할 내용이 적기 때문에 만만하므로!
-   상위 레이어 MySQL 엔진에서 관리되는 `LOCK TABLES`명령은 InnoDB가 볼 수가 없다. 때문에 데드락 감지가 불확실할 수 있으므로 `innodb_table_locks` 시스템 변수를 활성화하여 감지를 허용해주자.
-   데드락 감지 스레드가 부담된다면 `innodb_deadlock_detect`를 OFF해서 비활성화할 수 있다.
    -   이 경우 데드락이 걸리면 무한 대기 가능성이 있다. 이를 방지하기 위해 `innodb_lock_wait_timeout`을 초 단위로 설정하여 타임아웃 설정을 추천한다.

### 4.2.6 자동화된 장애 복구

1. InnoDB의 기본 복구 메커니즘

    - MySQL 서버 시작 시 자동으로 미완료 트랜잭션과 부분 기록된 데이터 페이지를 복구
    - 일반적으로 매우 안정적이나 하드웨어 문제로 자동 복구가 불가능한 경우 발생 가능

2. innodb_force_recovery 옵션

    - 값의 범위: 1~6
    - 값이 커질수록 데이터 손실 가능성이 증가하고 복구 가능성은 감소
    - 복구 모드에서는 SELECT 외의 쿼리(INSERT, UPDATE, DELETE) 수행 불가
    - 문제 원인을 모를 경우 1부터 순차적으로 값을 올리며 시도

3. 주요 복구 모드별 특징

    - 1(SRV_FORCE_IGNORE_CORRUPT): 손상된 데이터/인덱스 페이지 무시
    - 2(SRV_FORCE_NO_BACKGROUND): 백그라운드 메인 스레드 미실행
    - 3(SRV_FORCE_NO_TRX_UNDO): 미완료 트랜잭션 롤백 건너뛰기
    - 4(SRV_FORCE_NO_IBUF_MERGE): 인서트 버퍼 내용 무시
    - 5(SRV_FORCE_NO_UNDO_LOG_SCAN): 언두 로그 무시
    - 6(SRV_FORCE_NO_REDO_LOG_SCAN): 리두 로그 무시

4. 복구 후 권장사항
    - MySQL 서버가 시작되면 mysqldump를 통한 데이터 백업
    - 백업된 데이터로 데이터베이스 재구축
    - 위 방법도 실패 시 최신 백업본과 바이너리 로그를 이용한 복구 시도

## 4.1 MySQL 엔진 아키텍처


MySQL은 크게 MySQL 엔진과 스토리지 엔진으로 구분함.

- 이 둘을 합쳐 그냥 MySQL 또는 MySQL 서버라고함.

### MySQL 엔진

클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룸.

### 스토리지 엔진

실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어옴.

MySQL엔진은 하나이지만 스토리지 엔진은 여러개가 될 수 있음.

```sql
CREATE TABLE test_table (fd1 INT, fd2, INT) ENGINE=INNODB;
```

- test_table에 INSERT, UPDATE, DELETE, SELECT, … 등의 작업 발생 시 InnoDB 스토리지 엔진이 담당

### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이 요청을 핸들러 요청이라 하고, 여기에 사용되는 API를 핸들러 API라고 함.


- MySQL은 프로세스 기반이 아니라 스레드 기반으로 동작
- 포그라운드(Foreground) 스레드, 백그라운드(Background) 스레드로 구분



- 포그라운드 스레드
    - MySQL 서버에 접속된 클라이언트의 수가 최소한의 개수
    - 주로 쿼리 문장을 처리
    - 커넥션을 종료하면 해당 스레드는 스레드 캐시로 되돌아감.
    - 데이터를 데이터 버퍼나 캐시로부터 가져옴.
        - 없는 경우, 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
    - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드에 위임.
- 백그라운드 스레드
    - InnoDB의 경우 아래 작업들이 백그라운드로 처리
        - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
        - 로그를 디스크로 기록하는 스레드
        - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
        - 데이터를 버퍼로 읽어 오는 스레드
        - 잠금이나 데드락을 모니터링하는 스레드
    - 로그 스레드(Log thread)와 쓰기 스레드(Write thread)가 가장 중요
    - 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만, 읽기 작업은 절대 지연될 수 없음.
    - 일반적으로 쓰기 작업은 버퍼링해서 일괄 처리하는 기능 탑재(InnoDB도 그러함)
    - MyISAM은 포그라운드 스레드가 쓰기 작업까지 함께 처리.

### 메모리 할당 및 사용 구조


- 글로벌 메모리 영역과 로컬 메모리 영역으로 구분 가능
- 글로벌 메모리 영역
    - MySQL 서버가 시작되면서 모든 메모리 공간 운영체제로부터 할당.
    - 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당.
    - 대표적으로 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼
- 로컬 메모리 영역(세션 메모리 영역)
    - 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용
    - 클라이언트가 MySQL 서버에 접속시 MySQL 서버에서는 클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드 할당.
    - 스레드별로 독리적으로 할당, 공유되어 사용되지 않음.
    - 메모리 공간을 신경 쓰지 않고 설정되므로, 적절한 메모리 공간을 설정하는 것이 중요.
    - 대표적으로 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼

### 플러그인 스토리지 엔진 모델

### 플러그인 스토리지 엔진 모델


- 검색어 파서, 사용자 인증을 위한 Native Authentication, Cache SHA-2 Authentication 등도 모두 플러그인으로 구현되어 제공
- 쿼리는 대부분의 작업이 MySQL 엔진에서 처리되고, 마지막 데이터 읽기/쓰기 작업만 스토리지 엔진에서 처리
- 복잡한 연산인 GROUP BY나 ORDER BY 등의 처리는 MySQL 엔진의 처리 영역이 쿼리 실행기에서 처리.
- 중요한것은 MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다는 것임.

### 컴포넌트

플러그인의 단점

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음.
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움.

MySQL 8.0 버전부터는 비밀번호 검증 기능이 컴포넌트로 변경되었음.

### 쿼리 실행 구조


- 쿼리 파서
    - 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어냄.
    - 기본 문법 오류는 이 과정에서 발견 → 사용자에게 오류 메시지 전달
- 전처리기
    - 파서 과정에서 만들어진 파서 트리를 기반으로 구조적인 문제가 있는지 확인.
    - 각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 객체의 존재 여부와 객체의 접근 권한 등을 확인 하는 과정 수행
- 옵티마이저
    - 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할.
    - DBMS의 두뇌로, 해당 책의 내용은 대부분 옵치마이저가 선택하는 내용을 설명할정도로 중요하고 영향범위가 넓음.
- 실행 엔진
    - 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발
    - 예를 들어, 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 한다면,
        - 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
        - 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
        - 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
        - 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
    - 즉, 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행
- 핸들러
    - MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할 ⇒ 결국 스토리지 엔진을 의미

### 쿼리 캐시

- 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할
- SQL 실행 결과를 메모리에 캐시 ⇒ 동일 SQL 실행 시 테이블을 읽지 않고 즉시 결과를 반환.
- 테이블의 데이터가 변경 시 캐시에 저장된 결과 중 관련 데이터는 모두 삭제 ⇒ 동시 처리 성능 저하.
- MySQL 8.0 에서는 완전히 제거. 관련 시스템 변수도 모두 제거.

### 스레드 풀

- 엔터프라이즈 에디션은 스레드 풀 기능을 제공하지만, 커뮤니티 에디션은 지원하지 않음.
- Percona Server에서 제공하는 스레드 풀 기능을 기준으로 설명
- 커뮤니티 에디션에서 스레드 풀 기능을 사용하고자 한다면, 동일 버전의 Percona Server에서 스레드 풀 플러그인 라이브러리를 MySQL 에디션 서버에 설치해서 사용.
- 스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여, 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적.
- 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드물다.
- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단.
- 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공.

### 트랜잭션 지원 메타데이터

- 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 `데이터 딕셔너리` 또는 `메타데이터`라고 함.
- MySQL 5.7 까지는 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리

  ⇒ 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 있었음.

- MySQL 8.0 버전부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선.
- 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장하고 있음.
- mysql DB는 통쨰로 mysql.ibd라는 이름의 테이블스페이스에 저정됨
    - *.ibd 파일과 함께 특별히 주의해야함.

## 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용 가능한 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공함.

⇒ 높은 동시성 처리 가능, 안정적, 성능 뛰어남.


### 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 있음.
    - 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻.
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용.
    - 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있음.
- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않음.
    - 프라이머리 키와 세컨더리 인덱스는 구조적으로 별 차이 없음.
    - 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐임.
    - 모든 인덱스는 물리적인 레코드의 주소값을 가짐.

### 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원 ⇒ MyISAM이나 MEMORY 테이블에서는 사용 할 수 없음!
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요
- 변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업 필요. ⇒ 잠금이 여러 테이블로 전파되고, 그로 인해 데드락 발생할 때가 많음.

### MVCC

- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있음.
- InnoDB는 언두 로그를 이용해 이 기능을 구현함.
- READ COMMITED 상태인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터를 어떻게 변경하는지를 보자.
- UPDATE문이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값인 ‘경기’로 업데이트된다.


- InnoDB는 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방함.
- 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 없데이트돼 있을 수도 있고 아닐 수도 있다
- MySQL 서버의 시스템 변수에 설정된 격리 수준에 따라 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 쿼리롤 작업 중인 레코드를 조회했을 때 어디 데이터를 조회할지가 달라진다.
- READ_UNCOMMITTED인 경우에는 InnoDB의 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환.
- READ_COMMITTED나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우에는 아직 커밋되지 않았기 떄문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환함.

⇒ 이러한 과정을 MVCC라고 표현함.

- 즉, 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조임.

### 잠금 없는 일관된 읽기

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행함.
- 잠금을 걸지 않아 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업ㅇ 가능.
- 격리 수준이 SERIALIZABLE이 아니면 INSERT와 연결되지 않은 순수한 SELECT 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

  ⇒ 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- 오랜 시간 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있음.
- 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기때문에 발생 ⇒ 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋음.

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태(Wait-for List)로 관리함.
    - 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료.
    - 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상이 됨.
- 일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사개헛 데드락을 찾아내는 작업은 크게 부담되지 않음.
- 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐.
    - 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못해 대기하면서 서비스에 악영향.
    - innodb_deadlock_detect 시스템 변수의 값을 OFF로 설정해 해당 스레드를 꺼버리면됨.

      ⇒ 데드락이 발생하면 무한 대기에 놓임

        - innodb_lock_wait_timeout 시스템 변수의 값을 수정해 잠금을 획득하지 못한 트랜잭션을 일정 시간 후에 종료시키는 방법 사용

### 자동화된 장애 복구

- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재되어 있음.
    - MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행됨.
- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않음.
- MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 자동으로 복구를 못 하는 경우가 발생할 수 있음.
    - 한번 문제가 생기면 복구하기가 쉽지 않음.
    - InnoDB 데이터 파일은 MySQL 서버가 시작될 때 항상 자동 복구를 수행하지만, 자동으로 복구될 수 없는 손상이 있다면 MySQL 서버는 종료되 버림.
    - innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 해야함.

### InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
    - 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 함.
- 일반적인 애플리케이션에서는 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경해서 랜덤한 디스크 작업을 발생시킴.
- 버퍼 풀이 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있음.

### 버퍼 풀의 크기 설정

- 버퍼 풀의 크기는 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정해야 함.
- 레코드 버퍼는 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간을 말함.
    - 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수 있음.
- MySQL 5.7 버넞부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선되었음.

### 버퍼 풀의 구조

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd9eb0a2-9c82-43da-92ea-939474e849bb/fba6e648-5dd8-4beb-a923-d7ee79bb95e8/7fc3981b-6c92-4a41-b78b-0d3b71a7527b.png)

- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 LRU 리스트와 플러시 리스트, 프리 리스트라는 3개의 자료 구조를 관리함.
- InnoDB 스토리지 엔진에서 데이터를 찾는 과정을 다음과 같음
    - 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사.
        - InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
        - 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
            - 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
    - 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
    - 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
    - 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼 풀에서 제거 된다. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU 헤덩 부분으로 옮겨진다.
    - 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가.
- 플러시 리스트는 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리함.

### 버퍼 풀과 Redo 로그

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd9eb0a2-9c82-43da-92ea-939474e849bb/5eb85731-8cd2-4237-a88f-1b20adc83e69/f1f667e6-82b3-442c-8204-67cd4b234c78.png)

- InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능은 나빠짐.
- 하지만 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있는데, 버퍼 풀의 메모리 공간만 단수히 늘리는 것은 데이터 캐시 기능만 향상시키는 것이다.
- InnoDB의 버퍼 풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께 INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 더티 페이지도 가지고 있다.

### 버퍼 풀 플러시

- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 아래와 같이 2개의 플러시 기능을 백그라운드로 실행함.

### 1. Flush List Flush (변경된 데이터 동기화)

- 더티 페이지(변경된 페이지)들을 변경 시점 순서대로 디스크에 기록
- 클리너 스레드(Cleaner Thread)가 이 작업을 담당
- Adaptive Flush 기능으로 자동 최적화 지원

- `innodb_page_cleaners`: 클리너 스레드 수 조정
- `innodb_max_dirty_pages_pct`: 버퍼 풀의 더티 페이지 최대 비율 설정 (기본값 90%)
- `innodb_max_dirty_pages_pct_lwm`: 더티 페이지 동기화 시작 임계값
- `innodb_adaptive_flushing`: Adaptive Flush 기능 활성화 여부

1. 더티 페이지 관리
    - 과도한 더티 페이지는 디스크 I/O 버스트 유발 가능
    - 적절한 임계값 설정으로 점진적 동기화 구현
2. Adaptive Flush
    - Redo 로그 증가 속도 모니터링
    - 버퍼 풀 상태에 따른 자동 조절
    - 시스템 부하 균형 유지

### 2. LRU List Flush (메모리 공간 확보)

- LRU(Least Recently Used) 알고리즘 기반 페이지 관리
- 사용 빈도가 낮은 페이지를 대상으로 수행
- 새로운 페이지를 위한 공간 확보가 주 목적

### 프로세스

1. LRU 리스트 스캔
2. 더티 페이지 발견 시 디스크 동기화
3. 클린 페이지는 Free 리스트로 이동
4. 결과적으로 새로운 페이지를 위한 공간 확보

### MySQL 버퍼 풀 상태 관리

버퍼 풀의 효율적인 관리는 MySQL 성능에 직접적인 영향을 미치는 핵심 요소입니다. 특히 서버 재시작 시 발생하는 콜드 스타트 현상을 방지하기 위한 다양한 기능들이 버전별로 발전해왔습니다.

### 버퍼 풀 Warming Up의 중요성

- 디스크 I/O는 메모리 접근보다 수백~수천 배 느림
- 적절한 Warming Up으로 성능이 수십 배 향상 가능
- 서비스 초기 응답 시간 안정화에 필수적

`버전별 Warming Up 방식`

- MySQL 5.5 이전
    - 수동적인 Warming Up 방식 사용
    - 서비스 시작 전 주요 테이블 Full Scan 수행
    - 인덱스 강제 로드 필요

```sql

SELECT COUNT(*) FROM main_table FORCE INDEX(PRIMARY);
SELECT COUNT(*) FROM main_table FORCE INDEX(idx_column);

```

- MySQL 5.6 이후
    - 버퍼 풀 덤프/로드 기능 도입
    - 시스템 변수를 통한 제어 가능

```sql

SET GLOBAL innodb_buffer_pool_dump_now = ON
SET GLOBAL innodb_buffer_pool_load_now = ON;

```

### 버퍼 풀 모니터링

### MySQL 5.6 - 8.0

- `information_schema.INNODB_BUFFER_POOL_STATS`
    - 버퍼 풀 전반적인 상태 확인
    - 페이지 수, 히트율 등 확인 가능

```sql
SELECT * FROM information_schema.INNODB_BUFFER_POOL_STATS;

```

- `information_schema.INNODB_BUFFER_PAGE`
    - 페이지별 상세 정보 제공
    - 주의: 대용량 버퍼 풀에서 조회 시 성능 저하 발생

```sql
SELECT
    TABLE_NAME,
    COUNT(*) AS PAGE_COUNT,
    SUM(IF(IS_HASHED = 'YES', 1, 0)) AS HASHED_PAGES
FROM information_schema.INNODB_BUFFER_PAGE
GROUP BY TABLE_NAME;

```

### Double Write Buffer

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd9eb0a2-9c82-43da-92ea-939474e849bb/6daef69e-a4ed-454a-a917-883c44b8ac4d/1954e830-4b42-4922-8d52-81f6826442a5.png)

redo 로그는..

- 공간 효율성을 위해 페이지의 변경된 부분만 기록
- 전체 페이지가 아닌 변경 사항만 저장

Partial-Page는..

- Dirty Page 플러싱 중 일부만 기록되는 현상
- 페이지 일부만 기록된 상태에서 장애 발생 시 복구 불가능
- 데이터 무결성 위협 요소

### Double Write 동작 방식

1. Dirty Page 묶음('A'~'E')을 Double Write 버퍼에 일괄 기록
2. Double Write 버퍼 기록 완료 후 실제 데이터 파일에 쓰기 수행

- 정상 동작 시: Double Write 버퍼 내용은 사용되지 않음
- 장애 발생 시:
    - InnoDB 재시작 시점에 검증 수행
    - Double Write 버퍼와 데이터 파일 페이지 비교
    - 불일치 발견 시 Double Write 버퍼의 내용으로 복구

### Undo 로그

- DML 연산 실행 전 데이터의 이전 상태를 보관하는 로그
- INSERT, UPDATE, DELETE 작업에 대한 변경 이전 데이터 백업

### Undo 로그의 진화

- MySQL 5.5 이전의 한계
    - Undo 로그 공간의 비탄력적 운영
        - 한번 증가한 공간 축소 불가
        - 대용량 데이터/장기 트랜잭션 시 공간 낭비
        - 과도한 백업 오버헤드 발생

- MySQL 5.7 이후 개선사항
    - 공간 관리의 유연성 확보
    - MySQL 8.0의 주요 개선
        - 순차적 Undo 로그 사용으로 디스크 공간 최적화
        - 동적 Undo 테이블스페이스 관리 가능

### Undo 로그 모니터링

모니터링 방법

```sql
sql
Copy
SHOW ENGINE INNODB STATUS \G

```

- 활성 트랜잭션 상태 확인
- 장기 실행 트랜잭션 식별
- 리소스 사용량 분석

### Undo 테이블스페이스 구조와 관리

- 구조적 특징
    - 1~128개의 롤백 세그먼트 포함
    - 각 롤백 세그먼트는 복수의 Undo Slot 보유
    - 트랜잭션당 최대 4개 Undo Slot 사용

용량 관리

- 기본 설정(16KB)으로 약 131,072 트랜잭션 동시 처리 가능
- MySQL 8.0의 동적 관리 기능

```sql

CREATE UNDO TABLESPACE tablespace_name;

DROP TABLESPACE tablespace_name;

```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd9eb0a2-9c82-43da-92ea-939474e849bb/e397aa5b-d94a-43a1-9658-b44448e2e5f2/a96cf966-0640-4025-b811-19ae05149ee8.png)

### 체인지 버퍼

Change Buffer는 인덱스 페이지 업데이트의 효율성을 높이기 위한 InnoDB의 메모리 영역입니다.

- 인덱스 업데이트 발생 시..
    - 대상 페이지가 버퍼 풀에 존재 → 즉시 업데이트
    - 대상 페이지가 버퍼 풀에 부재 → Change Buffer에 임시 저장
- Unique Index는 Change Buffer 사용 불가
    - 중복 검사 필요성으로 인한 제약
- MySQL 8.0 이전 버전: INSERT 작업만 지원

### 리두 로그 및 로그 버퍼

- 리두 로그
    - 데이터베이스의 Durability(지속성) 보장
    - 비정상 종료 시 데이터 복구 메커니즘 제공
    - 트랜잭션의 영속성 보장
    - 데이터 변경 사항을 순차적으로 기록
    - Write-Ahead Logging(WAL) 방식 사용
        - 데이터 파일 변경 전 로그 먼저 기록
        - 순차적 I/O로 성능 최적화

- 커밋된 트랜잭션 복구
    - 상황: 커밋은 됐으나 데이터 파일 미반영
    - 해결: Redo 로그에서 변경사항 재적용



- 롤백된 트랜잭션 처리
    - 상황: 롤백됐으나 데이터 파일에 기록된 경우
    - 용도: 트랜잭션 상태 추적 및 관리

### 어댑티브 해시 인덱스

Adaptive Hash Index(AHI)는 InnoDB에서 제공하는 자동 최적화 인덱스 메커니즘으로, 자주 접근하는 데이터에 대한 해시 기반 빠른 접근을 제공합니다.

- B-Tree 인덱스를 기반으로 동작
- 자주 접근하는 데이터에 대해 자동으로 해시 인덱스 생성
- 버퍼 풀 내의 데이터 페이지만 대상으로 관리
- B-Tree 인덱스 ID + 실제 키 값의 조합
- 전체 엔진에 단일 AHI 존재
    - 인덱스 고유번호로 구분 필요

- MySQL 8.0의 개선사항

  파티션 기능 도입으로 경합 감소


```sql
SET GLOBAL innodb_adaptive_hash_index_parts = value;
```

### 모니터링

```sql
SHOW ENGINE INNODB STATUS\G

```

- 해시 인덱스 사용 통계 확인
- 효율성 분석 가능

### InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

## 시대별 기본 스토리지 엔진

### MySQL 5.5 이전

- MyISAM이 기본 스토리지 엔진
- 시스템 테이블도 대부분 MyISAM 사용

### MySQL 5.5

- InnoDB가 기본 스토리지 엔진으로 전환
- 일부 시스템 테이블은 여전히 MyISAM 사용

### MySQL 8.0

- 모든 시스템 테이블이 InnoDB로 마이그레이션
- 완전한 InnoDB 중심 아키텍처로 전환

## 현재 상황

- InnoDB가 표준 스토리지 엔진으로 자리잡음
- MyISAM과 MEMORY 엔진은 레거시 상태
    - 지원 중단 가능성 존재
    - 새로운 프로젝트에서 사용 비권장
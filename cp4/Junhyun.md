# 4.1 MySQL 엔진 아키텍쳐
## MySQL의 전체 구조
MySQL 서버 = MySQL 엔진 + 스토리지 엔진
### MySQL 엔진
- 요청된 SQL문장을 분석하거나 최적화 하는 등 DBMS의 두뇌에 해당하는 처리

`커넥션 핸들러`: 클라이언트로부터 접속, 쿼리 요청을 처리함.
`SQL 파서` 및 `전처리기`
`옵팁마이저`: 쿼리의 최적화된 실행

### 스토리지 엔진
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 읽어는 부분
- MySQL 서버에서 MySQL 엔지은 하나지만 스토리지 엔진은 여러개 동시 사용 가능
- InnoDB(버퍼 풀)
- MyISAM(키 캐시)

### 핸들러 API
MySQL엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을때 각 스토리지 엔지에 하는 요청 = 핸들러 요청
이때 사용되는 API = 핸들러 API

아래 명령으로 핸들러 API를 통해 얼마나 많은 데이터 작업이 있었는지 확인 가능
```mysql
SHOW GLOBAL STATUS LIKE 'Handler%';
```

## MySQL 스레딩 구조
![Image](https://github.com/user-attachments/assets/8d35ffc0-3da5-4e39-ba26-ee0dcd32226f)

- MySQL서버는 프로세스 기반이 아니라 스레드 기반으로 작동
- `포그라운드 스레드`, `백그라운드 스레드`로 구분
실행 중인 스레드 목록
```mysql
SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER BY type, thread_id;
```
`thread/sql/one_connection` 이것만 실제 사용자의 요청을 처리하는 포그라운드 스레드
동일 이름의 스레드가 2개 이상인 것은 서버의 설정 내용에 의해 동일 작업을 병렬로 처리하는 경우

### 포그라운드 스레드(클라이언트 스레드)
- 최소한 MySQL 서버에 접속한 클라이언트 수만큼 존재
- 주로 각 클라이언트 사용자가 요청하는 쿼리 문장 처리
- 작업을 마치고 커넥션을 종료하면 담당 스레드는 다시 스레드 캐시로 되돌아감.
- 스레드 케시에 일정 개수 이상이 대기 중이면 종료시켜 스레드 캐시의 개수 유지
- InnoDB테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리

### 백그라운드 스레드
`InnoDB`
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 `Log thread`와 버퍼의 데이터를 디스크로 내려쓰는 `Write tread`이다.
MySQL5.5 부터 `innodb_write_io_threads`와 `innodb_read_io_threads`를 설정하여 스레드 개수를 2개 이상 지정할 수 있음.

InnoDB에서 읽기는 주로 클라이언트 스레드에서 처리하기 때문에 읽기 스레드는 많을 필요없음.
쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기때문에
- 내장 디스크: 2~4개
- DAS, SAN: 충분히 설정

쓰기 작업은 지연(버퍼링)되어 처리될 수 있다.
읽기는 지연될 수 없다.
대부분 쓰기는 버퍼링해서 일괄 처리하는 기능 탑재(InnoDB 포함)
데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다릴 필요없음.

## 메모리 할당 및 사용 구조
`글로벌 메모리`(시작되며 운영체제로부터 할당), `로컬 메모리`로 구분 가능
![Image](https://github.com/user-attachments/assets/93aabfd0-9c4d-42c0-a222-50276f98c485)

### 글로벌 메모리 영역
스레드 수와 무관하게 하나의 메모리 공간만 할당됨.(필요에 따라 2개이상 가능, 모든 스레드의 의해 공유됨)
### 로컬 메모리 영역(세션 메모리 영역)
클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역

클라이언트 MySQL 서버 접속 -> 스레드를 하나씩 할당
`로컬 메모리 영역` = `클라이언트 메모리 영역` = 클라이언트 스레드가 사용하는 메모리 공간
`세션`: 클라언트와 MySQL 서버 사이의 커넥션

각 클라이언트 스레드별로 독립적 할당. 절대 공유 안 됨.
각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우 MySQL이 공간을 할당하지 않을 수도 있다.(sort 버퍼, join 버퍼)
- 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간: `커넥션 버퍼`, `결과 버퍼`
- 쿼리 실행 순간에 할당 후 해제되는 공간: `sort 버퍼`, `join 버퍼`

### 플러그인 스토리지 엔진 모델
`핸들러(핸들러 객체)`: 프로그래밍 언어에서 어떤 기능을 호출하기 위해 사용하는 객체
MySQL서버에서 
MySQL엔진 = 사람
스토리지 엔진 = 자동차
MySQL엔진이 스토리지 엔진을 조정하기 위해 핸들러 사용
MySQL엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 `핸들러`를 통해야함.

### 컴포넌트
8.0 부터 플러그인 아키텍처의 단점을 극복하고 이를 대체함.

### 쿼리 실행 구조
![Image](https://github.com/user-attachments/assets/23fe14c7-e1c3-4f1a-949b-83ff45ccf9ba)
### 쿼리 파서
사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리하여 트리 형태의 구조로 만들어내는 작업을 의미한다.
쿼리 문장의 기본적인 문법 오류는 이 단계에서 발견되고 사용자에게 메시지 전달.
### 전처리기
파서 트리를 바탕으로 쿼리 문장에 구조적인 문제가 있는지 확인한다.
테이블 이름이나 컬럼 이름, 내장 함수 존재 여부, 객체의 접근 권한 등을 확인한다.
### 옵티마이저
쿼리 문장을 가장 저렴한 비용으로 가장 빠르게 처리하는 결정, 두뇌
### 실행 엔진
손과 발
만들어진 계획대로  각 핸들러에게 요청해 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.
### 핸들러(스토리지 엔진)
MySQL 서버 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크에 저장하고 디스크로 부터 읽어오는 역할.
핸들러 = 스토리지 엔진
---
# 4.2 InnoDB 스토리지 엔진 아키텍처
- 레코드 기반 잠금 제공
- 높은 동시성 처리 가능
![Image](https://github.com/user-attachments/assets/81694b5e-000a-4860-9012-9eba86630d86)
## 프라이머리 키에 의한 클러스터링
프라이머리 키 = 클러스터링 인덱스
- 기본은 프라이머리키 기준으로 클러스터링 되어 순서대로 디스크에 저장.
- 모든 세컨더리 인덱스는 프라이머리 키의 값을 논리적 주소로 사용
- 프라이머리키 이용한 레인지 스캔 빠름
- 쿼리 실행 계획에서 프라이머리키가 다른 보조 인덱스에 비해 비중이 높게 설정됨.

## 외래 키 지원
- 스토리지 엔진 레벨에서 지원
- 부모와 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요
- 변경 시 부모 자식에 데이터가 있는지 체크
- 잠금이 여러 테이블로 전파되고 데드락 많이 발생. 
```mysql
SET foreign_key_checks=OFF;
```
왜래키 체크를 일시적으로 해재해 레코드 작업을 하고 다시 일관성을 맞춰준 다음 활성화해야함.

## MVCC(Multi Version Concurrency Control)
- 레코드 레벨의 트랜잭션 지원하는 DBMS의 기능
- 잠금을 사용하지 않는 일관된 읽기 제공
- InnoDB는 undo log를 이용해 MVCC를 구현


## Non Locking Consistent Read

## 자동 데드락 감자

## 자동화된 장애 복구

## InnoDB 버퍼 풀

## Double Write Buffer

## undo log

## 체인지 버퍼

## redo log 및 로그 버퍼

## 어댑티브 해시 인덱스

## InnoDB 스토리지 엔진과 비교